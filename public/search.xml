<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[跨平台好用且小巧的pdf阅读器]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%A5%BD%E7%94%A8%E4%B8%94%E5%B0%8F%E5%B7%A7%E7%9A%84pdf%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要在跨平台的PDF阅读器中，Foxit阅读器还是比较不错的，但是Foxit 在linux下的变现还是有点令人不大满意，首先是看英文文献中，做notes很不convenient，没有快捷键使用注释工具，还不能取词，复制有时也必须在选择模式下才能复制，总之很不方便。下面给推荐两款跨平台，windows和linux都好用的PDF阅读和编辑的软件 master pdf editor5 （破解后很好用哦） Pdf studio viewer 2018(免费版可以做笔记很好用) Foxit Reader（感觉linux里一般般，取词不行，应该是快捷键冲突和复制内容有时抽风） Okular （差强人意吧，但是没什么科夸赞的） master pdf editor5 官方地址Master pdf editor is the most popular and featured rich commercial Linux pdf editor available in the market. You can do almost everything ranging from creating and editing a pdf file to signature handling and editing scanned documents. It provides a wide range of features including add or edit text, images, notes into the pdf documents, offers powerful annotation tools, ability to edit pdf forms etc. Though Master PDF Editor is a proprietary application, still you can do some basic task by using the free version. But digital signatures, encryption, and watermarks are not available in the free version. but there have some approch to get it by crick. master pdf editor5 破解版linux安装教程linux下从get-masterpdfeditor官方下载最新版rpm或者其他方式安装，下面以rpm安装为例1234porter@porter-Aspire:~$ cd ~porter@porter-Aspire:~$ wget https://code-industry.net/public/master-pdf-editor-5.4.10_qt5.x86_64.rpmporter@porter-Aspire:~$ dpkg -i ./master-pdf-editor-5.4.10_qt5.x86_64.rpmporter@porter-Aspire:~$ masterpdfeditor5 # 或者直接去软件中心打开这个安装好的软件 master-pdf-editor软件将会运行界面效果如下 离线激活教程Off Line Activation In order to activate Master PDF Editor in autonomous mode, preform following actions: Double click Master PDF Editor icon on your desktop and choose Help -&gt; Register… Set Offline Activation checkbox on. Activation Code field will appear near Registration Code field. System will also generate unique identifier for you (ID is selected on screenshot below). 出现如下的激活界面： 到此不要看下面一段官方购买的激活教程，我们跳过， 12345Please, copy-paste to e-mail and send ID and Registration Code to our e-mail address support@code-industry.net.Please, inform your Order ID or e-mail address that you used for purchasing! Letter without this information will be ignored!After you receive the response with activation code, do not type it in manually. Instead, copy-paste it to Activation Code field and paste registration code to Registration Code field and then click Activate. 好了，跳转到这，现在告诉你们如何用免费的手段激活 [1.] 找台windows机器，在windows上运行破解软件Keygen.exe [2.] 将 ##masterpdfeditor-5-register## 图片中的ID，复制到破解软件中 [3.] 然后回车，此时破解软件会出现如下激活码信息 [4.] 将破解替换文件文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(linux在/opt/master pdf/) [5.] 输入激活码到上图对应的填写位置,点击激活 效果如下 我提供的破解文件里面包含如下文件，exe是windows环境中运行的。rpm是linux中运行的。 windows下从get-masterpdfeditor官方下载最新版exe破解步骤 [1.] 直接安装exe [2.] 将破解替换文件文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(windows桌面快捷键右键软件安装位置) [3.] 运行激活软件keygreen.exe产生激活码 [4.] 运行master pdf ，将ID复制出来填写到kegreen.exe后回车，keygreen 将产生激活码，切换到master pdf 填写激活码 [5.] 破解成功 软件汉化参考地址Master PDF Editor怎么设置中文界面 让你的操作更方便 附件供下载331×××@q×.com: master pdf 破解版下载链接: https://pan.baidu.com/s/1iGH2394KU7nG_lde7hRy2Q 提取码: kra8 复制这段内容后打开百度网盘手机App，操作更方便哦 如果软件链接失效可以关注我的telegram并私信给我: @Porter_Pan 文章写作技巧： 12345+ 1.写+ 2.的+ 的+ 对对对+ 的 效果 1.写 2.的 的 对对对 的 123456破解步骤- 1. 直接安装exe - 2. 将[破解替换文件](/appendix/Crack/)文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(windows桌面快捷键右键软件安装位置)- [3.] 运行激活软件keygreen.exe产生激活码- [4.] 运行master pdf ，将ID复制出来填写到kegreen.exe后回车，keygreen 将产生激活码，切换到master pdf 填写激活码- [5.] 破解成功 效果 破解步骤 直接安装exe 将破解替换文件文件家中的两个x86/x64根据你自己电脑是64位还是32位选择性复制到你的安装目录中(windows桌面快捷键右键软件安装位置) [3.] 运行激活软件keygreen.exe产生激活码 [4.] 运行master pdf ，将ID复制出来填写到kegreen.exe后回车，keygreen 将产生激活码，切换到master pdf 填写激活码 [5.] 破解成功]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习-深度学习顶级会议]]></title>
    <url>%2F%E9%98%85%E8%AF%BB%E6%80%BB%E7%BB%93-ICLR%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E9%A1%B6%E7%BA%A7%E4%BC%9A%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要 ICLRthe international conference on learning representations缩写，由位列深度学习三大巨头之二的 Yoshua Bengio 和 Yann LeCun 牵头创办。 The International Conference on Learning Representations (ICLR) is a machine learning conference held every Spring. The conference includes invited talks as well as oral and poster presentations of refereed papers. The first ICLR was held in Scottsdale, Arizona[1]. Since its inception in 2013, ICLR has employed an open peer review process to referee paper submissions (based on models proposed by Yann LeCun[2]). In 2019, there were 1591 paper submissions, of which 500 accepted with poster presentations (31%) and 24 with oral presentations (1.5%) ICML是 International Conference on Machine Learning的缩写即国际机器学习大会。ICML如今已发展为由国际机器学习学会（IMLS）主办的年度机器学习国际顶级会议。 NIPSNeural Information Processing Systems，神经信息处理系统大会是人工智能和机器学习领域最重要的盛会。每年，来自计算机科学领域的各路专家和业界人士都会共聚一堂，共同讨论和分享有关人工智能的前沿想法。而作为大会学术内容最重要的部分，会议论文是众人关注的焦点。 AAAI:AAAI Conference on Artificial IntelligenceIJCAI:International Joint Conferences on AIICRA:International Conference on Robotics and AutomationIROS:International Conference on Intelligent Robots and SystemsAAMAS:International Conference on Autonomous Agents and Multiagent SystemsRSS:Robotics: Science and SystemsICCV:International Conference on Computer VisionCVPRConference on Computer Vision and Pattern RecognitionCVPR是IEEE Conference on Computer Vision and Pattern Recognition的缩写，即IEEE国际计算机视觉与模式识别会议。该会议是由IEEE举办的计算机视觉和模式识别领域的顶级会议。 简介编辑 国际计算机视觉与模式识别会议（CVPR）是IEEE一年一度的学术性会议，会议的主要内容是计算机视觉与模式识别技术。CVPR是世界顶级的计算机视觉会议（三大顶会之一，另外两个是ICCV和ECCV），近年来每年有约1500名参加者，收录的论文数量一般300篇左右。本会议每年都会有固定的研讨主题，而每一年都会有公司赞助该会议并获得在会场展示的机会。 引用来自百度百科 ECCV:European Conference on Computer Vision]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.18 ubuntu下安装OpenCV 3.4.3]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-18-opencv-%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[摘要解决ubuntu 中安装opencv遇到的各种水土不服 下载 安装 ##下载OpenCV 源码 安装依赖包1234567sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff5-dev libdc1394-22-dev sudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev liblapacke-devsudo apt-get install libxvidcore-dev libx264-dev sudo apt-get install libatlas-base-dev gfortran sudo apt-get install ffmpeg 作者：BlainWu来源：CSDN原文：https://blog.csdn.net/qq_22945165/article/details/84312374版权声明：本文为博主原创文章，转载请附上博文链接！ 下载、安装从第三方源中下载（解决官方github下载网速过慢的问题）123https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/opencv-3.4.3.zip（https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/opencv_contrib-3.4.3.tar.gz）#目前这个control不用下载，以后需要可以下载安装 解压 12cd /你的解压路径/opencv/mkdir ./build cmake 12cd buildcmake -D CMAKE_BUILD_TYPE=Release -D CMAKE_INSTALL_PREFIX=/usr/local .. make 1make -j4 安装 1sudo make install 编译中会出现的问题 ippicv_2017u3_lnx_intel64_general_20180518.tgz下载失败 进入opencv解压的文件路径中 —&gt; 找到你的解压路径/opencv-3.4.3/3rdparty/ippicv/ippicv.cmake的文件。 编辑文件：ippicv.cmake 编辑ippicv.cmake内容,替换如下的内容 123456ocv_download(FILENAME $&#123;OPENCV_ICV_NAME&#125; HASH $&#123;OPENCV_ICV_HASH&#125; URL "$&#123;OPENCV_IPPICV_URL&#125;" "$ENV&#123;OPENCV_IPPICV_URL&#125;" "file:///home/blain/Downloads/"# “file:///home/blain/Downloads/“# 这个为你手动下载的文件所在的路径 需手动下载的包的地址如下，自己手动下载，建议存放在opencv解压后的文件夹中方便管理1https://ftp.osuosl.org/pub/blfs/conglomeration/opencv/ippicv_2017u3_lnx_intel64_general_20180518.tgz 我的下载存放地址就是 home/blain/Downloads 。 修改完成，重新cmake 即可]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>OpenCV</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.19 gym_gazabe安装配置]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-19-gym-gazabe%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录gym_gazebo安装的过程，想想每次安装都要一堆的百度，过程很痛苦，所以直接记录下我成功安装的过程，方便后面安装的参考。 具体内容如下： 摘要 解决ubuntu 中安装 gym_gazabe 遇到的各种水土不服 Basic requirements: ROS Kinetic dependencies Install Sophus Gazebo gym Dependencies and libraries Agent dependencies Run the environment with a sample agent 解决ubuntu 中安装 gym_gazabe 遇到的各种水土不服Basic requirements: ROS Kinetic (/rosversion: 1.12.7) Gazebo 8.1.1 Python 3.5.2 OpenCV3, installed from sources for Python 3 (git clone https://github.com/Itseez/opencv.git) OpenAI gym 这部分的安装请自行百度, 但是这部分的内容也要安装上，不然安装gym_gazebo会出错的。 ROS Kinetic dependencies12345678910111213141516171819202122232425262728sudo pip3 install rospkg catkin_pkgsudo apt-get install python3-pyqt4sudo apt-get install \cmake gcc g++ qt4-qmake libqt4-dev \libusb-dev libftdi-dev \python3-defusedxml python3-vcstool \libbluetooth-dev libspnav-dev \pyqt4-dev-tools libcwiid-dev \ros-kinetic-octomap-msgs \ros-kinetic-joy \ros-kinetic-geodesy \ros-kinetic-octomap-ros \ros-kinetic-control-toolbox \ros-kinetic-pluginlib \ros-kinetic-trajectory-msgs \ros-kinetic-control-msgs \ros-kinetic-std-srvs \ros-kinetic-nodelet \ros-kinetic-urdf \ros-kinetic-rviz \ros-kinetic-kdl-conversions \ros-kinetic-eigen-conversions \ros-kinetic-tf2-sensor-msgs \ros-kinetic-pcl-ros \ros-kinetic-navigation \ros-kinetic-ar-track-alvar-msgs Install Sophus123456789cdgit clone https://github.com/stonier/sophus -b release/0.9.1-kineticcd sophusmkdir buildcd buildcmake ..makesudo make installecho "## Sophus installed ##\n" Gazebo gym1234cd git clone https://github.com/erlerobot/gym-gazebocd gym-gazebosudo pip3 install -e . Dependencies and libraries1234567891011sudo pip3 install h5pysudo apt-get install python3-skimage# install Theanocd ~/git clone git://github.com/Theano/Theano.gitcd Theano/sudo python3 setup.py develop#install Kerassudo pip3 install keras Agent dependencies 这部分的安装可以参考我的github 仓库(gazebo.repos 已经修改过,并且在ubuntu16上正确编译安装通过，可以直接clone下来安装,我只修改了gazebo.repos,设置/usr/local/python3.5环境): 这部分的安装需要注意请尽量用”/usr/local/bin/python3.5”如果用anaconda的python环境下安装，会出现Cmake 报错,如果你有解决的办法可以忽略提示 切换python 环境，只需要执行如下命令： 1234vim ~/.bashrc# 修改弹出的文本，将export anaconda这行注释掉，如下所示# added by Anaconda3 4.2.0 installer#export PATH="/home/porter/anaconda3/bin:$PATH" 效果如下： 安装前需要配置下Agent 的gazebo.repos123cd ~/gym-gazebo/gym_gazebo/envs/installation/cp ./gazebo.repos ./gazebo.repos.bakgedit ~/gym-gazebo/gym_gazebo/envs/installation/gazebo.repos gazebo.repos 内容如下 主要修改一些github 仓库对应版本release的分支问题, 解决安装时的错误， 修改后的内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168repositories:# ardupilot_sitl_gazebo_plugin:# type: git# url: https://github.com/erlerobot/ardupilot_sitl_gazebo_plugin## version: master ar_track_alvar: type: git url: https://github.com/ros-perception/ar_track_alvar.git version: kinetic-devel mav_comm: type: git url: https://github.com/ethz-asl/mav_comm.git version: master# ar_track_alvar:# type: git# url: https://github.com/sniekum/ar_track_alvar# version: indigo-devel# ar_track_alvar_msgs:# type: git# url: https://github.com/sniekum/ar_track_alvar_msgs# version: indigo-devel catkin_simple: type: git url: https://github.com/catkin/catkin_simple.git version: master control_toolbox: type: git url: https://github.com/ros-controls/control_toolbox.git version: indigo-devel# drcsim:# type: hg# url: https://bitbucket.org/osrf/drcsim# version: default ecl_core: type: git url: https://github.com/stonier/ecl_core version: release/0.61-indigo-kinetic ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kinetic ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: devel ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic driver_base: type: git url: https://github.com/ros-drivers/driver_common.git version: indigo-devel gazebo_ros_pkgs: type: git url: https://github.com/ros-simulation/gazebo_ros_pkgs version: indigo-devel# glog_catkin:# type: git# url: https://github.com/ethz-asl/glog_catkin.git# version: master hector_gazebo: type: git url: https://github.com/tu-darmstadt-ros-pkg/hector_gazebo/ version: indigo-devel image_common: type: git url: https://github.com/ros-perception/image_common.git version: hydro-devel joystick_drivers: type: git url: https://github.com/ros-drivers/joystick_drivers.git version: master kobuki: type: git url: https://github.com/yujinrobot/kobuki version: indigo kobuki_core: type: git url: https://github.com/yujinrobot/kobuki_core version: indigo kobuki_desktop: type: git url: https://github.com/erlerobot/kobuki_desktop version: indigo kobuki_msgs: type: git url: https://github.com/yujinrobot/kobuki_msgs version: indigo# mavros:# type: git# url: https://github.com/erlerobot/mavros.git# version: gazebo_udp# mav_comm:# type: git# url: https://github.com/PX4/mav_comm.git# version: master navigation: type: git url: https://github.com/ros-planning/navigation version: indigo-devel# osrf-common:# type: hg# url: https://bitbucket.org/osrf/osrf-common# version: default pcl_ros: type: git url: https://github.com/ros-perception/perception_pcl.git version: indigo-devel# python_qt_binding:# type: git# url: https://github.com/ros-visualization/python_qt_binding# version: kinetic-devel# qt_gui_core:# type: git# url: https://github.com/ros-visualization/qt_gui_core# version: groovy-devel realtime_tools: type: git url: https://github.com/ros-controls/realtime_tools version: indigo-devel ros_control: type: git url: https://github.com/ros-controls/ros_control version: indigo-devel roslint: type: git url: https://github.com/ros/roslint version: master# rqt:# type: git# url: https://github.com/ros-visualization/rqt# version: groovy-devel# rqt_common_plugins:# type: git# url: https://github.com/ros-visualization/rqt_common_plugins# version: master# rqt_robot_plugins:# type: git# url: https://github.com/ros-visualization/rqt_robot_plugins# version: master turtlebot: type: git url: https://github.com/turtlebot/turtlebot version: indigo turtlebot_create: type: git url: https://github.com/turtlebot/turtlebot_create version: indigo turtlebot_simulator: type: git url: https://github.com/turtlebot/turtlebot_simulator version: indigo xacro: type: git url: https://github.com/ros/xacro version: indigo-devel yocs_msgs: type: git url: https://github.com/yujinrobot/yocs_msgs version: release/0.6-kinetic yujin_ocs: type: git url: https://github.com/yujinrobot/yujin_ocs version: kinetic 具体的修改地方建议，通过code compare 工具查看，这里推荐一个好用而代码比较工具：Meld Diff 比较好用。 接下来执行如下Agent dependences 12cd gym_gazebo/envs/installationbash setup_kinetic.bash Run the environment with a sample agent12cd gym_gazebo/examples/scripts_turtlebotpython circuit2_turtlebot_lidar_qlearn.py]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>gym_gazabe</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gym-gazebo安装后的测试]]></title>
    <url>%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-ROS%E6%9C%BA%E5%99%A8%E4%BA%BA-gym-gazebo%E5%AE%89%E8%A3%85%E5%90%8E%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[目录本节会安装以下内容 目录 第一步：bash turtlebot_setup.bash Running an environment Run any of the examples available in examples/. E.g.: 第二步：source setup_turtlebot.bash source 进行expert操作 第三步：eg export ROS_MASTER_URI=http://localhost:12795 第二步和第三步操作方法的截图 第四步：gzclient 五 最终效果 Display reward plot Killing background processes Edit By Porter, 积水成渊,蛟龙生焉。 第一步：bash turtlebot_setup.bashRunning an environmentLoad the environment variables corresponding to the robot you want to launch. E.g. to load the Turtlebot:12cd gym_gazebo/envs/installationbash turtlebot_setup.bash Note: all the setup scripts are available in gym_gazebo/envs/installation Run any of the examples available in examples/. E.g.:12cd examples/turtlebotpython3 circuit2_turtlebot_lidar_qlearn.py 第二步：source setup_turtlebot.bash 我的source bash文件是setup.bash不是setup_turtlebot.bash，所以我的是source setup.bash source12cd /home/porter/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/develsource setup.bash 进行expert操作首先第一步：bash turtlebot_setup.bash过后，终端会有如下的提示 得到有用的终端输出信息12345678910111213porter@porter-Aspire:~/gym-gazebo/examples/turtlebot$ python3 circuit2_turtlebot_lidar_qlearn.pyROS_MASTER_URI=http://localhost:12795GAZEBO_MASTER_URI=http://localhost:12796Gazebo launched!Unable to register with master node [http://localhost:12795]: master may not be running yet. Will keep trying.... logging to /home/porter/.ros/log/ab3f7618-6fea-11e9-a24a-f0761cd1b3e0/roslaunch-porter-Aspire-11818.logChecking log directory for disk usage. This may take awhile.Press Ctrl-C to interruptDone checking log file disk usage. Usage is &lt;1GB.started roslaunch server http://porter-Aspire:33631/ 第三步：eg export ROS_MASTER_URI=http://localhost:1279512export ROS_MASTER_URI=http://localhost:12795 # 和上面的端口号一致export GAZEBO_MASTER_URI=http://localhost:12796 # 和上面的端口号一致 第二步和第三步操作方法的截图 第四步：gzclient执行如下命令打开gazebo1gzclient 五 最终效果 Display reward plotDisplay a graph showing the current reward history by running the following script: 123cd /home/porter/gym-gazebo/cd examples/utilitiespython3 display_plot.py HINT: use –help flag for more options. Killing background processesSometimes, after ending or killing the simulation gzserver and rosmaster stay on the background, make sure you end them before starting new tests. We recommend creating an alias to kill those processes. 1echo "alias killgazebogym='killall -9 rosout roslaunch rosmaster gzserver nodelet robot_state_publisher gzclient'" &gt;&gt; ~/.bashrc 参考来源：https://github.com/erlerobot/gym-gazebo/tree/master#installation]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>gym-gazebo</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu16 安装gym-gazebo]]></title>
    <url>%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-ROS%E6%9C%BA%E5%99%A8%E4%BA%BA-ubuntu16-%E5%AE%89%E8%A3%85gym-gazebo%2F</url>
    <content type="text"><![CDATA[目录本节会安装以下内容 Kinetic ubuntu16 gazebo8 gym python3.5 opencv3 安装 gazebo_ros_pkgs gym-gazebo gym-gazebo 测试 本节笔记主要记录ubuntu16 下安装gym-gazebo，包括其依赖的软件包安装。 我的代码仓库: https://github.com/porterpan/gym-gazebo 建议直接clone 我的软件仓库安装(直接适应kinetic版本安装不会出现警告和编译出错终止，当然可能会应为你的ros功能包缺失出错,这时只需要手动安装缺失的ros功能包，删除catkin_ws，再重复上次的安装过程即可) 12cd ~git clone -b master https://github.com/porterpan/gym-gazebo 实在官方的仓库中修改了: ~/gym-gazebo/gym_gazebo/envs/installation/gazebo.repos 文件内容.使整个安装适应ROS kinetic 环境。当然过程中如果缺ros功能包，需要自己额外安装功能包的。 缺失ros功能包会在编译时出现make error 红色的， 解决办法见ROS 中功能包的安装与查询 部分的方法安装好，然后remove -rf 安装路径中的catkin_ws 文件夹，然后重新上一步操作安装即可。 目录 第一部分安装gym-gazebo 下载安装文件 安装依赖环境 Basic requirements: Install Sophus 安装gym-gazebo Dependencies and libraries install Theano install Keras Try it out (turtlebot simple env) Agent dependencies: Run the environment with a sample agent: 第二部分：附录 ROS 中功能包的安装与查询 1.查询当前安装完成的所有包文件 2.查询ros的所有功能包 安装错误解决 错误1： 问题2 问题3： gazebo.repos 内容修改 安装结束效果 gym-gazebo 测试 Edit By Porter, 积水成渊,蛟龙生焉。 第一部分安装gym-gazebo下载安装文件12cd ~ #进入home目录git clone -b master https://github.com/porterpan/gym-gazebo 安装依赖环境Basic requirements: ROS Kinetic (/rosversion: 1.12.7) (安装选择这个sudo apt-get install ros-kinetic-desktop, 不要全装不然后面装gazebo8会相对麻烦点) 进入ROS官网的安装界面：http://wiki.ros.org/ROS/Installation 选择需要的版本 Kinetic 和系统平台，我们用的是 ubuntu 16.04按照指导进行安装，这里注意要选择安装 ros-kinetic-desktop 版本，不要选 ros-kinetic-desktop-full，前者不包含 Gazebo ，后者包含了 Gazebo 7。后边安装 Gazebo 8 的时候还需要卸载掉，比较麻烦。按照完 ROS 测试一下，在命令行中输入如下命令，看能否正常启动 ros master ： 作者：isl_qdu链接：https://www.jianshu.com/p/2b4c68b9caaf来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 Gazebo 8.1.1 , 进入选择手动安装，不要选择Default installation: one-liner安装方式，否则会给你安装默认最新版本的gazebo. Python 3.5.2 (# I have yet to find out why though, because all the standard ROS stuff is in Python 2) OpenCV3, installed from sources for Python 3， pip3 或者手动安装(git clone https://github.com/Itseez/opencv.git) 安装 gazebo_ros_pkgs 前边安装的 ROS 与 Gazebo 是完全独立的两部分，要使他们之间互相通讯，还需要安装 gazebo_ros_pkgs 包。 进入官网安装界面：http://gazebosim.org/tutorials?tut=ros_installing 按照指导安装即可。我一般选择用 A: Install Pre-Built Debians 方式安装。需要注意的是，如果用如下命令安装报错：1sudo apt-get install ros-kinetic-gazebo-ros-pkgs ros-kinetic-gazebo-ros-control 则需要指明 Gazebo 版本，将命令改为：1sudo apt-get install ros-kinetic-gazebo8-ros-pkgs ros-kinetic-gazebo8-ros-control 就可以解决问题。 测试。安装结束，用如下命令测试：12roscore # 启动 ros masterrosrun gazebo_ros gazebo # 用 rosrun 方式启动 Gazebo 作者：isl_qdu链接：https://www.jianshu.com/p/2b4c68b9caaf来源：简书简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。 OpenAI gym安装 Install Sophus123456789cd ~git clone https://github.com/stonier/sophus -b release/0.9.1-kineticcd sophusmkdir buildcd buildcmake ..makesudo make installecho "## Sophus installed ##\n" 安装gym-gazebo12345cd ~Gazebo gymgit clone -b master https://github.com/erlerobot/gym-gazebocd gym-gazebosudo pip2 install -e . Dependencies and libraries12sudo pip3 install h5pysudo apt-get install python3-skimage install Theano1234cd ~/git clone git://github.com/Theano/Theano.gitcd Theano/sudo python3 setup.py develop install Keras1sudo pip3 install keras Try it out (turtlebot simple env) Issues: spacenav_node not compiling. CATKIN_IGNOREd.wiimote not compiling. CATKIN_IGNOREd.kobuki_qtestsuite not compiling. CATKIN_IGNOREd. Agent dependencies:1234567# make sure to switch to bash, because the installation script # hasn't been converted to ZSH yet# and if you run it from ZSH the environmental variables # that are set during the script's execution aren't preservedcd gym_gazebo/envs/installation./setup_kinetic.bash ./turtlebot_setup.bash Run the environment with a sample agent:123# only execute this while still in the same bash as last stepcd ../../../examples/scripts_turtlebot/python circuit2_turtlebot_lidar_qlearn.py The result should look like this (after a few seconds): 123456789101112... (messages about ROS and Gazebo starting up, until finally:) ...[ INFO] [1508869124.880487247, 81.480000000]: GazeboRosKobuki plugin ready to go! [mobile_base]EP: 1 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.9] - Reward: -87 Time: 0:00:05EP: 2 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.9] - Reward: -155 Time: 0:00:05EP: 3 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.9] - Reward: -165 Time: 0:00:05EP: 4 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -156 Time: 0:00:06EP: 5 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -162 Time: 0:00:06EP: 6 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -161 Time: 0:00:07EP: 7 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -167 Time: 0:00:07EP: 8 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -166 Time: 0:00:08EP: 9 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -154 Time: 0:00:08EP: 10 - [alpha: 0.2 - gamma: 0.8 - epsilon: 0.89] - Reward: -157 Time: 0:00:09 第二部分：附录ROS 中功能包的安装与查询1.查询当前安装完成的所有包文件1rospack list 可以看到所有的ROS功能包都在/opt/ros/kinetic/share目录下，所以也可以使用如下命令查询1234cd /opt/ros/kinetic/share/orroscd turtlesim/cd .. 2.查询ros的所有功能包1apt-cache search ros-kinetic 或者说在不知道要安装功能包的确切名字的情况下找到目标包1apt-cache search ros-kinetic | grep rqt- 通过管道线 与grep命令， 输出与关键字rqt-相关的行 再或者下述安装命令与Tab键结合1sudo apt-get install ros-kinetic-rqt- 系统输出相应提示。前述所有内容中，rospack list 与sudo apt-get install ros-kinetic-rqt- +Tab键使用最方便。 安装错误解决错误1： 错误1：错误提示： 在moveit编译时找不到manipulation_msgsConfig.cmake manipulation_msgs-config.cmake文件 123456789101112Could not find the required component 'manipulation_msgs'. The following CMake error indicates that you either need to install the package with the same name or change your environment so that it can be found.CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package): Could not find a package configuration file provided by "manipulation_msgs" with any of the following names: manipulation_msgsConfig.cmake manipulation_msgs-config.cmake--------------------- 作者：pd很不专业 来源：CSDN 原文：https://blog.csdn.net/qq_42145185/article/details/80975975 版权声明：本文为博主原创文章，转载请附上博文链接！ 错误1：解决： 搜索这个功能包 能找到这个ros-kinetic-manipulation-msgs 包1sudo apt-get install ros-kinetic-manipulation-msgs 对ros安装对应的manipulation_msgsConfig包, 完成安装后重新去编译一下你的moveit包就行了。 问题2 错误二：错误提示： 123456" CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkinConfig.cmake:83 (find_package): Could not find a package configuration file provided by "tf2_geometry_msgs" with any of the following names:tf2_geometry_msgsConfig.cmaketf2_geometry_msgs-config.cmakeAdd the installation prefix of "tf2_geometry_msgs" to CMAKE_PREFIX_PATH or set "tf2_geometry_msgs_DIR" to a directory containing one of the above files. If "tf2_geometry_msgs" provides a separate development package or SDK, be sure it has been installed." 错误二：解决： 先搜索这个需要安装的ros功能包 1apt-cache search ros-kinetic | grep tf2_geometry_msgs 发现存在这个包12porter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation$ apt-cache search ros-kinetic | grep tf2_geometry_msgsros-kinetic-tf2-geometry-msgs - tf2_geometry_msgs 执行这个功能包的安装12345678910111213141516porter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation$ sudo apt-get install ros-kinetic-tf2-geometry-msgs[sudo] porter 的密码： 正在读取软件包列表... 完成正在分析软件包的依赖关系树 正在读取状态信息... 完成 下列【新】软件包将被安装： ros-kinetic-tf2-geometry-msgs升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 0 B/13.2 kB 的归档。解压缩后会消耗 86.0 kB 的额外空间。正在选中未选择的软件包 ros-kinetic-tf2-geometry-msgs。(正在读取数据库 ... 系统当前共安装有 415109 个文件和目录。)正准备解包 .../ros-kinetic-tf2-geometry-msgs_0.5.20-0xenial-20190320-171251-0800_amd64.deb ...正在解包 ros-kinetic-tf2-geometry-msgs (0.5.20-0xenial-20190320-171251-0800) ...正在设置 ros-kinetic-tf2-geometry-msgs (0.5.20-0xenial-20190320-171251-0800) ...porter@porter-Aspire:~/gym-gazebo/gym_gazebo/envs/installation$ 问题3： 问题3：错误提示 CMake Error at /opt/ros/kinetic/share/catkin/cmake/catkin_workspace.cmake:95 (message): 12345WARNING: Metapackage "ecl_tools" must buildtool_depend on catkin.WARNING: Metapackage "ecl_tools" should not have other dependencies besides a buildtool_depend on catkin and run_depends.WARNING: Metapackage "ecl_lite" must buildtool_depend on catkin.WARNING: Metapackage "ecl_lite" should not have other dependencies besides a buildtool_depend on catkin and run_depends.Packages "mav_msgs" not found in the workspace 问题3：解决 出现这个错误的原因是ecl升级，或这和你当前安装的ros版本不对应。造成了cmake版本比配。出错，方法是 打开gazebo.repos,修改如下部分：123456789101112ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kinetic ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: devel ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic (将ecl_core、 ecl_lite 和ecl_tools 的版本号（version）改成： release/0.61-indigo-kinetic） 不过最终解决还是建议你如果也是安装ros kenitic 直接复制我后面附录的gazebo.repos内容替换掉之前的 路径： vim ~/gym-gazebo/gym_gazebo/envs/installation/gazebo.repos gazebo.repos 内容修改gazebo.repos 修改后的文件内容，使适应kinetic环境，进行安装。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113repositories: ar_track_alvar: type: git url: https://github.com/ros-perception/ar_track_alvar version: kinetic-devel mav_comm: type: git url: https://github.com/ethz-asl/mav_comm.git version: master catkin_simple: type: git url: https://github.com/catkin/catkin_simple.git version: master control_toolbox: type: git url: https://github.com/ros-controls/control_toolbox.git version: kinetic-devel ecl_core: type: git url: https://github.com/stonier/ecl_core version: release/0.61-indigo-kinetic ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kinetic ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: release/0.60-indigo-kinetic ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic driver_base: type: git url: https://github.com/ros-drivers/driver_common.git version: indigo-devel gazebo_ros_pkgs: type: git url: https://github.com/ros-simulation/gazebo_ros_pkgs version: kinetic-devel hector_gazebo: type: git url: https://github.com/tu-darmstadt-ros-pkg/hector_gazebo/ version: kinetic-devel image_common: type: git url: https://github.com/ros-perception/image_common.git version: hydro-devel joystick_drivers: type: git url: https://github.com/ros-drivers/joystick_drivers.git version: master kobuki: type: git url: https://github.com/yujinrobot/kobuki version: kinetic kobuki_core: type: git url: https://github.com/yujinrobot/kobuki_core version: kinetic kobuki_desktop: type: git url: https://github.com/yujinrobot/kobuki_desktop version: kinetic kobuki_msgs: type: git url: https://github.com/yujinrobot/kobuki_msgs version: kinetic navigation: type: git url: https://github.com/ros-planning/navigation version: kinetic-devel pcl_ros: type: git url: https://github.com/ros-perception/perception_pcl.git version: kinetic-devel realtime_tools: type: git url: https://github.com/ros-controls/realtime_tools version: kinetic-devel ros_control: type: git url: https://github.com/ros-controls/ros_control version: kinetic-devel roslint: type: git url: https://github.com/ros/roslint version: master turtlebot: type: git url: https://github.com/turtlebot/turtlebot version: kinetic turtlebot_create: type: git url: https://github.com/turtlebot/turtlebot_create version: master turtlebot_simulator: type: git url: https://github.com/turtlebot/turtlebot_simulator version: indigo xacro: type: git url: https://github.com/ros/xacro version: kinetic-devel yocs_msgs: type: git url: https://github.com/yujinrobot/yocs_msgs version: release/0.6-kinetic yujin_ocs: type: git url: https://github.com/yujinrobot/yujin_ocs version: kinetic 安装结束效果123456789vim ~/.bashrc# 最后几行的环境应该是这样的source /home/porter/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/devel/setup.bashexport GAZEBO_MODEL_PATH=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/modelsexport GYM_GAZEBO_WORLD_MAZE=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/maze.worldexport GYM_GAZEBO_WORLD_CIRCUIT=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/circuit.worldexport GYM_GAZEBO_WORLD_CIRCUIT2=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/circuit2.worldexport GYM_GAZEBO_WORLD_CIRCUIT2C=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/circuit2c.worldexport GYM_GAZEBO_WORLD_ROUND=/home/porter/gym-gazebo/gym_gazebo/envs/installation/../assets/worlds/round.world 打开终端执行的效果如下图 gym-gazebo 测试参见我的另一篇文章gym-gazebo安装后的测试]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>gym-gazebo</tag>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ros and gazebo and gym_gazebo安装]]></title>
    <url>%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-ROS%E6%9C%BA%E5%99%A8%E4%BA%BA-ros-and-gazebo-and-gym-gazebo%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[摘要本节笔记主要记录ROS室内仿真环景的具体演示过程和 Edit By Porter, 积水成渊,蛟龙生焉。 ros 安装gazebo安装gym_gazebo安装安装配置中的问题python 环境下提示无法导入rospy报错解决12sudo pip install catkin-toolssudo pip install rospkg 12sudo pip3 install catkin-toolssudo pip3 install rospkg 效果123456789101112131415161718192021222324252627282930313233343536porter@porter-Aspire:~$ sudo pip3 install catkin-tools[sudo] porter 的密码： The directory '/home/porter/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/porter/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Requirement already satisfied: catkin-tools in /usr/local/lib/python3.5/site-packagesRequirement already satisfied: osrf-pycommon&gt;0.1.1 in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: PyYAML in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: setuptools in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: catkin-pkg&gt;0.2.9 in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: trollius in /usr/local/lib/python3.5/site-packages (from catkin-tools)Requirement already satisfied: docutils in /usr/local/lib/python3.5/site-packages (from catkin-pkg&gt;0.2.9-&gt;catkin-tools)Requirement already satisfied: pyparsing in /usr/local/lib/python3.5/site-packages (from catkin-pkg&gt;0.2.9-&gt;catkin-tools)Requirement already satisfied: python-dateutil in /usr/local/lib/python3.5/site-packages (from catkin-pkg&gt;0.2.9-&gt;catkin-tools)Requirement already satisfied: six in /usr/local/lib/python3.5/site-packages (from trollius-&gt;catkin-tools)You are using pip version 9.0.1, however version 19.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.porter@porter-Aspire:~$ sudo pip3 install rospkgThe directory '/home/porter/.cache/pip/http' or its parent directory is not owned by the current user and the cache has been disabled. Please check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.The directory '/home/porter/.cache/pip' or its parent directory is not owned by the current user and caching wheels has been disabled. check the permissions and owner of that directory. If executing pip with sudo, you may want sudo's -H flag.Requirement already satisfied: rospkg in /usr/local/lib/python3.5/site-packagesRequirement already satisfied: PyYAML in /usr/local/lib/python3.5/site-packages (from rospkg)Requirement already satisfied: catkin-pkg in /usr/local/lib/python3.5/site-packages (from rospkg)Requirement already satisfied: python-dateutil in /usr/local/lib/python3.5/site-packages (from catkin-pkg-&gt;rospkg)Requirement already satisfied: pyparsing in /usr/local/lib/python3.5/site-packages (from catkin-pkg-&gt;rospkg)Requirement already satisfied: docutils in /usr/local/lib/python3.5/site-packages (from catkin-pkg-&gt;rospkg)Requirement already satisfied: six&gt;=1.5 in /usr/local/lib/python3.5/site-packages (from python-dateutil-&gt;catkin-pkg-&gt;rospkg)You are using pip version 9.0.1, however version 19.1 is available.You should consider upgrading via the 'pip install --upgrade pip' command.porter@porter-Aspire:~$ python3Python 3.5.6 (default, Mar 29 2019, 21:29:42) [GCC 5.4.0 20160609] on linuxType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; import rospy&gt;&gt;&gt;]]></content>
      <categories>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gym 运行常见错误及解决办法]]></title>
    <url>%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-ROS%E6%9C%BA%E5%99%A8%E4%BA%BA-gym-%E8%BF%90%E8%A1%8C%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要 Edit By Porter, 积水成渊,蛟龙生焉。 1. env.close()问题1.1 问题1描述(TypeError: ‘NoneType’ object is not iterable) 当我们在pycharm或者其他IDE运行一段gym例子,程序结束时都会弹出这个错误提示 12345678910111213141516OKException ignored in: &lt;bound method Viewer.__del__ of &lt;gym.envs.classic_control.rendering.Viewer object at 0x7f8758e0a4a8&gt;&gt;Traceback (most recent call last): File "/home/porter/gym/gym/envs/classic_control/rendering.py", line 152, in __del__ File "/home/porter/gym/gym/envs/classic_control/rendering.py", line 71, in close File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/window/xlib/__init__.py", line 480, in close File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/xlib.py", line 345, in destroy File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/base.py", line 334, in destroy File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/xlib.py", line 335, in detach File "/home/porter/anaconda3/lib/python3.5/site-packages/pyglet/gl/lib.py", line 97, in errcheck File "&lt;frozen importlib._bootstrap&gt;", line 968, in _find_and_load File "&lt;frozen importlib._bootstrap&gt;", line 953, in _find_and_load_unlocked File "&lt;frozen importlib._bootstrap&gt;", line 887, in _find_specTypeError: 'NoneType' object is not iterableProcess finished with exit code 0 1.2 解决 原因是，我们没在迭代结束后加上这句话 在代码迭代结束后加上这句代码 1env.close() 1.3 测试代码如下：1234567891011121314151617181920import gymfrom time import sleepenv = gym.make('CartPole-v0')i = 0for i_episode in range(20): observation = env.reset() for step in range(100): env.render() print(observation) action = env.action_space.sample() observation, reward, done, info = env.step(action) if done: print("Episode finished after &#123;&#125; timesteps".format(step+1)) break i += 1 print("i=", i, )print("OK")sleep(3)env.close() 2. 在运行 ‘python circuit2_turtlebot_lidar_qlearn.py ’ 报错2.1 错误提示1234while processing /home/harish/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/src/turtlebot_simulator/turtlebot_gazebo/launch/includes/kobuki.launch.xml:Invalid tag: Cannot load command parameter [robot_description]: command [/opt/ros/kinetic/lib/xacro/xacro --inorder '/home/harish/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/src/turtlebot/turtlebot_description/robots/kobuki_hexagons_asus_xtion_pro.urdf.xacro'] returned with code [2].Param xml is The traceback for the exception was written to the log file PyCharm 中的错误提示 12345678910111213141516171819202122GAZEBO_MASTER_URI=http://localhost:10039Traceback (most recent call last): File "/home/porter/gym-gazebo/examples/turtlebot/circuit_turtlebot_lidar_qlearn.py", line 24, in &lt;module&gt; env = gym.make('GazeboCircuitTurtlebotLidar-v0') File "/home/porter/gym/gym/envs/registration.py", line 155, in make return registry.make(id, **kwargs) File "/home/porter/gym/gym/envs/registration.py", line 100, in make env = spec.make(**kwargs) File "/home/porter/gym/gym/envs/registration.py", line 72, in make env = cls(**_kwargs) File "/home/porter/gym-gazebo/gym_gazebo/envs/turtlebot/gazebo_circuit_turtlebot_lidar.py", line 20, in __init__ gazebo_env.GazeboEnv.__init__(self, "GazeboCircuitTurtlebotLidar_v0.launch") File "/home/porter/gym-gazebo/gym_gazebo/envs/gazebo_env.py", line 36, in __init__ ros_path = os.path.dirname(subprocess.check_output(["which", "roscore"])) File "/home/porter/anaconda3/lib/python3.5/subprocess.py", line 316, in check_output **kwargs).stdout File "/home/porter/anaconda3/lib/python3.5/subprocess.py", line 398, in run output=stdout, stderr=stderr)subprocess.CalledProcessError: Command '['which', 'roscore']' returned non-zero exit status 1Process finished with exit code 1 2.2 解决方法使用gedit打开kobuki.launch.xml文件 1gedit /home/zhw/gym-gazebo/gym_gazebo/envs/installation/catkin_ws/src/turtlebot_simulator/turtlebot_gazebo/launch/includes/kobuki.launch.xml 然后，将第六行替换成：1&lt;arg name="urdf_file" default="$(find xacro)/xacro.py '$(find turtlebot_description)/robots/$(arg base)_$(arg stacks)_$(arg 3d_sensor).urdf.xacro'"/&gt; 3.错误提示1234Multiple packages found with the same name "ecl_mobile_robot":- ecl_core/ecl_mobile_robot- ecl_navigation/ecl_mobile_robotsetup_kinetic.bash: 行 80: devel/setup.bash: 没有那个文件或目录 解决方法 打开gazebo.repos,修改如下部分：改写,原来的内容为：12345678910111213141516ecl_core: type: git url: https://github.com/stonier/ecl_core version: devel ecl_lite: type: git url: https://github.com/stonier/ecl_lite version: devel ecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: devel ecl_tools: type: git url: https://github.com/stonier/ecl_tools version: devel 改写为(将ecl_core、 ecl_lite 和ecl_tools 的版本号（version）改成： release/0.61-indigo-kinetic） 12345678910111213141516ecl_core: type: git url: https://github.com/stonier/ecl_core version: release/0.61-indigo-kineticecl_lite: type: git url: https://github.com/stonier/ecl_lite version: release/0.61-indigo-kineticecl_navigation: type: git url: https://github.com/stonier/ecl_navigation version: release/0.61-indigo-kineticecl_tools: type: git url: https://github.com/stonier/ecl_tools version: release/0.61-indigo-kinetic]]></content>
      <categories>
        <category>gym</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图书馆占座小工具使用手册]]></title>
    <url>%2F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E5%B0%8F%E9%A1%B9%E7%9B%AE%E5%AE%9E%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3-Library-%E5%8D%A0%E5%BA%A7%E5%B0%8F%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[摘要 摘要 使用说明 房间情况查询操作帮助说明 查询功能描述 查询-软件操作步骤 注意 选座操作帮助说明 手动选座功能描述 选座-软件操作步骤 注意 自动选座操作帮助说明 自动选座功能描述 自动选座-软件操作步骤 注意 关于软件打包成exe方案 安装pyinstaller 打包成exe文件 Edit By Porter, 积水成渊,蛟龙生焉。 帮网友做的图书馆抢座和查学生信息的GUI操作界面 使用说明 注意自动抢座模式，电脑不能掉网哦，程序内部已经添加了学校网络账号自动登录功能，但是用的作者个人账号，所以为了不影响作者上网，除了调试阶段的程序，其他发布的程序，自动链接网络的功能都是注释掉的，望海涵，如果后期有需要，笔者可以在软件界面加个输入上网账号的输入口，实现用用户自己的上网号自动上网。 房间情况查询操作帮助说明查询功能描述 可以查询当前选择的房间号和当前填写的时间段的座位被占用情况 可以查询当前座位的同学姓名 查询-软件操作步骤 输入 【开始时间】-【结束时间】-【日期设置】 选择 【房间号】 填写 【座位号】 点击 【房间查询】按键 通过以上4步骤，即可返回你要查询年月日下的对应时间段房间预约情况。 注意 输入格式严格按照运行软件的实例格式输入，具体怎么输入，可咨询作者，但是非作者本人分享，你是找不到作者的，如果命令输入错误，拼写问题，会有相应提示错误原因。如果字符格式错误，软件将会气死的。为啥不人性化直接输入时间数值，原因很简单，害怕软件传播，影响其他爱学习的孩子，建议1楼的都不要抢啊，人家考研的辛苦的。 如果输入信息出错将会有相应错误信息提示，按照错误信息操作即可解决 选座操作帮助说明手动选座功能描述 可以选择当前选择的房间号和当前填写的时间段的座位，对对应房间号中的某座位进行预约 支持当天的位置预约和未来24小时的位置进行预约 更多功能自行探索 选座-软件操作步骤 输入 【输入学号】-【输入密码】-【验证码】 点击 【登录】按键 【开始时间】-【结束时间】-【日期设置】 选择 【房间号】 填写 【座位号】 然后点击【选座】 通过以上6步骤，即可成功预约在你指定的时间断中，你选择的房间号下对应的座位号，即成功按照你的需要预约成功。 注意 输入格式严格按照运行软件的实例格式输入，具体怎么输入，可咨询作者，但是非作者本人分享，你是找不到作者的，如果命令输入错误，拼写问题，会有相应提示错误原因。如果字符格式错误，软件将会气死的。为啥不人性化直接输入时间数值，原因很简单，害怕软件传播，影响其他爱学习的孩子，建议1楼的都不要抢啊，人家考研的辛苦的。 如果输入信息出错将会有相应错误信息提示，按照错误信息操作即可解决，成功预约会返回成功的相应信息。如“您已成功预约”等字样 自动选座操作帮助说明自动选座功能描述 可以在当天上午5:30时刻自动对明天8：30-22:00时间段的，当前选定的房间号和座位号进行座位的抢占 注意勾选自动抢座后，程序会到每天的上午5:30时刻进行自动预约24小时后的位置（相对今天，明天的位置） 自动选座-软件操作步骤 输入 【输入学号】-【输入密码】-【验证码】 点击 【登录】按键 选择 【房间号】 填写 【座位号】 然后勾选右下角的【自动选座】 通过以上5步骤，软件讲处于自动选座模式，此时需要保持软件处于运行状态，软件将会在每天的5:30开始抢座。 抢座的时间段固定为当天后一天（今天5:30开抢明天8:30-22:00）的座位。 抢占的座位和房间号可以在5:30前的任何时间填写好，（今天5:30开抢，一般昨天晚上睡觉前，在选择房间号和座位号后就点击自动选位开抢了）然后不要玩了勾选自动选择座位。 注意 输入格式严格按照运行软件的实例格式输入，具体怎么输入，可咨询作者，但是非作者本人分享，你是找不到作者的，如果命令输入错误，拼写问题，会有相应提示错误原因。如果字符格式错误，软件将会气死的。为啥不人性化直接输入时间数值，原因很简单，害怕软件传播，影响其他爱学习的孩子，建议1楼的都不要抢啊，人家考研的辛苦的。 如果输入信息出错将会有相应错误信息提示，按照错误信息操作即可解决，成功预约会返回成功的相应信息。如“您已成功预约”等字样 关于软件打包成exe方案安装pyinstaller www.pyinstaller.org 安装指令 1pip install pyinstaller 打包成exe文件12345-F, –onefile 打包成一个exe文件。-D, –onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项）。-c, –console, –nowindowed 使用控制台，无界面(默认)-w, –windowed, –noconsole 使用窗口，无控制台更详细的使用方法可以参考下载包里的doc目录下的Manual.html文件。 生成的exe文件相对较小，而且可以不用安装运行环境 12cd 到name.py脚本的目录中pyinstaller -w -F name.py 这条指令后会生成一个exe，并且占用空间小，占内存和你代码写的有关系，一般占用内存也不大 界面升级]]></content>
      <categories>
        <category>Library Project</category>
      </categories>
      <tags>
        <tag>Library Project</tag>
        <tag>Pythton</tag>
        <tag>qt5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.17 ubuntu下安装有道词典]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-17-ubuntu%E4%B8%8B%E5%AE%89%E8%A3%85%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8%2F</url>
    <content type="text"><![CDATA[摘要解决ubuntu16安装有道词典安装后”水土不服“的一些问题 不能取词 不能发音问题 具体步骤内容如下： 摘要 解决ubuntu16安装有道词典安装后”水土不服“的一些问题 下载有道词典的官方最新安装包 cd 到下载保存的目录执行解包,修改，打包等 创建youdao-dict目录，把该deb包解压到youdao-dict目录 解压deb包中的control信息（包的依赖就写在这个文件里面） 编辑control文件，删除Depends里面的gstreamer0.10-plugins-ugly,添加gstreamer1.0-libav 编辑后的control文件的依赖包内目如下 重新打包，安装 Edit By Porter, 积水成渊,蛟龙生焉。 下载有道词典的官方最新安装包youdao-dict_1.1.0-0-ubuntu_amd64.deb cd 到下载保存的目录执行解包,修改，打包等创建youdao-dict目录，把该deb包解压到youdao-dict目录1sudo dpkg -X ./youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict 解压deb包中的control信息（包的依赖就写在这个文件里面）1sudo dpkg -e ./youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict/DEBIAN 编辑control文件，删除Depends里面的gstreamer0.10-plugins-ugly,添加gstreamer1.0-libav1sudo vi ./youdao-dict/DEBIAN/control 注意可以直接先安装好有道词典单词发音的语音包修复如下 123456# 安装单词发音语音包# 搜索 gstreamer1 相关的包sudo apt-cache search gstreamer1 # 安装找到的 gstreamer1.0-libav 包sudo apt-get install gstreamer1.0-libav 编辑后的control文件的依赖包内目如下1Depends: python3, python3-pyqt5, python3-requests, python3-xlib, tesseract-ocr, tesseract-ocr-eng, tesseract-ocr-chi-sim, tesseract-ocr-chi-tra, python3-pil, ttf-wqy-microhei, python3-lxml, python3-xdg, python3-pyqt5.qtmultimedia, python3-pyqt5.qtquick, python3-pyqt5.qtwebkit, gir1.2-appindicator3-0.1, python3-dbus, qtdeclarative5-controls-plugin, libqt5multimedia5-plugins, gstreamer1.0-libav 重新打包，安装sudo dpkg-deb -b youdao-dict youdaobuild.deb 12345sudo dpkg -i youdaobuild.deb出现缺少的依赖使用如下命令安装所需依赖sudo apt install -f依赖安装完成后再次键入如下命令进行安装sudo dpkg -i youdaobuild.deb]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>有道词典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.15 ubuntu下goldendict有道爬虫小程序]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-15-ubuntu%E4%B8%8Bgoldendict%E6%9C%89%E9%81%93%E7%88%AC%E8%99%AB%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[摘要有道翻译 for GoldenDict 半完美取词显示插件说道linux里面好用的取词软件，不得不数goldendict很不错的，比好几年都没更新linux客户端的有道来说好用的多，毕竟ubuntu18下，有道qt已经存在不兼容，要么降qt版本，要么自己折腾对官方提供的deb安装包进行解包，然后进行修改以来环境的代码，再打包，太麻烦了，当然目前也有基于官方的有道词典打包好的支持ubuntu18系统，可以去我的github下载直接安装就好了，但是打包后我发现一个问题，OCR屏幕取词，一天下来Python和取词插件会把你电脑内存占得满满的，结果就是，你的电脑很卡，所以还是转goldendict吧。 下面高能 将解决目前goldendict的网页引入有道的查词，界面各种不整洁，不友好的解决办法。 Edit By Porter, 积水成渊,蛟龙生焉。 原理原理是爬虫的，我是基于：完了，这是真的，原作者的代码我参考，忘了转移到我的github了，如果，原作看到了，记得给我留言，我加上你的参考地址啊，尴尬了 首先效果图如下图]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>goldendict</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.16 ubuntu18升级后部分应用不能中文输入的问题]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-16-ubuntu18%E5%8D%87%E7%BA%A7%E5%90%8E%E9%83%A8%E5%88%86%E5%BA%94%E7%94%A8%E4%B8%8D%E8%83%BD%E4%B8%AD%E6%96%87%E8%BE%93%E5%85%A5%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[摘要ubuntu18升级后部分应用不能中文输入的问题作者做死尝试新的系统和新的桌面gnome结果悲剧了 问题一：我的爽系统引导失效了，重启直接进入windows不进入ubuntu的登录界面 问题二：我的输入法抽风了，我卸载安装，又卸载安装好多遍，结果还是不能用。本文我们只写如何修复部分应用可以i中文输入，然而像浏览器，啥的并不能英文输入的解决办法 Edit By Porter, 积水成渊,蛟龙生焉。 解决办法是，首先卸载ibus，然后进入系统输入法设置选择输入法为fcitx ，然后重启，开机后就正常了 12345678sudo apt-get remove ibus*sudo apt-get purge ibus*# 卸载～/.cache中的不能中文输入的软件cahe全删除掉sudo rm -rf ~/.cache/gedit/sudo rm -rf ~/.cache/webkitgtk/sudo rm -rf ~/.cache/gnome-software/............sudo rm -rf ~/.cache/google-chrome/ 去官网下载fictx安装的binary 二进制安装文件deb fcitx 12345678910sudo rm -rf ~/.cache/ibus/sudo apt-get install fcitx-binsudo apt-get install fcitx-stablesudo apt-get remove ibussudo apt-get purge ibussudo apt-get remove indicator-keyboardsudo apt-get install fcitxfcitx -r# 下载搜狗官方安装包直接安装，双击或者cd到目录后执行如下代码sudo dpkg -i sogoupinyin_2.2.0.0108_amd64.deb 比如我是x64的，我选择amd64对应的deb，下载后直接双击安装就好 fcitx_4.2.9.6-1_all.deb 建议上面的 sudo apt-get install fcitx-bin sudo apt-get install fcitx-stable 也换成直接官方下载deb包然后安装，在哪可以自己去fcitx官网找到. 最后一步重启，要重启才有用。 然后按照之前那样设置搜狗输入法。 提示，如果你本来就安装了搜狗输入法，你也不用卸载，直接忽略我上面安装搜狗的步骤就好了，效果和重装搜狗一样。笔者是捣鼓的时候，误卸载了搜狗的，所以后面重装了。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>不能中文输入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.14 ubuntu16_18安装peek工具录制gif]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-14-ubuntu16-18%E5%AE%89%E8%A3%85peek%E5%B7%A5%E5%85%B7%E5%BD%95%E5%88%B6gif%2F</url>
    <content type="text"><![CDATA[摘要在写一些博客文章中，一般的png，jpg格式的图片往往满足不了复杂的演示过程，这时peek软件就能很好的帮助我们完成gif文件的制作，并且peek还是一个轻量级的gif制作软件，值得推荐，但是我根据官方的ubuntu安装步骤，发现确实能够安装，但是容易出问题，这里我把我的安装方法写出来，供安装后录制保存就死机的朋友参考。 Edit By Porter, 积水成渊,蛟龙生焉。 一、安装 获取deb包： 1wget https://github.com/phw/peek/releases/download/v0.7.2/peek-0.7.2-Linux.deb 安装依赖： 1sudo apt install libsdl1.2debian ffmpeg libavdevice-ffmpeg56 安装peek： 1sudo dpkg -i peek-0.7.2-Linux.deb 二、使用演示 已启用 类型 名称 命令行 图标 [v] html 词典名称随意填 /词典路径/wordtag.py %GDWORD% /图标路径/png.png]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>peek</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.12 vsftpd 文件配置]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-12-vsftpd-conf%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要 Edit By Porter, 积水成渊,蛟龙生焉。 名称vsftpd.conf - vsftpd的配置文件描述 vsftpd.conf可用于控制vsftpd行为的各个方面。默认情况下，vsftpd在/etc/vsftpd/vsftpd.conf位置查找此文件。但是，您可以通过为vsftpd指定命令行参数来覆盖它。命令行参数是vsftpd的配置文件的路径名。此行为很有用，因为您可能希望使用高级inetd（如 xinetd）以每个虚拟主机为基础启动vsftpd以及不同的配置文件。格式 vsftpd.conf的格式非常简单。每一行都是注释或指令。注释行以＃开头并被忽略。指令行的格式为：选项=值 重要的是要注意在选项，=和值之间放置任何空格是错误的。 每个设置都有一个默认编译，可以在配置文件中修改。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521布尔选项下面是布尔选项列表。布尔选项的值可以设置为YES 或NO。allow_anon_ssl仅在ssl_enable处于活动状态时适用。如果设置为YES，则允许匿名用户使用安全SSL连接。默认值：NOanon_mkdir_write_enable如果设置为YES，则允许匿名用户在特定条件下创建新目录。为此，必须激活选项write_enable，并且匿名ftp用户必须具有父目录的写权限。默认值：NOanon_other_write_enable如果设置为YES，则允许匿名用户执行除上载和创建目录之外的写入操作，例如删除和重命名。通常不建议这样做，但包括完整性。默认值：NOanon_upload_enable如果设置为YES，则允许匿名用户在特定条件下上载文件。为此，必须激活选项write_enable，并且匿名ftp用户必须具有所需上载位置的写入权限。虚拟用户上传也需要此设置; 默认情况下，虚拟用户使用匿名（即最大限制）权限处理。默认值：NOanon_world_readable_only启用后，将只允许匿名用户下载世界可读的文件。这是认识到ftp用户可能拥有文件，尤其是在上传的情况下。默认值：是anonymous_enable控制是否允许匿名登录。如果启用，则用户名ftp和anonymous都将被识别为匿名登录。默认值：是ascii_download_enable启用后，ASCII模式数据传输将在下载时受到尊重。默认值：NOascii_upload_enable启用后，上传时将遵循ASCII模式数据传输。默认值：NOasync_abor_enable启用后，将启用称为“异步ABOR”的特殊FTP命令。只有不明智的FTP客户端才会使用此功能。此外，此功能难以处理，因此默认情况下禁用。遗憾的是，除非此功能可用，否则某些FTP客户端将在取消传输时挂起，因此您可能希望启用它。默认值：NO背景启用后，vsftpd以“监听”模式启动，vsftpd将为侦听器进程提供背景。即控制将立即返回到启动vsftpd的shell。默认值：是check_shell注意！此选项仅对vsftpd的非PAM构建有效。如果禁用，vsftpd将不会检查/ etc / shells是否有用于本地登录的用户shell。默认值：是chmod_enable启用后，允许使用SITE CHMOD命令。注意！这仅适用于本地用户。匿名用户永远不会使用SITE CHMOD。默认值：是chown_uploads如果启用，则所有匿名上载的文件的所有权都将更改为设置chown_username中指定的用户。从管理方面，也许是安全方面来看，这很有用。默认值：NOchroot_list_enable如果激活，您可以在登录时提供其主目录中放置在chroot（）jail中的本地用户列表。如果chroot_local_user设置为YES，则含义略有不同。在这种情况下，列表将成为不被放置在chroot（）jail中的用户列表。默认情况下，包含此列表的文件是/ etc / vsftpd / chroot_list，但您可以使用chroot_list_file设置覆盖它。默认值：NOchroot_local_user如果设置为YES，则登录后本地用户（默认情况下）将放置在其主目录中的chroot（）jail中。警告：此选项具有安全隐患，尤其是在用户具有上载权限或shell访问权限的情况下。只有在您知道自己在做什么时才启用。请注意，这些安全隐患不是vsftpd特定的。它们适用于所有提供将本地用户放在chroot（）jail中的FTP守护进程。默认值：NOconnect_from_port_20这可以控制PORT样式数据连接是否在服务器计算机上使用端口20（ftp-data）。出于安全原因，一些客户可能会坚持认为是这种情况。相反，禁用此选项可使vsftpd以较低的权限运行。默认值：NO（但是示例配置文件启用它）debug_ssl如果为true，则将OpenSSL连接诊断转储到vsftpd日志文件。（在v2.0.6中添加）。默认值：NOdelete_failed_uploads如果为true，则删除任何失败的上载文件。（在v2.0.7中添加）。默认值：NOdeny_email_enable如果激活，您可能会提供一个匿名密码电子邮件响应列表，导致登录被拒绝。默认情况下，包含此列表的文件是/ etc / vsftpd / banned_emails，但您可以使用banned_email_file设置覆盖它。默认值：NOdirlist_enable如果设置为NO，则所有目录列表命令都将拒绝权限。默认值：是dirmessage_enable如果启用，FTP服务器的用户首次进入新目录时可以显示消息。默认情况下，会扫描目录以查找文件.message，但可以使用配置设置message_file覆盖该目录。默认值：NO（但是示例配置文件启用它）download_enable如果设置为NO，则所有下载请求都将拒绝权限。默认值：是dual_log_enable如果启用，则会并行生成两个日志文件，默认情况下为/ var / log / xferlog和/var/log/vsftpd.log。前者是一个wu-ftpd样式的传输日志，可以通过标准工具解析。后者是vsftpd自己的样式日志。默认值：NOforce_dot_files如果激活，则以。开头的文件和目录。即使客户端未使用“a”标志，也将显示在目录列表中。此覆盖不包括“。” 和“..”条目。默认值：NOforce_anon_data_ssl仅在激活ssl_enable时适用。如果激活，则强制所有匿名登录使用安全SSL连接，以便在数据连接上发送和接收数据。默认值：NOforce_anon_logins_ssl仅在激活ssl_enable时适用。如果激活，则强制所有匿名登录使用安全SSL连接以发送密码。默认值：NOforce_local_data_ssl仅在激活ssl_enable时适用。如果激活，则强制所有非匿名登录使用安全SSL连接，以便在数据连接上发送和接收数据。默认值：是force_local_logins_ssl仅在激活ssl_enable时适用。如果激活，则强制所有非匿名登录使用安全SSL连接以发送密码。默认值：是guest_enable如果启用，则所有非匿名登录都被归类为“访客”登录。guest 虚拟机登录将重新映射到guest_username设置中指定的用户。默认值：NOhide_ids如果启用，目录列表中的所有用户和组信息将显示为“ftp”。默认值：NOimplicit_ssl如果启用，则SSL握手是所有连接（FTPS协议）的首要任务。要支持显式SSL和/或纯文本，还应运行单独的vsftpd侦听器进程。默认值：NO听如果启用，vsftpd将以独立模式运行。这意味着不能从某种类型的inetd运行vsftpd。相反，vsftpd可执行文件直接运行一次。然后，vsftpd将负责监听和处理传入的连接。默认值：NOlisten_ipv6与listen参数一样，除了vsftpd将侦听IPv6套接字而不是IPv4套接字。此参数和listen参数是互斥的。默认值：NOlocal_enable控制是否允许本地登录。如果启用，则可以使用/ etc / passwd中的普通用户帐户（或PAM配置引用的任何位置）登录。必须启用此功能才能使任何非匿名登录工作，包括虚拟用户。默认值：NOlock_upload_files启用后，所有上载都会继续对上载文件进行写锁定。所有下载都继续对下载文件进行共享读锁定。警告！在启用此功能之前，请注意恶意阅读器可能会使想要添加文件的作者感到饥饿。默认值：是log_ftp_protocol启用后，将记录所有FTP请求和响应，前提是未启用xferlog_std_format选项。对调试很有用。默认值：NOls_recurse_enable启用后，此设置将允许使用“ls -R”。这是一个小的安全风险，因为大型站点顶层的ls -R可能会消耗大量资源。默认值：NOmdtm_write启用后，此设置将允许MDTM设置文件修改时间（根据通常的访问检查）。默认值：是no_anon_password启用后，这会阻止vsftpd请求匿名密码 - 匿名用户将直接登录。默认值：NOno_log_lock启用后，这会阻止vsftpd在写入日志文件时进行文件锁定。通常不应启用此选项。它的存在是为了解决操作系统错误，例如Solaris / Veritas文件系统组合，有时会出现试图锁定日志文件的挂起。默认值：NOone_process_model如果您有Linux 2.4内核，则可以使用不同的安全模型，每个连接只使用一个进程。它是一种不太纯粹的安全模型，但会提高您的性能。除非您知道自己在做什么，并且您的网站支持大量同时连接的用户，否则您真的不想启用它。默认值：NOpasswd_chroot_enable如果启用，则与chroot_local_user一起，然后可以基于每个用户指定chroot（）jail位置。每个用户的jail都是从/ etc / passwd中的主目录字符串派生的。主目录字符串中出现/./表示jail位于路径中的特定位置。默认值：NOpasv_addr_resolve如果要在pasv_address选项中使用主机名（而不是IP地址），请设置为YES 。默认值：NOpasv_enable如果要禁用PASV获取数据连接的方法，请设置为NO。默认值：是pasv_promiscuous如果要禁用PASV安全检查，则设置为YES，以确保数据连接源自与控制连接相同的IP地址。只有在你知道自己在做什么的情况下才能启用 对此的唯一合法用途是采用某种形式的安全隧道方案，或者可能是为了促进FXP支持。默认值：NOport_enable如果要禁止使用PORT方法获取数据连接，请设置为NO。默认值：是port_promiscuous如果要禁用PORT安全检查，则设置为YES，以确保传出数据连接只能连接到客户端。只有在你知道自己在做什么的情况下才能启用默认值：NOrequire_cert如果设置为yes，则需要所有SSL客户端连接来提供客户端证书。应用于此证书的验证程度由validate_cert控制（在v2.0.6中添加）。默认值：NOrequire_ssl_reuse如果设置为yes，则需要所有SSL数据连接以展示SSL会话重用（这证明它们知道与控制通道相同的主密钥）。虽然这是一个安全的默认设置，但它可能会破坏许多FTP客户端，因此您可能希望禁用它。有关后果的讨论，请参阅 http://scarybeastsecurity.blogspot.com/2009/02/vsftpd-210-released.html（在v2.1.0中添加）。默认值：是reverse_lookup_enable如果希望vsftpd在pam身份验证之前将ip地址转换为主机名，则设置为YES。如果您使用包含主机名的pam_access，这将非常有用。如果您希望vsftpd在某些主机名的反向查找可用并且名称服务器暂时不响应的环境中运行，则应将其设置为NO以避免性能问题。默认值：是run_as_launching_user如果您希望vsftpd作为启动vsftpd的用户运行，则设置为YES。在根访问不可用的情况下，这很有用。大规模警告！除非您完全知道自己在做什么，否则不要启用此选项，因为天真地使用此选项会产生大量安全问题。具体来说，当设置此选项时，vsftpd不会/不能使用chroot技术来限制文件访问（即使由root启动）。一个糟糕的替代品可能是使用deny_file 设置如&#123;/*,*..*&#125;，但这种可靠性无法与chroot相比，不应该依赖。如果使用此选项，则适用对其他选项的许多限制。例如，需要权限的选项（例如非匿名登录，上载所有权更改，从端口20连接以及小于1024的侦听端口）预计不起作用。其他选项可能会受到影响。默认值：NOsecure_email_list_enable如果您只想接受匿名登录的指定电子邮件密码列表，请设置为YES。这非常有用，可以在不需要虚拟用户的情况下限制对低安全性内容的访问。启用后，将禁止匿名登录，除非在email_password_file设置指定的文件中列出了提供的密码。文件格式是每行一个密码，没有额外的空格。默认文件名是/ etc / vsftpd / email_passwords。默认值：NOsession_support这可以控制vsftpd是否尝试维护登录会话。如果vsftpd正在维护会话，它将尝试更新utmp和wtmp。如果使用PAM进行身份验证，它也会打开pam_session，并且只有在注销时关闭它。如果您不需要会话日志记录，您可能希望禁用此功能，并希望为vsftpd提供更多机会以更少的进程和/或更少的权限运行。注 - utmp和wtmp支持仅在启用PAM的构建中提供。默认值：NOsetproctitle_enable如果启用，vsftpd将尝试在系统进程列表中显示会话状态信息。换句话说，报告的进程名称将更改以反映vsftpd会话正在执行的操作（空闲，下载等）。出于安全考虑，您可能希望将其关闭。默认值：NOssl_enable如果启用，并且vsftpd是针对OpenSSL编译的，则vsftpd将通过SSL支持安全连接。这适用于控制连接（包括登录）以及数据连接。您还需要一个支持SSL的客户端。注意！！请注意启用此选项。只有在需要时才启用它。vsftpd无法保证OpenSSL库的安全性。通过启用此选项，您声明您信任已安装的OpenSSL库的安全性。默认值：NOssl_request_cert如果启用，vsftpd会要求（但不一定需要;见 require_cert）一个证书上的传入 SSL 连接。通常这不应该造成任何麻烦，但IBM zOS似乎有问题。（v2.0.7中的新功能）。默认值：是ssl_sslv2仅在激活ssl_enable时适用。如果启用，此选项将允许SSL v2协议连接。TLS v1连接是首选。默认值：NOssl_sslv3仅在激活ssl_enable时适用。如果启用，此选项将允许SSL v3协议连接。TLS v1连接是首选。默认值：NOssl_tlsv1仅在激活ssl_enable时适用。如果启用，此选项将允许TLS v1协议连接。TLS v1连接是首选。默认值：是strict_ssl_read_eof如果启用，则需要通过SSL终止SSL数据上载，而不是套接字上的EOF。需要此选项以确保攻击者未使用伪造的TCP FIN过早终止上载。不幸的是，默认情况下它没有启用，因为很少有客户端能够正确使用它。（v2.0.7中的新功能）。默认值：NOstrict_ssl_write_shutdown如果启用，则需要通过SSL终止SSL数据下载，而不是套接字上的EOF。默认情况下这是关闭的，因为我无法找到执行此操作的单个FTP客户端。这是次要的。它影响的是我们判断客户是否确认完全收到该文件的能力。即使没有此选项，客户端也能够检查下载的完整性。（v2.0.7中的新功能）。默认值：NOsyslog_enable如果启用，那么将转到/var/log/vsftpd.log的任何日志输出都将转到系统日志。记录在FTPD工具下完成。默认值：NOtcp_wrappers的如果启用，并且vsftpd是使用tcp_wrappers支持编译的，则传入连接将通过tcp_wrappers访问控制提供。此外，还有一种基于每个IP的配置机制。如果tcp_wrappers设置VSFTPD_LOAD_CONF环境变量，则vsftpd会话将尝试加载此变量中指定的vsftpd配置文件。默认值：NOtext_userdb_names默认情况下，数字ID显示在目录列表的用户和组字段中。您可以通过启用此参数来获取文本名称。出于性能原因，它默认是关闭的。默认值：NOtilde_user_enable如果启用，vsftpd将尝试解析路径名，例如~chris / pics，即代字号后跟用户名。请注意，vsftpd将始终解析路径名〜和〜/ something（在这种情况下，〜解析为初始登录目录）。请注意，只有在_current_ chroot（）jail中找到文件/ etc / passwd时，〜用户路径才会解析 。默认值：NOuse_localtime如果启用，vsftpd将显示当前时区中包含时间的目录列表。默认为显示GMT。MDTM FTP命令返回的时间也受此选项的影响。默认值：NOuse_sendfile用于测试在平台上使用sendfile（）系统调用的相对好处的内部设置。默认值：是userlist_deny如果激活userlist_enable，则检查此选项。如果将此设置设置为NO，则将拒绝用户登录，除非它们明确列在userlist_file指定的文件中。拒绝登录时，将在要求用户输入密码之前发出拒绝。默认值：是userlist_enable如果启用，vsftpd将从userlist_file给出的文件名加载用户名列表。如果用户尝试使用此文件中的名称登录，则在要求输入密码之前，他们将被拒绝。这可能有助于防止传输明文密码。另请参见 userlist_deny。默认值：NOvalidate_cert如果设置为yes，则收到的所有SSL客户端证书都必须验证OK。自签名证书不构成OK验证。（v2.0.6中的新功能）。默认值：NOuserlist_log如果激活userlist_enable，则检查此选项。如果启用，将记录基于用户列表的每个登录拒绝。默认值：NOvirtual_use_local_privs如果启用，虚拟用户将使用与本地用户相同的权限。默认情况下，虚拟用户将使用与匿名用户相同的权限，这往往更具限制性（特别是在写访问方面）。默认值：NOWRITE_ENABLE这可以控制是否允许任何更改文件系统的FTP命令。这些命令是：STOR，DELE，RNFR，RNTO，MKD，RMD，APPE和SITE。默认值：NOxferlog_enable如果启用，将维护一个日志文件，详细说明上载和下载。默认情况下，此文件将放在/var/log/vsftpd.log中，但可以使用配置设置vsftpd_log_file覆盖此位置。默认值：NO（但是示例配置文件启用它）xferlog_std_format如果启用，传输日志文件将以标准xferlog格式写入，如wu-ftpd所使用。这很有用，因为您可以重用现有的传输统计信息生成器 但是，默认格式更具可读性。此样式的日志文件的缺省位置是/ var / log / xferlog，但您可以使用xferlog_file设置进行更改。默认值：NOisolate_network如果启用，请使用CLONE_NEWNET隔离不受信任的进程，以便它们不能执行任意connect（），而是必须向特权进程请求套接字（必须禁用port_promiscuous）。默认值：是隔离如果启用，请使用CLONE_NEWPID和CLONE_NEWIPC将进程隔离到其ipc和pid名称空间。因此，分离的流程不能相互交互。默认值：是数字选项以下是数字选项列表。必须将数字选项设置为非负整数。支持八进制数，以方便umask选项。要指定八进制数，请使用0作为数字的第一个数字。accept_timeout远程客户端与PASV样式数据连接建立连接的超时（以秒为单位）。默认值：60anon_max_rate匿名客户端允许的最大数据传输速率（以字节/秒为单位）。默认值：0（无限制）anon_umask为匿名用户设置用于文件创建的umask的值。注意！如果要指定八进制值，请记住“0”前缀，否则该值将被视为基数为10的整数！默认值：077chown_upload_mode要强制进行chown（）ed匿名上传的文件模式。（在v2.0.6中添加）。默认值：0600connect_timeout远程客户端响应PORT样式数据连接的超时（以秒为单位）。默认值：60data_connection_timeout超时（以秒为单位），大致是我们允许数据传输停止而没有进度的最长时间。如果超时触发，则启动远程客户端。默认值：300delay_failed_login报告登录失败之前暂停的秒数。默认值：1delay_successful_login允许成功登录之前暂停的秒数。默认值：0file_open_mode用于创建上载文件的权限。Umasks应用于此值之上。如果您希望上传的文件可执行，您可能希望更改为0777。默认值：0666ftp_data_portPORT样式连接源自的端口（只要命名不佳的connect_from_port_20已启用）。默认值：20idle_session_timeout超时（以秒为单位），即远程客户端在FTP命令之间可能花费的最长时间。如果超时触发，则启动远程客户端。默认值：300listen_port如果vsftpd处于独立模式，则它将侦听传入FTP连接的端口。默认值：21local_max_rate本地身份验证用户允许的最大数据传输速率（以字节/秒为单位）。默认值：0（无限制）local_umask为本地用户设置用于文件创建的umask的值。注意！如果要指定八进制值，请记住“0”前缀，否则该值将被视为基数为10的整数！默认值：077max_clients如果vsftpd处于独立模式，则这是可以连接的最大客户端数。连接的任何其他客户端都将收到错误消息。值0关闭限制。默认值：2000max_login_fails在此多次登录失败后，会话被终止。默认值：3max_per_ip如果vsftpd处于独立模式，则这是可以从同一源Internet地址连接的最大客户端数。如果客户端超过此限制，则会收到错误消息。值0关闭限制。默认值：50pasv_max_port为PASV样式数据连接分配的最大端口。可用于指定窄端口范围以协助防火墙。默认值：0（使用任何端口）pasv_min_port为PASV样式数据连接分配的最小端口。可用于指定窄端口范围以协助防火墙。默认值：0（使用任何端口）trans_chunk_size您可能不想更改此设置，但请尝试将其设置为8192，以获得更加平滑的带宽限制器。默认值：0（让vsftpd选择合理的设置）字符串选项以下是字符串选项列表。anon_root此选项表示vsftpd在匿名登录后尝试更改的目录。失败被默默地忽略了。默认值:(无）banned_email_file此选项是包含不允许的匿名电子邮件密码列表的文件的名称。如果启用了选项deny_email_enable，则会查询此文件 。默认值：/ etc / vsftpd / banned_emailsbanner_file此选项是包含要在有人连接到服务器时显示的文本的文件的名称。如果设置，它将覆盖ftpd_banner选项提供的标题字符串 。默认值:(无）ca_certs_file此选项是用于加载证书颁发机构证书的文件的名称，用于验证客户端证书。加载的证书也会通告给客户端，以满足TLSv1.0客户端的需求，例如z / OS FTP客户端。遗憾的是，由于vsftpd使用受限制的文件系统空间（chroot），因此未使用默认的SSL CA证书路径。（在v2.0.6中添加）。默认值:(无）chown_username这是获得匿名上传文件所有权的用户的名称。仅当设置了另一个选项chown_uploads时，此选项才有意义。默认值：rootchroot_list_file该选项是包含本地用户列表的文件的名称，该列表将放置在其主目录中的chroot（）jail中。仅当启用了选项chroot_list_enable时，此选项才有意义。如果启用了选项chroot_local_user，则列表文件将成为不放置在chroot（）jail中的用户列表。默认值：/etvsftpd.confc/vsftpd.chroot_listcmds_allowed此选项指定允许的FTP命令的逗号分隔列表（登录后.USER，PASS和QUIT以及其他始终允许在登录前使用）。其他命令被拒绝。这是一种真正锁定FTP服务器的强大方法。示例：cmds_allowed = PASV，RETR，QUIT默认值:(无）cmds_denied此选项指定以逗号分隔的拒绝FTP命令列表（登录后。始终允许登录前使用USER，PASS，QUIT等）。如果此命令和cmds_allowed上都出现命令，则拒绝优先。（在v2.1.0中添加）。默认值:(无）deny_file此选项可用于设置文件名（和目录名称等）的模式，这些模式不应以任何方式访问。受影响的项目不会被隐藏，但任何尝试对它们做任何事情（下载，更改到目录，影响目录内的某些内容等）都将被拒绝。此选项非常简单，不应用于严格的访问控制 - 应优先使用文件系统的权限。但是，此选项在某些虚拟用户设置中可能很有用。特别要注意的是，如果文件名可以通过各种名称访问（可能是由于符号链接或硬链接），那么必须注意拒绝访问所有名称。如果项目的名称包含hide_file给出的字符串，或者它们与hide_file指定的正则表达式匹配，则将拒绝访问项目。请注意，vsftpd' 正则表达式匹配代码是一个简单的实现，它是完整正则表达式功能的子集。因此，您需要仔细而详尽地测试此选项的任何应用程序。并且由于其更高的可靠性，建议您对任何重要的安全策略使用文件系统权限。支持的正则表达式语法是任意数量的* ,? 和unnested &#123;，&#125;运算符。仅在路径的最后一个组件上支持正则表达式匹配，例如a / b /？支持，但/？/ c不支持。示例：deny_file = &#123;*。mp3，*。mov，.private&#125; 并且由于其更高的可靠性，建议您对任何重要的安全策略使用文件系统权限。支持的正则表达式语法是任意数量的* ,? 和unnested &#123;，&#125;运算符。仅在路径的最后一个组件上支持正则表达式匹配，例如a / b /？支持，但/？/ c不支持。示例：deny_file = &#123;*。mp3，*。mov，.private&#125; 并且由于其更高的可靠性，建议您对任何重要的安全策略使用文件系统权限。支持的正则表达式语法是任意数量的* ,? 和unnested &#123;，&#125;运算符。仅在路径的最后一个组件上支持正则表达式匹配，例如a / b /？支持，但/？/ c不支持。示例：deny_file = &#123;*。mp3，*。mov，.private&#125;默认值:(无）dsa_cert_file此选项指定用于SSL加密连接的DSA证书的位置。默认值:(无 - RSA证书就足够了）dsa_private_key_file此选项指定用于SSL加密连接的DSA私钥的位置。如果未设置此选项，则预期私钥与证书位于同一文件中。默认值:(无）email_password_file此选项可用于提供secure_email_list_enable设置使用的备用文件。默认值：/ etc / vsftpd / email_passwordsftp_username这是我们用于处理匿名FTP的用户的名称。该用户的主目录是匿名FTP区域的根目录。默认值：ftpftpd_banner此字符串选项允许您在首次进入连接时覆盖vsftpd显示的问候语横幅。默认值:(无 - 显示默认的vsftpd横幅）guest_username有关guest虚拟机登录的说明，请参阅boolean设置guest_enable。此设置是访客用户映射到的真实用户名。默认值：ftphide_file此选项可用于设置文件名（和目录名称等）的模式，这些模式应该从目录列表中隐藏。尽管被隐藏，但是知道实际使用的名称的客户端可以完全访问文件/目录等。如果项目的名称包含hide_file给出的字符串，或者它们与hide_file指定的正则表达式匹配，则将隐藏项目。请注意，vsftpd的正则表达式匹配代码是一个简单的实现，它是完整正则表达式功能的子集。有关具体支持的正则表达式语法的详细信息，请参阅deny_file。示例：hide_file = &#123;*。mp3，.hidden，hide *，h？&#125;默认值:(无）listen_address如果vsftpd处于独立模式，则此设置可能会覆盖（所有本地接口的）默认侦听地址。提供数字IP地址。默认值:(无）listen_address6与listen_address类似，但指定IPv6侦听器的默认侦听地址（如果设置了listen_ipv6，则使用该地址）。格式是标准IPv6地址格式。默认值:(无）local_root此选项表示vsftpd在本地（即非匿名）登录后尝试更改的目录。失败被默默地忽略了。默认值:(无）message_file此选项是输入新目录时我们查找的文件的名称。内容显示给远程用户。仅当启用了选项dirmessage_enable时，此选项才有意义。默认值：.messagenopriv_user这是vsftpd在完全没有特权的情况下使用的用户名。请注意，这应该是专用用户，而不是任何人。在大多数机器上，用户没有倾向于使用很多重要的东西。默认值：没人pam_service_name此字符串是vsftpd将使用的PAM服务的名称。默认值：ftppasv_address设置使用此选项可覆盖vsftpd将响应PASV命令而通告的IP地址。提供数字IP地址，除非 启用了pasv_addr_resolve，在这种情况下，您可以提供在启动时为您解析的DNS主机名。默认值:(无 - 地址来自传入的连接套接字）rsa_cert_file此选项指定用于SSL加密连接的RSA证书的位置。默认值：/usr/share/ssl/certs/vsftpd.pemrsa_private_key_file此选项指定用于SSL加密连接的RSA私钥的位置。如果未设置此选项，则预期私钥与证书位于同一文件中。默认值:(无）secure_chroot_dir此选项应该是空目录的名称。此外，ftp用户不应该写入该目录。此目录有时用作安全chroot（）jail，vsftpd不需要文件系统访问。默认值：/ usr / share / empty的ssl_ciphers此选项可用于选择vsftpd允许加密SSL连接的SSL密码。有关更多详细信息，请参见密码手册页。请注意，限制密码可能是一种有用的安全预防措施，因为它可以防止恶意远程方强制使用已发现问题的密码。默认值：DES-CBC3-SHAuser_config_dir这个功能强大的选项允许基于每个用户覆盖手册页中指定的任何配置选项。用法很简单，最好用一个例子来说明。如果将user_config_dir设置为/ etc / vsftpd / user_conf然后以用户“chris”身份登录，则vsftpd将在会话期间应用文件/ etc / vsftpd / user_conf / chris中的设置。此文件的格式详见本手册页！请注意，并非所有设置都是基于每个用户有效。例如，许多设置仅在用户会话启动之前。不会影响每个用户的任何行为的设置示例包括listen_address，banner_file，max_per_ip，max_clients，xferlog_file等。默认值:(无）user_sub_token此选项与虚拟用户结合使用非常有用。它用于根据模板为每个虚拟用户自动生成主目录。例如，如果通过guest_username指定的真实用户的主目录是/ home / virtual / $ USER，并且user_sub_token设置为 $ USER，那么当虚拟用户fred登录时，他将结束（通常是chroot（）'ed ）在目录/ home / virtual / fred中。如果local_root包含user_sub_token，则此选项也会生效。默认值:(无）userlist_file此选项是userlist_enable选项处于活动状态时加载的文件的名称。默认值：/ etc / vsftpd / user_listvsftpd_log_file此选项是我们编写vsftpd样式日志文件的文件的名称。仅当设置了选项xferlog_enable并且未设置xferlog_std_format时， 才会写入此日志。或者，如果已设置选项dual_log_enable，则会写入。另一个复杂因素 - 如果您设置了syslog_enable，则不会写入此文件，而是将输出发送到系统日志。默认值：/var/log/vsftpd.logxferlog_file此选项是我们编写wu-ftpd样式传输日志的文件的名称。仅当 设置了xferlog_enable选项以及xferlog_std_format时才会写入传输日志。或者，如果已设置选项dual_log_enable，则会写入。默认值：/ var / log / xferlog 作者scarybeasts@gmail.com 英文参考文件位置]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>vsftpd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年2020年房地产]]></title>
    <url>%2F%E9%99%84%E5%BD%95-2019%E5%B9%B42020%E5%B9%B4%E6%88%BF%E5%9C%B0%E4%BA%A7%2F</url>
    <content type="text"><![CDATA[摘要2019年2020年房地产 Edit By Porter, 积水成渊,蛟龙生焉。 康波周期，蔡森，技术派；周金涛，周期派。新财富最佳策略分析师榜单 苑举正 股市 https://pynative.com/python-mysql-blob-insert-retrieve-file-image-as-a-blob-in-mysql/]]></content>
      <categories>
        <category>summary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[1.13 mysql 笔记]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-13-mysql-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录mysql的相关文档，包括安装，配置和数据库访问相关代码 Edit By Porter, 积水成渊,蛟龙生焉。 一、下载安装mysql1.1 准备工作 MySQL8.0 For Windows zip包 -&gt; : 下载地址 [1] 解压 我的解压在了D:\program\mysql\mysql-8.0.11-winx64 [2] 配置环境变量 [3] 配置初始化的my.ini文件 我们发现解压后的目录并没有my.ini文件，没关系可以自行创建。在安装根目录下添加 my.ini（新建文本文件，将文件类型改为.ini），写入基本配置： 12345678910111213141516171819202122232425[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\Program Files\MySQL# 设置mysql数据库的数据的存放目录datadir=D:\Program Files\MySQL\Data# 允许最大连接数max_connections=200# 允许连接失败的次数。max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证#mysql_native_passworddefault_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8 注意：其中的data目录不需要创建，下一步初始化工作中会自动创建 1.2 安装工作在安装时，必须以管理员身份运行cmd，否则在安装时会报错，会导致安装失败的情况 1.2.1 初始化数据库1CD \d D:/ 在MySQL安装目录的 bin 目录下执行命令： 1mysqld --initialize --console 执行完成后，会打印 root 用户的初始默认密码，比如： 12345D:\Program Files\mysql\bin&gt;mysqld --initialize --console2019-02-14T11:47:59.282979Z 0 [System] [MY-013169] [Server] D:\Program Files\mysql\bin\mysqld.exe (mysqld 8.0.15) initializing of server in progress as process 137522019-02-14T11:47:59.284705Z 0 [Warning] [MY-013242] [Server] --character-set-server: 'utf8' is currently an alias for the character set UTF8MB3, but will be an alias for UTF8MB4 in a future release. Please consider using UTF8MB4 in order to be unambiguous.2019-02-14T11:48:40.707445Z 5 [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 7CwffH5&lt;(lem2019-02-14T11:49:02.894787Z 0 [System] [MY-013170] [Server] D:\Program Files\mysql\bin\mysqld.exe (mysqld 8.0.15) initializing of server has completed 注意！执行输出结果里面有一段： [Note] [MY-010454] [Server] A temporary password is generated for root@localhost: 7CwffH5&lt;(lem,D 其中root@localhost:后面的“7CwffH5&lt;(lem,D”就是初始密码（不含首位空格）。在没有更改密码前，需要记住这个密码，后续登录需要用到。要是你手贱，关快了，或者没记住，那也没事，删掉初始化的 datadir 目录，再执行一遍初始化命令，又会重新生成的。当然，也可以使用安全工具，强制改密码，用什么方法，自己随意。 1.3 安装服务在MySQL安装目录的 bin 目录下执行命令： 1mysqld --install [服务名] 后面的服务名可以不写，默认的名字为 mysql。当然，如果你的电脑上需要安装多个MySQL服务，就可以用不同的名字区分了，比如 mysql5 和 mysql8。安装完成之后，就可以通过命令net start mysql启动MySQL的服务了。通过命令net stop mysql停止服务。通过命令sc delete MySQL/mysqld -remove卸载 MySQL 服务 1.4 更改密码下面提供两种方法修改密码，一种是GUI界面的一种是终端操作 1.4.1 GUI界面修改密码（推荐） 这里附上软件下载地址: 链接: https://pan.baidu.com/s/19mjZmCgZYaXRezxdukuG0w 提取码: m7de 复制这段内容后打开百度网盘手机App，操作更方便哦 新建的MySQL的连接 还记得刚刚让你复制的root @ localhost：后面的初始密码了吗？现在要用到它了复制粘贴上去！测试一下！ MySQL的是成功安装了也可以登录现在就是改密码的时候了写SQL改密码吗？太麻烦了太低来我有个简单的方法用Navicat的点击刚刚的连接就会提示我们输入新密码 1.4.2 终端方式修改密码终端里管理员身份运行cmd,并CD 到在MySQL安装目录的 bin 目录下执行命令： 1mysql -u root -p 这时候会提示输入密码，记住了上面第3.1步安装时的密码，填入即可登录成功，进入MySQL命令模式。 在MySQL中执行命令： 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;新密码&apos;; 修改密码，注意命令尾的；一定要有，这是mysql的语法 二、账号配置与使用测试2.1 数据库的创建、表单和字段配置 创建数据库：iodata 创建数据库表单：teacher ，user_info 创建数据库表单中的字段：user_id，user_pass，user_modified 等等 设置数据库表单中的主键。 1234567891011121314151617CREATE DATABASE iodata;use iodata;/*show tables;create table teacher ( code varchar(20) primary key, name varchar(20));*/CREATE TABLE user_info( ID int NOT NULL AUTO_INCREMENT,/* 设置自动加的用户ID*/ user_id VARCHAR(200) NOT NULL,/*支持中英文200个字符的用户字符串*/ user_pass VARCHAR(200) NOT NULL, user_create datetime(3) NULL DEFAULT CURRENT_TIMESTAMP(3), user_modified datetime(3) NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3), PRIMARY KEY (ID)/* 设置主键*/); 2.2 配置数据库的用户访问账号密码，权限123456use iodata;CREATE USER &apos;porter&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;shuruniziji_mima&apos;;/* 创建用户 */INSERT INTO iodata.user_info ( user_id, user_pass) VALUES ( &apos;porter&apos;, &apos;123&apos;); grant all privileges on *.* to &apos;porter&apos;@&apos;%&apos;; /* 放行用户的所有权限并允许远程网络连接 */ Python 代码来链接数据库 如下代码功能是链接数据库并从数据库中读取数据并打印出来 123456789101112131415161718192021222324# -*- coding:utf-8 -*-import pymysqlimport sysdef get_db_data(): connect = pymysql.Connect( host="210.28.33.2", port=3306, user="porter", passwd="smrit", db="iodata", charset='utf8' ) print("写入中，请等待……") cursor = connect.cursor() sql = "select * from user_info" cursor.execute(sql) number = cursor.fetchall() print(number) cursor.close() connect.close()if __name__ == "__main__": get_db_data() 三、简单的操作例程3.1 存储图片的数据库读写操作使用上面推荐的GUI数据库操作工具：Navicat Premium, 软件，在软件中执行 12use iodata;CREATE TABLE Images(Id INT PRIMARY KEY AUTO_INCREMENT, Data MEDIUMBLOB); 读取数据库中图片的Python 代码 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-import pymysqlimport matplotlib.pyplot as pltimport matplotlib.image as mpimg # mpimg 用于读取图片import sysdef get_loan_number(file): connect = pymysql.Connect( host="210.28.33.2", port=3306, user="porter", passwd="smriti", db="iodata", charset='utf8' ) print("写入中，请等待……") cursor = connect.cursor() sql = "select Data from images LIMIT 1" cursor.execute(sql) fout = open('2.jpg','wb') image_file = cursor.fetchone()[0] fout.write(image_file) fout.close() cursor.close() connect.close() print("写入完成,共写入%d条数据……" % 1)if __name__ == "__main__": # file = r"C:\Users\test\Desktop\loanNUmber.txt" file = "task1.txt" get_loan_number(file) 3.2 读取数据数据并保存在txt文件中123456789101112131415161718192021222324252627282930313233343536373839404142# -*- coding:utf-8 -*-import pymysqldef get_loan_number(file): connect = pymysql.Connect( host="106.14.221.55", port=3306, user="nadersidc", passwd="366583", db="defect_detecting", charset='utf8' ) print("写入中，请等待……") cursor = connect.cursor() # sql = "select id from application where status='SUBMITTING' and contract like 'Performance-%' and " \ # "loan_org_party='166490194444444444'" # sql = "select Element.Id,Element.FileName,DefectPosition.TopX,DefectPosition.TopY,\ # DefectPosition.Width,DefectPosition.Height from Element,DefectPosition where Element.DefectId=6 \ # and Element.ImageTypeId=2 and DefectPosition.ElementId=Element.Id" # sql = "select * from Element LIMIT 1,5" # sql = "select * from * LIMIT 1,5" # 查询数据库表中所有的表名字 # sql = "select table_name from information_schema.tables where table_schema='defect_detecting'" sql = "select * from TrainProject LIMIT 1,5" cursor.execute(sql) number = cursor.fetchall() fp = open(file, "w") loan_count = 0 for loanNumber in number: loan_count += 1 fp.write(str(loanNumber)+'\n') fp.close() cursor.close() connect.close() print("写入完成,共写入%d条数据……" % loan_count)if __name__ == "__main__": # file = r"C:\Users\test\Desktop\loanNUmber.txt" file = "task2.txt" get_loan_number(file) 3.2 读取数据数据并直接显示 涉及一个问题，就是数据库中的图片是二进制流的，如何直接从数据库中获取数据并显示]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.11 sublime text3插件介绍]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-11-sublime-text3%E6%8F%92%E4%BB%B6%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[摘要Package Control 包控制安装最简单的安装方法是通过 Sublime Text 控制台。控制台可以通过 ctrl +` 快捷方式 或 View &gt; Show Console 菜单来开启/关闭。 打开后，将适用于你 Sublime Text 版本的 Python 代码粘贴到控制台中。 /Sublime Text 3 包控制安装代码/ 12345678910import urllib.request,os,hashlib; h = 'df21e130d211cfc94d9b0905775a7c0f' + '1e3d39e33b79698005270310898eea76'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read();dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by) Edit By Porter, 积水成渊,蛟龙生焉。 通过Package Control 包控制安装插件Package Control（包控制）是安装下面列出的所有插件和主题的最佳方式。继续，在包控制中安装插件。通过 Package Control（包控制）安装插件和主题很简单： 使用方法：进入命令面板（ctrl + shift+ p），然后键入 install。然后键入 remove 删除。 Emmet Emmet绝对的节省时间。您可以轻松快速地编写HTML。 BracketHighlighter 该插件提供行数列高亮的各种配对的语法符号。（愚人码头注：就是将配对的括号等显示在行数列上 Colorpicker 使用一个取色器改变颜色使用方法: ctrl + shift + c DocBlockr 一个真正简单的方式来轻松地创建许多语言包括JavaScript，PHP和CoffeeScript的文档块。只要在函数的上面输入/**，按Tab就可以了。DocBlockr会观察函数需要的变量名和类型，并创建文档块。 SidebarEnhancements 扩展文件树右键功能 CSSComb 用来给CSS属性进行排序的格式化注：因为Csscomb的快捷键是shift+ctrl+c，可能与其他快捷键冲突你可以去Preferences–&gt;插件设置–&gt;CssComb–&gt;key-Bindings-Defallut设置 ColorHighlighter 它可以展示你所选择的颜色代码（像“#FFFFFF”, “rgb(255,255,255)”, “white”）的真正颜色。同时它还包含一个颜色选择器让你可以方便地更改颜色。 使用：快捷键Windows: ctrl+shift+w Trailing spaces 功能：检测并一键去除代码中多余的空格使用：安装插件并重启，即可自动提示多余空格。一键删除多余空格：CTRL+SHITF+T（需配置）快捷键配置：在Preferences / Key Bindings – User加上代码（数组内）{ “keys”: [“ctrl+shift+t”], “command”: “delete_trailing_spaces” }, auto-save 功能：自动保存文件使用：默认是不会自动保存，按快捷键Ctrl+Shift+S开启。快捷键配置方法：首选项-快捷键设置，在数组内添加{ “keys”: [“ctrl+shift+s”], “command”: “auto_save” },如需自动启用，首选项-插件-auto-save## settings-usre粘帖一下配置{“auto_save_on_modified”: true,“auto_save_delay_in_seconds”: 10,“auto_save_all_files”: true,“auto_save_current_file”: “”,“auto_save_backup”: false,“auto_save_backup_suffix”: “autosave”} view in browser 功能：通过默认浏览器打开文件使用：快捷键配置方法：首选项-快捷键设置，在数组内添加快捷键：{ “keys”: [“f12”], “command”: “open_in_browser” }, autoprefixer 功能：CSS添加私有前缀简介：CSS还未标准化，所以要给各大浏览器一个前缀以解决兼容问题使用：快捷键配置方法：首选项-快捷键设置，在数组内添加{ “keys”: [“ctrl+shift+enter”], “command”: “autoprefixer” },快捷键：ctrl+shift+enter CSS Extended Completions 功能：关联CSS文件智能提示css文件中的类名，非常好用 JavaScript Completions 功能：支持javascript原生语法提示 jQuery 功能：jQ函数提示简介：快捷输入jQ函数，是偷懒的好方法 AutoFileName 功能：快捷输入文件名简介：自动完成文件名的输入，如图片选取使用：输入”/”即可看到相对于本项目文件夹的其他文件 HTML-CSS-JS Prettify 功能：快捷输入文件名简介: 编辑HTML, CSS, JS时，经常会出现缩进不对，代码行不对其的情况。装了这个插件之后，只要按下 Ctrl+Shift+h (Windows), Command+Shift+h (Mac), 你的文档就会被整理干净。 注: 需要配置node文件路径 HTML-CSS-JS Prettify &gt; plugin Options]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>sublime test3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 帮助文档检索方法]]></title>
    <url>%2F%E9%99%84%E5%BD%95-Python-%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3%E6%A3%80%E7%B4%A2%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习Python 相关如何查找帮助文档，提升编程效率。 Edit By Porter, 不积跬步无以至千里。 Python中的Module很丰富，一段时间不用，我们就会忘记各个模块的功能作用，以及如何调用模块中的方法。所以会使用帮助文档，以及高效的使用帮助文档，将变得十分重要。 一、查看python中模块的所有方法命令行下使用pydoc命令1在命令行下运行$ pydoc modules即可查看 在python交互解释器中使用help()查看1在交互式解释器中输入&gt;&gt;&gt; help("modules")即可，效果跟在命令行下输入$ pydoc modules是一样的 又如： 123456789&gt;&gt;&gt; help(math.sin)Help on built-in function sin in module math:sin(...) sin(x) Return the sine of x (measured in radians).&gt;&gt;&gt; 查看函数信息的另一种方法print(func_name.doc)如查看内建函数print用法 123456&gt;&gt;&gt; print(print.__doc__)print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)Prints the values to a stream, or to sys.stdout by default....&gt;&gt;&gt; doc前后是两个短下划线，在python中会合并为长下划线python中的help()类似unix中的man指令，熟悉后会对我们的编程带来很大帮助 查看模块下所有函数dir(module_name)如我们需要列举出math模块下所有的函数名称 123&gt;&gt;&gt; dir(math)['__doc__', '__loader__', '__name__',...]&gt;&gt;&gt; 又如： 12345678910import requests,os,randomprint(dir(random))# [&apos;BPF&apos;, &apos;LOG4&apos;, &apos;NV_MAGICCONST&apos;, &apos;RECIP_BPF&apos;, &apos;Random&apos;, &apos;SG_MAGICCONST&apos;, &apos;SystemRandom&apos;, # &apos;TWOPI&apos;, &apos;_BuiltinMethodType&apos;, &apos;_MethodType&apos;, &apos;_Sequence&apos;, &apos;_Set&apos;, &apos;__all__&apos;, &apos;__builtins__&apos;, # &apos;__cached__&apos;, &apos;__doc__&apos;, &apos;__file__&apos;, &apos;__loader__&apos;, &apos;__name__&apos;, &apos;__package__&apos;, &apos;__spec__&apos;, &apos;_acos&apos;, # &apos;_ceil&apos;, &apos;_cos&apos;, &apos;_e&apos;, &apos;_exp&apos;, &apos;_inst&apos;, &apos;_log&apos;, &apos;_pi&apos;, &apos;_random&apos;, &apos;_sha512&apos;, &apos;_sin&apos;, &apos;_sqrt&apos;, &apos;_test&apos;,# &apos;_test_generator&apos;, &apos;_urandom&apos;, &apos;_warn&apos;, &apos;betavariate&apos;, &apos;choice&apos;, &apos;expovariate&apos;, &apos;gammavariate&apos;, &apos;gauss&apos;, # &apos;getrandbits&apos;, &apos;getstate&apos;, &apos;lognormvariate&apos;, &apos;normalvariate&apos;, &apos;paretovariate&apos;, &apos;randint&apos;, &apos;random&apos;, &apos;randrange&apos;, # &apos;sample&apos;, &apos;seed&apos;, &apos;setstate&apos;, &apos;shuffle&apos;, &apos;triangular&apos;, &apos;uniform&apos;, &apos;vonmisesvariate&apos;, &apos;weibullvariate&apos;] 在python交互是解释器下导入sys模块查看python的sys模块也是可以用来查看模块信息的 12&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules.keys() 命令行下使用pip查看 如果你使用的是pip来作为你的python包管理器的话，可以在命令行下直接运行$ pip freeze或者$ pip list来查看安装包的信息，当然其它的包管理器也有类似的功能，同时，你也可以在python交互式解释器中导入pip模块来查看包信息 12345import pipinstalled_packages = pip.get_installed_distributions()installed_packages_list = sorted(["%s==%s" % (i.key, i.version) for i in installed_packages])print(installed_packages_list) 使用yolk来查看 如果你安装过yolk的话可以使用yolk命令来查看包信息，你可以使用$ pip install yolk来安装它yolk使用简单，只需在命令行下操作即可 1234$ yolk -l #列出所有安装模块$ yolk -a #列出激活的模块$ yolk -n #列出非激活模块$ yolk -U [packagename] # 通过查询pypi来查看（该）模块是否有新版本]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Module篇使用__future__]]></title>
    <url>%2F%E9%99%84%E5%BD%95-Module%E7%AF%87%E4%BD%BF%E7%94%A8-future%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习Python 相关编程的总结及其他信息。 Edit By Porter, 不积跬步无以至千里。 官方定义参考地址— Future statement definitions。 future is a real module, and serves three purposes: To avoid confusing existing tools that analyze import statements and expect to find the modules they’re importing. To ensure that future statements run under releases prior to 2.1 at least yield runtime exceptions (the import of future will fail, because there was no module of that name prior to 2.1). To document when incompatible changes were introduced, and when they will be — or were — made mandatory. This is a form of executable documentation, and can be inspected programmatically via importing future and examining its contents. Python 的每个版本或多或少会添加一些新的功能，或者修改某些现存的功能，所以在不同版本的环境中我们写的某一些代码可能会存在不兼容的现象，比如Python2.5与Python3.6等等之间的版本就存在不兼容的问题，为了解决这种问题，Python加入了future模块。方便将工程代码过渡到新的版本上。比如2.x里的字符串用’xxx’表示str，Unicode字符串用u’xxx’表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u’xxx’和’xxx’是完全一致的，而在2.x中以’xxx’表示的str就必须写成b’xxx’，以此表示“二进制字符串”。 要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。 Python提供了future模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下： 为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法： 此处借鉴廖雪峰的博客: 12345678# still running on Python 2.7from __future__ import unicode_literalsprint '\'xxx\' is unicode?', isinstance('xxx', unicode)print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)print '\'xxx\' is str?', isinstance('xxx', str)print 'b\'xxx\' is str?', isinstance(b'xxx', str) 注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的’a string’仍是一个unicode，而加上前缀b的b’a string’才变成了str： 12345$ python task.py'xxx' is unicode? Trueu'xxx' is unicode? True'xxx' is str? Falseb'xxx' is str? True 类似的情况还有除法运算。在Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”： 12&gt;&gt;&gt; 10 / 33 要做精确除法，必须把其中一个数变成浮点数： 12&gt;&gt;&gt; 10.0 / 33.3333333333333335 而在Python 3.x中，所有的除法都是精确除法，地板除用//表示： 12345678$ python3Python 3.3.2 (default, Jan 22 2014, 09:54:40) [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33 如果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过future模块的division实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152使用__future__阅读: 142513Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。有些改动是不兼容旧版本的，也就是在当前版本运行正常的代码，到下一个版本运行就可能不正常了。从Python 2.7到Python 3.x就有不兼容的一些改动，比如2.x里的字符串用'xxx'表示str，Unicode字符串用u'xxx'表示unicode，而在3.x中，所有字符串都被视为unicode，因此，写u'xxx'和'xxx'是完全一致的，而在2.x中以'xxx'表示的str就必须写成b'xxx'，以此表示“二进制字符串”。要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。Python提供了__future__模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。举例说明如下：为了适应Python 3.x的新的字符串的表示方法，在2.7版本的代码中，可以通过unicode_literals来使用Python 3.x的新的语法：# still running on Python 2.7from __future__ import unicode_literalsprint '\'xxx\' is unicode?', isinstance('xxx', unicode)print 'u\'xxx\' is unicode?', isinstance(u'xxx', unicode)print '\'xxx\' is str?', isinstance('xxx', str)print 'b\'xxx\' is str?', isinstance(b'xxx', str)注意到上面的代码仍然在Python 2.7下运行，但结果显示去掉前缀u的'a string'仍是一个unicode，而加上前缀b的b'a string'才变成了str：$ python task.py'xxx' is unicode? Trueu'xxx' is unicode? True'xxx' is str? Falseb'xxx' is str? True类似的情况还有除法运算。在Python 2.x中，对于除法有两种情况，如果是整数相除，结果仍是整数，余数会被扔掉，这种除法叫“地板除”：&gt;&gt;&gt; 10 / 33要做精确除法，必须把其中一个数变成浮点数：&gt;&gt;&gt; 10.0 / 33.3333333333333335而在Python 3.x中，所有的除法都是精确除法，地板除用//表示：$ python3Python 3.3.2 (default, Jan 22 2014, 09:54:40) [GCC 4.2.1 Compatible Apple LLVM 5.0 (clang-500.2.79)] on darwinType "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 10 // 33如果你想在Python 2.7的代码中直接使用Python 3.x的除法，可以通过__future__模块的division实现：from __future__ import divisionprint '10 / 3 =', 10 / 3print '10.0 / 3 =', 10.0 / 3print '10 // 3 =', 10 // 3 结果如下： 12310 / 3 = 3.3333333333310.0 / 3 = 3.3333333333310 // 3 = 3 由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了future模块，让你在旧的版本中试验新版本的一些特性。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Module</tag>
        <tag>__future__</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.4 Decision tree]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-4-Decision-tree%2F</url>
    <content type="text"><![CDATA[摘要决策树是在已知各种情况发生的概率的基础上，通过决策树来求取净现值的期望值大于或等于零的概率，从而评价项目风险，判断其可能性的决策分析方法，是直观的运用概率分析的一种图解方法。由于决策树画成的图像就像一棵树的树干，故称决策树。在机器学习中决策树是一种预测模型，他表示对象属性和对象之间的一种映射关系。决策树是一种判断其可行性的决策分析的方法，也是一种能够直观运用概率分析的一种图解法。 Edit By Porter, 积水成渊,蛟龙生焉。 决策树是一种树形结构，其中每个内部节点表示一个属性上的测试，每个分支代表一个测试输出，每个叶节点代表一种类别。 分类树（决策树）是一种十分常用的分类方法。他是一种监管学习，所谓监管学习就是给定一堆样本，每个样本都有一组属性和一个类别，这些类别是事先确定的，那么通过学习得到一个分类器，这个分类器能够对新出现的对象给出正确的分类。这样的机器学习就被称之为监督学习。 参考自百度百科：决策树 一、组成 决策树是一种树形的结构图，在计算机预测模型中，其中每个内部节点代表一个属性上的测试，每个分支代表一个测试输出（可能的属性值），每个叶节点代表一种类别。他由分支来对该类型的对象依靠属性进行分类。当不能在进行分割或一个单独的类可以被应用于某一分支时，递归过程就完成了。 A、先画一个方框作为出发点，又称决策节点； B、从出发点向右引出若干条直线，这些直线叫做方案枝； C、在每个方案枝的末端画一个圆圈，这个圆圈称为概率分叉点，或自然状态点； D、从自然状态点引出代表各自然状态的分枝，称为概率分枝； E、如果问题只需要一级决策，则概率分枝末端画三角形，表示终点 。 二、 决策树的作用 尽可能最大化地规避项目风险。 能够直观地通过图示的方式传达信息背后的价值。 显示出项目所有可供选择的行动方案，行动方案之间的关系，行动方案的后果以及发生的概率，甚至是每种方案的损益期望值。 具体的决策树绘制方法与很多，下面给一个国内的强大绘图软件：亿方图软件绘制决策树的方法。 三、实例理解还是纯粹的理论有点不好理解，接下来进行实例，来进一步了解决策树算法。 第一个例子是引用百科的。 3.1 案例一为了适应市场的需要，某地准备扩大电视机生产。市场预测表明：产品销路好的概率为0.7；销路差的概率为0.3。 [ ] 备选方案有三个：第一个方案是建设大工厂，需要投资600万元，可使用10年；如销路好，每年可赢利200万元；如销路不好，每年会亏损40万元。 [ ] 第二个方案是建设小工厂，需投资280万元；如销路好，每年可赢利80万元；如销路不好，每年也会赢利60万元。 [ ] 第三个方案也是先建设小工厂，但是如销路好，3年后扩建，扩建需投资400万元，可使用7年，扩建后每年会赢利190万元。 根据如上绘制决策树如下图所示： 各点期望： 点②：0.7×200×10+0.3×（-40）×10-600（投资）=680（万元） 点⑤：1.0×190×7-400=930（万元） 点⑥：1.0×80×7=560（万元） 比较决策点4的情况可以看到，由于点⑤（930万元）与点⑥（560万元）相比，点⑤的期望利润值较大，因此应采用扩建的方案，而舍弃不扩建的方案。把点⑤的930万元移到点4来，可计算出点③的期望利润值。 点③：0.7×80×3+0.7×930+0.3×60×（3+7）-280 = 719（万元） 最后比较决策点1的情况。由于点③（719万元）与点②（680万元）相比，点③的期望利润值较大，因此取点③而舍点②。这样，相比之下，建设大工厂的方案不是最优方案，合理的策略应采用前3年建小工厂，如销路好，后7年进行扩建的方案。 3.2 实例学习2假设有一项工程，施工管理人员需要决定下月是否开工。如果开工后天气好，则可为国家创收4万元，若开工后天气坏，将给国家造成损失1万元，不开工则损失1000元。根据过去的统计资料，下月天气好的概率是0.3,天气坏的概率是0.7。请做出决策。现采用决策树方法进行决策。 解： 第一步：将题意表格化 自然状态 概率 行动方案 行动方案 开工 不开工 天气好 0.3 40000 -1000 天气坏 0.7 -10000 -1000 第二步：画决策树形，根据第一步所列的表格，在绘制决策树，如下图： 第三步：计算期望值 一般按反向的时间程序逐步计算，将各方案的几种可能结果的数值和它们各自的概率相乘，并汇总所得之和，其和就是该方案的期望值。 第四步：确定决策方案 在比较方案考虑的是收益值时，则取最大期望值；若考虑的是损失时，则取最小期望值。根据计算出的期望值分析，本题采取开工方案较好。 更多的可以参考这个PPT]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>决策树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5 梯度下降和最小二乘法]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-5-%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E5%92%8C%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要本节笔记主要记录梯度下降算法和最小二乘法的相同点和不同点，为了简单的理解和推导，我们暂只讨论一元线性回归下的梯度下降算法和最小二乘。从实现++代码上的最大不同就是梯度下降采用了迭代算法—预先给一个参数设置初始值，然后通过迭代和学习率实现线性方程直线的无限靠近理想函数。最小二乘采用了高中数学求凸函数（下凹）的最小值—即求导数为零的参数方程。 Edit By Porter, 积水成渊,蛟龙生焉。 梯度下降和最小二乘发的相同点和不同点如下： 狭义的最小二乘法：指的是在线性回归下采用最小二乘准则（或者说叫做最小平方），进行线性拟合参数求解的、矩阵形式的公式方法，是线性假设下的一种有闭式解的参数求解方法，最终结果为全局最优； 广义的最小二乘法：是最小二乘准则，本质上是一种evaluation rule或者说objective funcion。是一种对于偏差程度的评估准则。 梯度下降法，是假设条件更为广泛（无约束）的，一种通过迭代更新来逐步进行的参数优化方法，最终结果为局部最优； 最小二乘与极大似然的区别 二乘法：即观测值与实际数据误差平方和最小，其没有假设，几何意义上就是距离最小 最大似然估计：估计参数可能值，使样本发生概率最大 对于回归问题，两者对于最优参数的不同解法假设一元回归方程为 $$f(x_i)=\omega x_i +b$$ 实际中我们会采样得到关于[x,y]的很多样本，此时我们会通过损失函数loss，来求最优$\omega , b$的最优解。 $$loss = (\omega x + b -y)^2$$ 假设$E_(\omega, b)=loss_(\omega, b)$,于是： 为求得最优的$\omega ， b$,即求解$E_(\omega, b)=\sum_{m}^{i=1} (y_i - \omega x_i -b)^2$的最小取值下的$\omega ， b$最优解。 注意此时的$E_(\omega, b)$是一个凸函数，注意也就是对应国内教材下凹函数曲线。 最小二乘法的求解最优的$\omega ， b$的方法直接通过对$E_(\omega, b)$对$\omega ， b$分别求偏导，并将偏导设为0，求取凸函数取得最小值下的对应$\omega ， b$参数。 最小二乘法的局限性和适用场景 从上面可以看出，最小二乘法适用简洁高效，比梯度下降这样的迭代法似乎方便很多。但是这里我们就聊聊最小二乘法的局限性。 首先，最小二乘法需要计算的逆矩阵，有可能它的逆矩阵不存在，这样就没有办法直接用最小二乘法了，此时梯度下降法仍然可以使用。当然，我们可以通过对样本数据进行整理，去掉冗余特征。让的行列式不为0，然后继续使用最小二乘法。 第二，当样本特征n非常的大的时候，计算的逆矩阵是一个非常耗时的工作（nxn的矩阵求逆），甚至不可行。此时以梯度下降为代表的迭代法仍然可以使用。那这个n到底多大就不适合最小二乘法呢？如果你没有很多的分布式大数据计算资源，建议超过10000个特征就用迭代法吧。或者通过主成分分析降低特征的维度后再用最小二乘法。 第三，如果拟合函数不是线性的，这时无法使用最小二乘法，需要通过一些技巧转化为线性才能使用，此时梯度下降仍然可以用。 第四，讲一些特殊情况。当样本量m很少，小于特征数n的时候，这时拟合方程是欠定的，常用的优化方法都无法去拟合数据。当样本量m等于特征说n的时候，用方程组求解就可以了。当m大于n时，拟合方程是超定的，也就是我们常用与最小二乘法的场景了。 原文地址：http://www.cnblogs.com/pinard/p/5976811.html 梯度下降算法的求解最优的$\omega ， b$的方法同样，梯度下降算法也是要求最小损失函数 $$loss = (\omega x + b -y)^2$$ 但是方法不一样了，梯度下降算法，在上面的基础上设定一个学习率的参数，假设为:$lr$ 对于待求解的参数$\omega ， b$则转化为 –&gt; 求最终待求的$\omega ‘ ， b’$关于前一时刻的$\omega ， b$的函数，如下 $$\omega ‘=\omega - lr * \frac{\bigtriangledown loss}{\bigtriangledown \omega}$$ 同理： $$b ‘=b - lr * \frac{\bigtriangledown loss}{\bigtriangledown b}$$ 根据上面的式子，假设学习率lr的初始值为0，然后通过for循环进行迭代，此时求解的关于$\omega ， b$的曲线会随着迭代的次数增加，一步步无限的靠近最优的解，理论上会求解到最优的$\omega ， b$。 针对上面的一元回归梯度下降算法的代码实现，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import numpy as np# y = wx + bdef compute_error_for_line_given_points(b, w, points): totalError = 0 for i in range(0, len(points)): x = points[i, 0] y = points[i, 1] totalError += (y - (w * x + b)) ** 2 return totalError / float(len(points))def step_gradient(b_current, w_current, points, learningRate): b_gradient = 0 w_gradient = 0 N = float(len(points)) for i in range(0, len(points)): x = points[i, 0] y = points[i, 1] b_gradient += -(2/N) * (y - ((w_current * x) + b_current)) w_gradient += -(2/N) * x * (y - ((w_current * x) + b_current)) new_b = b_current - (learningRate * b_gradient) new_m = w_current - (learningRate * w_gradient) return [new_b, new_m]def gradient_descent_runner(points, starting_b, starting_m, learning_rate, num_iterations): b = starting_b m = starting_m for i in range(num_iterations): b, m = step_gradient(b, m, np.array(points), learning_rate) return [b, m]def run(): points = np.genfromtxt("data.csv", delimiter=",") learning_rate = 0.0001 initial_b = 0 # initial y-intercept guess initial_m = 0 # initial slope guess num_iterations = 1000 print("Starting gradient descent at b = &#123;0&#125;, m = &#123;1&#125;, error = &#123;2&#125;" .format(initial_b, initial_m, compute_error_for_line_given_points(initial_b, initial_m, points)) ) print("Running...") [b, m] = gradient_descent_runner(points, initial_b, initial_m, learning_rate, num_iterations) print("After &#123;0&#125; iterations b = &#123;1&#125;, m = &#123;2&#125;, error = &#123;3&#125;". format(num_iterations, b, m, compute_error_for_line_given_points(b, m, points)) )if __name__ == '__main__': run() 对应的数据集如下(data.csv)： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910032.502345269453031,31.7070058465699253.426804033275019,68.7775959816389161.530358025636438,62.56238229794580347.475639634786098,71.54663223356777759.813207869512318,87.23092513368739355.142188413943821,78.21151827079923252.211796692214001,79.6419730498087439.299566694317065,59.17148932186950848.10504169176825,75.33124229706305652.550014442733818,71.30087988685035345.419730144973755,55.16567714595912354.351634881228918,82.47884675749791944.164049496773352,62.00892324572582558.16847071685779,75.39287042599495756.727208057096611,81.4361921588786448.955888566093719,60.72360244067396544.687196231480904,82.89250373145371560.297326851333466,97.37989686216607845.618643772955828,48.84715331735507238.816817537445637,56.87721318626850666.189816606752601,83.87856466460276365.41605174513407,118.5912173025224947.48120860786787,57.25181946226896941.57564261748702,51.39174407983230751.84518690563943,75.38065166531235759.370822011089523,74.76556403215137457.31000343834809,95.45505292257473763.615561251453308,95.22936601755530746.737619407976972,79.05240616956558650.556760148547767,83.43207142132371252.223996085553047,63.35879031749787835.567830047746632,41.41288530370056342.436476944055642,76.61734128007404458.16454011019286,96.76956642610819957.504447615341789,74.08413011660252345.440530725319981,66.58814441422859461.89622268029126,77.76848241779302433.093831736163963,50.71958891231208436.436009511386871,62.12457081807178137.675654860850742,60.81024664990221144.555608383275356,52.68298336638778143.318282631865721,58.56982471769286750.073145632289034,82.90598148507051243.870612645218372,61.42470980433912362.997480747553091,115.2441528007952932.669043763467187,45.57058882337608540.166899008703702,54.08405479622361253.575077531673656,87.99445275811041333.864214971778239,52.72549437590042564.707138666121296,93.57611869265824138.119824026822805,80.16627544737096444.502538064645101,65.10171157056032640.599538384552318,65.56230126040037541.720676356341293,65.28088692082282351.088634678336796,73.43464154632430155.078095904923202,71.1397278586189441.377726534895203,79.10282968354985762.494697427269791,86.52053844034715349.203887540826003,84.74269780782621841.102685187349664,59.35885024862493341.182016105169822,61.68403752483362750.186389494880601,69.84760415824918352.378446219236217,86.09829120577410350.135485486286122,59.10883926769964333.644706006191782,69.8996816436276339.557901222906828,44.86249071116439856.130388816875467,85.49806777884022357.362052133238237,95.53668684646721960.269214393997906,70.25193441977158735.678093889410732,52.72173496477498831.588116998132829,50.39267013507989653.66093226167304,63.64239877565775346.682228649471917,72.24725106866236543.107820219102464,57.81251297618140270.34607561504933,104.2571015854382244.492855880854073,86.64202031882200657.50453330326841,91.48677800011013536.930076609191808,55.23166088621283655.805733357942742,79.55043667850760938.954769073377065,44.84712424246760156.901214702247074,80.20752313968276356.868900661384046,83.1427497920434634.33312470421609,55.72348926054391459.04974121466681,77.63418251167786457.788223993230673,99.05141484174826954.282328705967409,79.12064627468002751.088719898979143,69.58889785111847550.282836348230731,69.51050331149438944.211741752090113,73.68756431831728538.005488008060688,61.36690453724013132.940479942618296,67.17065576899511853.691639571070056,85.66820314500154268.76573426962166,114.8538712339139446.230966498310252,90.12357206996742368.319360818255362,97.91982103524284850.030174340312143,81.53699078301502849.239765342753763,72.11183246961566350.039575939875988,85.23200734232567348.149858891028863,66.22495788805463225.128484647772304,53.454394214850524 总结以上就是关于简单的一元回归的关于梯度下降和最小二乘的区别，对于代码中，的迭代的实现下一小节中会有详细的介绍，会通过代码来直观例说迭代算法和递归算法的差异和原理。 无聊时刻看部综艺：]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>梯度下降和最小二乘法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.10 hexo网页定制]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-10-hexo%E7%BD%91%E9%A1%B5%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.10 hexo网页定制，要知道原作官方提供的hexo yeele网站的手机页面和电脑页面css布局和java页面交互的文本进行个性定制。第一部分，设置手机页面的 mobile-slider.styl 等文件， 里面的css文件。 第二部分是java交互界面的文件设置。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 一、样式定制之css样式文件定制 使用之前删掉里面的注释1.1 mobile-slider.styl 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#viewer&#123; position: fixed; z-index: 1000000; top: 0; bottom: 0; left: 0; right: 0; overflow: hidden;&#125;//mune bar setting#viewer-box&#123; display: flex; width: 100%; height: 100%; position: relative;//设置浮窗的左边距 left:30px; color: #0f0; -webkit-transform: translate3d(-100%, 0, 0 ); -webkit-transition: -webkit-transform .25s ease-in-out;//设置悬浮的弹窗页面 .viewer-box-l&#123; background: rgba(20,20,20,1); width: 80%; height: auto; flex-grow: 0; min-width: 8em; max-width: 23em; .viewer-box-wrap&#123; //revise the moble menu margin: 20px 10px 10px 0px; &#125; //frends links menu .viewer-title&#123; line-height: 32px; //black background: rgba(0,0,0,1); &amp;:before&#123; content: ""; width: 6px; height: 6px; //border: 1px solid #999; border: 1px solid #006699; -webkit-border-radius: 10px; border-radius: 10px; //background is tabar of list content background: #0000cc; display: inline-block; margin-right: 10px; &#125; &#125; //div Underline, dash .viewer-div&#123; //setting div 黄色背景幕布 background: rgba(255,255,153,0.85); //蓝色圆点 border-bottom: 1px dotted #0000cc; padding-bottom: 13px; line-height: 20px; &amp;:last-child&#123; //设置标签背景白色透明，不继承上面的白色 border-bottom: none; background: rgba(229,229,255,0.01); &#125; .switch-friends-link&#123; line-height: 20px; &#125; &#125; &#125; //black .viewer-box-r&#123; flex-grow: 1 width: auto height: auto background: rgba(0,0,0,1) &amp;:hover &#123; cursor: w-resize &#125; &#125;&#125;#viewer-box.anm-swipe&#123; -webkit-transform: translate3d(0, 0, 0); .viewer-box-r&#123; background: rgba(0,0,0,1); &#125;&#125;.hide&#123; display: none;&#125;#viewer-box .viewer-list&#123; margin: 0; padding: 0; height: 100%; overflow: hidden;&#125; 1.1 mobile.styl123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325.left-col &#123; display: none;&#125;.mid-col &#123; left: 0;&#125;#header&#123; .header-nav&#123; position: relative; &#125; .header-menu &#123; line-height: 1.3 min-height 3rem &#125;&#125;.header-author&#123; &amp;.fixed&#123; position: fixed; top: -8px; width: 100%; color: #ddd; a &#123; color: white; &#125; &#125;&#125;.overlay&#123; .slider-trigger&#123; position: absolute;/*设置手机页面滑动图标置于最上层显示*/ z-index: 999; bottom: 0; left: 0; width: 42px; height: 42px; &amp;:hover&#123; background: #3399; /*background: #444;*/ &#125; &amp;:before&#123; /*background: #ff3399;*/ color: #ddd; content: "\f00b"; font: 16px FontAwesome; width: 16px; height: 16px; margin-left: 9px; margin-top: 14px; display: block; &#125; &#125;&#125;.article-header&#123; border-left: none; padding: 0; border-bottom: 1px dotted #ddd; h1&#123; margin-bottom: 2px; &#125;&#125;#header .header-subtitle&#123; padding: 0 3em; font-size: 1em;&#125;.article-info-index.article-info&#123; padding-top: 10px; margin: 0; border-top: 1px solid #ddd;&#125;.article-info-post.article-info&#123; margin: 0; padding-top: 10px; border: none;&#125;#viewer-box .viewer-box-l&#123; font-size: 14px;&#125;.article&#123; margin: (10/16)rem 10px; .article-entry&#123; padding-left: 0; padding-right: 0; .highlight &#123; padding .35em .6em &#125; &#125; .article-title&#123; display: block; margin: 0; font-size 1.5rem font-weight bold &#125; .article-meta&#123; display: none; &#125;&#125;.article-inner &#123; padding: 12px;&#125;.archive-article-inner .article-meta &#123; top: 0; margin-top: .5em;&#125;.archives &#123; .archive-article &#123; padding: 0; &#125; .archive-article-date &#123; margin-right: 0; &#125; .article-info &#123; display: none; &#125;&#125;.archive-article-inner .article-meta .archive-article-date.share&#123; padding: 3px 10px;&#125;.duoshuo &#123; padding: 0 13px;&#125;#disqus_thread &#123; padding: 0 13px;&#125;#mobile-nav&#123; display: block;&#125;#page-nav .extend&#123; opacity: 1;&#125;#page-nav &#123; margin-top: 1em; .page-number &#123; margin-bottom: 1.5em; &#125;&#125;.instagram .open-ins&#123; left: 2px; top: -30px; color: #aaa;&#125;.info-on-right&#123; float: initial;&#125;.archives-wrap&#123; margin: 10px 10px 0px; padding: 10px; padding-right: 0; .archive-year-wrap&#123; position: relative; padding: 0 0 0 0; a&#123; padding: 0 0 0 0; &#125; &#125; h1 &#123; font-size: 1.2em; margin-bottom: .3em; &#125;&#125;.archives&#123; .archive-article&#123; padding: 10px 0; margin-left: 0; &#125;&#125;#footer &#123; .footer-left&#123; float: initial; margin-bottom: .5em; &#125; .footer-right&#123; float: initial; margin-bottom: 1em; &#125; .visit &#123; margin: 0; &#125;&#125;.article-category::before&#123; display: none;&#125;.article-tag::before &#123; display: none;&#125;.article-meta time:before &#123; display: none;&#125;.visit &#123; margin-top: 1em;&#125;#tocButton &#123; z-index: 100; position: fixed; left: .5em; top: auto; /*In order to cover style in article.styl*/ bottom: 10px; padding: .2em .4em; border-radius: 6px; border-style : outset; background: rgba(255, 255, 255, .7); font-size: 1em; font-weight: bold; color: gray; &amp;:hover &#123; color: #88acdb; font-size: 1em; &#125;&#125;.toc-article &#123; display: none; z-index: 99 left: 0; top: 38%; bottom: 1em; height: auto; max-height: 58%; width: none; width: auto; min-width: 7em; max-width: 61.8%; overflow: auto; margin-left: 0; padding: 10px; padding-left: 0; border-radius: 2.8%; background: none; font-size: 1em; line-height: 1.25em; .toc-title &#123; display: none; padding: .3em; color: white; background: lightgray; border-radius 3px &#125; .toc &#123; padding: 0.5em; &#125; ol &#123; margin: 0; padding: 0.5em; border-radius: 5px; background: rgba(255, 255, 255, .85); ol &#123; padding: 0.1em 0; padding-left: 1.2em; &#125; &#125; a &#123; color: #767676; &#125;&#125;if toc-nowrap li.toc-item line-height: 1.2.copyright &#123; width: 90%; padding: .5em .8em;&#125;.scroll &#123; right: 1.2em; li &#123; font-size: 1.7em; &#125;&#125;.hide-labels &#123; z-index: 100; position: fixed; left: .5em; top: auto; bottom: 10px; padding: .2em .4em; border-radius: 6px; border-style : outset; opacity: .9; background: rgba(255, 255, 255, .8); font-weight: bold; color: gray;&#125;#post-nav-button &#123; display: none;&#125;.post-list &#123; visibility: hidden;&#125;/*多说 UA*/.ua &#123; display: none !important;&#125;if hexo-config("github_widget") .github-text display none.copyright font-size 16px .copy-path display none// Tags Cloud Page.tags a line-height 45px]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>java</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.9 hexo 实现本地图片加载]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-9-hexo-%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.9 hexo 实现本地图片加载，要知道原作官方提供的hexo-asset-image，根本不能满足自己的需要，所以这里是基于原作的代码进行修改实现，原作并未其提供的代码做出解释说明，本文将对更改后能实现本地图片加载的代码进行解释，并有针对性的对后来遇到问题的，或者可以给你们提供二次修改说明的解释并提醒。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook hexo-asset-image,这是原作者提供的代码，有一个特别致命的问题，是每次hexo g,后，需要手动将图片一张张对应复制到public文件夹中对应你的博文对应生成的文件夹的路径下才可以实现，本地图片显示。那么问题来了，我如果写了很多博文，需要每次复制如此多的图片到不同博文对应生成的文件夹中去。太麻烦了 若，我是写的书的格式，分章分节，一章我有10几节，那一个文件一个文件复制太麻烦了。 一、要解决的问题 我们要解决既要加载本地图库在我们的站点显示 又不想一个博文一个博文区分开了分别拷贝对应图片到public文件夹中 假设：如果我们能够把每章节的很多文章的不同图片放到该章节的图库文件夹中，这样每章就一个图库文件，我们把图库（image1文件夹）直接复制到（source文件夹下），然后直接hexo clean &amp;&amp; hexo g 就可以，这样不用手动添加文件到问文件夹中。 二、操作2.1 下载原作者的文件，然后修改原文件代码 安装原作者的hexo-asset-image 1npm install hexo-asset-image --save 2,2 原始作者的代码如下（还未经过博主修改前的代码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2.3 修改原作代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string//获取对应链接的'/'分开的某部分function getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; //调用上面的函数，取link链接的第三个'/'位置的数组下标值，做下面取链接的首地址区间。 var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". //取link链接的最后一个'/'，做下面取链接的尾地址区间。 var endPos = link.lastIndexOf('/') + 1; //取link连接中我们认为有用的地址部分。 link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); //取图片的名字，比如 x.png var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); //$(this).attr('src', config.root + link + src); //notes: src is image name,and config.root is localhost:port,the middle cahr string is my local image Repository //这我们做判断，判断原始link链接的前3个字是不是“第一章”,如果是，我们将link地址写成'image1'，（image1是我们存放第一章所有图片的图库文件夹） if(link.substring(0,3)=="第一章")&#123; //第一章的所有图片放到这个文件夹下 link="image1/"; console.info&amp;&amp;console.info("judement the fist capture!"); &#125; //这我们做判断，判断原始link链接的前3个字是不是“第二章”,如果是，我们将link地址写成'image2'，（image2是我们存放第二章所有图片的图库文件夹） else if(link.substring(0,3)=="第二章")&#123; link="image2/"; console.info&amp;&amp;console.info("judement the second capture!"); &#125; else if(link.substring(0,3)=="第三章")&#123; link="image3/"; console.info&amp;&amp;console.info("judement the third capture!"); &#125; else if(link.substring(0,3)=="第四章")&#123; link="image4/"; console.info&amp;&amp;console.info("judement the fourth capture!"); &#125; else if(link.substring(0,3)=="第五章")&#123; link="image5/"; console.info&amp;&amp;console.info("judement the fifth capture!"); &#125; else if(link.substring(0,3)=="第六章")&#123; link="image6/"; console.info&amp;&amp;console.info("judement the sixth capture!"); &#125; else if(link.substring(0,3)=="第七章")&#123; link="image7/"; console.info&amp;&amp;console.info("judement the seventh capture!"); &#125; //$(this).attr('src', config.root + "image1/" + src); //这里我们做字符串的拼接，将最终输出的图片链接地址改为：config.root + link + src //其中config.root 是'/'表示根目录。link使我们的图库相对根目录的位置。src是图片的名字: x.png或其他格式图片 $(this).attr('src', config.root + link + src); //终端上打印调试信息，供自己调试，是否每个图片输出地址是正确的。 console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + "==" + link + "==" + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2.3 修改你站点文件根目录的_config.yml文件的配置信息找到如下条，将默认的false改为true,注意_config.yml不是你的主题文件家中的文件 1post_asset_folder: true # local image to url,revise true 2.4 我的博文目录格式如下图片所示： 2.5 将你的的博文直接放到你站点根目录下的：source-&gt;_post文件夹下，如下图 2.6 将你的所有章节的图库文件夹直接放到source文件夹中即可如图： 三、Hexo手机页面优化文件路径 1站点根目录/themes/yelee/source/css/_partial/mobile-slider.styl 修改mobile-slider.styl文件内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#viewer&#123; position: fixed; z-index: 1000000; top: 0; bottom: 0; left: 0; right: 0; overflow: hidden;&#125;#viewer-box&#123; display: flex; width: 100%; height: 100%; position: relative; color: #ccc; -webkit-transform: translate3d(-100%, 0, 0 ); -webkit-transition: -webkit-transform .25s ease-in-out; .viewer-box-l&#123; background: rgba(20,20,20,1); width: 80%; height: auto; flex-grow: 0; min-width: 8em; max-width: 23em; .viewer-box-wrap&#123; //revise the moble menu margin: 20px 10px 0px 60px; &#125; .viewer-title&#123; line-height: 32px; &amp;:before&#123; content: ""; width: 6px; height: 6px; border: 1px solid #999; -webkit-border-radius: 10px; border-radius: 10px; background: #0000cc; display: inline-block; margin-right: 10px; &#125; &#125; .viewer-div&#123; border-bottom: 1px dotted #666; padding-bottom: 13px; line-height: 20px; &amp;:last-child&#123; border-bottom: none; &#125; .switch-friends-link&#123; line-height: 20px; &#125; &#125; &#125; .viewer-box-r&#123; flex-grow: 1 width: auto height: auto background: rgba(0,0,0,0) &amp;:hover &#123; cursor: w-resize &#125; &#125;&#125;#viewer-box.anm-swipe&#123; -webkit-transform: translate3d(0, 0, 0); .viewer-box-r&#123; background: rgba(0,0,0,0); &#125;&#125;.hide&#123; display: none;&#125;#viewer-box .viewer-list&#123; margin: 0; padding: 0; height: 100%; overflow: hidden;&#125;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>java</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.12 logistic regression]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-12-logistic-regression%2F</url>
    <content type="text"><![CDATA[摘要 Edit By Porter, 积水成渊,蛟龙生焉。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>logistic regression</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS室内仿真环境]]></title>
    <url>%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-ROS%E6%9C%BA%E5%99%A8%E4%BA%BA-ROS%E5%AE%A4%E5%86%85%E4%BB%BF%E7%9C%9F%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[摘要本节笔记主要记录ROS室内仿真环景的具体演示过程和 Edit By Porter, 积水成渊,蛟龙生焉。 《机器人操作系统入门》课程代码示例 前言欢迎来到中国大学MOOC—《机器人操作系统入门》课程，本ROS软件包是课程的代码示例，课程中使用的例子均出自本代码包。除了代码包，课程还提供讲义，欢迎各位朋友下载、学习和分享。 本示例包含了XBot机器人和中科院软件博物馆仿真、ROS通信示例程序、导航与SLAM功能演示，在每个软件包下都有相应的功能介绍。 如果你遇到任何问题，可以在Github上方的issues栏目中提问，我们课程团队会耐心回答。本示例将长期维护，不断更新，如果你认可我们的工作，请点击右上角的star按钮，您的鼓励是我们的动力。 示例介绍本仓库为ROS入门教程的代码示例，包括以下ROS软件包: 软件包 内容 robot_sim_demo 机器人仿真程序，大部分示例会用到这个软件包 topic_demo topic通信，自定义msg，包括C++和python两个版本实现 service_demo service通信，自定义srv，分别以C++和python两种语言实现 action_demo action通信，自定义action，C++和python两种语言实现 param_demo param操作，分别以C++和python两种语言实现 msgs_demo 演示msg、srv、action文件的格式规范 tf_demo tf相关API操作演示，tf示例包括C++和python两个版本 tf_follower 制作mybot机器人 实现mybot跟随xbot的功能 urdf_demo 创建机器人urdf模型，在RViz中显示 navigation_sim_demo 导航演示工具包，包括AMCL, Odometry Navigation等演示 slam_sim_demo 同步定位与建图演示，包括Gmapping, Karto, Hector等SLAM演示 robot_orbslam2_demo ORB_SLAM2的演示 ros_academy_for_beginners Metapacakge示例，依赖了本仓库所有的pacakge 下载和编译 克隆或下载ROS-Academy-for-Beginners教学包到工作空间的/src目录下，例如 ~/catkin_ws/src 12$ cd ~/catkin_ws/src$ git clone https://github.com/DroidAITech/ROS-Academy-for-Beginners.git 安装教学包所需的依赖 12$ cd ~/catkin_ws$ rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y 如果安装失败,出现如下的错误信息： 1234ERROR: the following packages/stacks could not have their rosdep keys resolved to system dependencies:slam_sim_demo: No definition of [hector_mapping] for OS [debian]navigation_sim_demo: No definition of [dwa_local_planner] for OS [debian]robot_sim_demo: No definition of [yocs_cmd_vel_mux] for OS [debian] 可以执行如下的命令(在ubuntu16下对应-xenial) 1rosdep install --from-paths src --ignore-src --rosdistro=$&#123;ROS_DISTRO&#125; -y --os=ubuntu:xenial 编译并刷新环境 12$ catkin_make$ source ~/catkin_ws/devel/setup.bash 运行示例 运行须知 建议在本地Ubuntu 16.04下运行仿真程序。目前Gazebo模拟器的兼容性是一大问题，在虚拟机或配置较低的电脑上可能无法运行。如果你的显卡是N卡，建议安装Ubuntu下的显卡驱动。 运行Gazebo仿真程序robot_sim_demo前，请将Gazebo升级到7.x版本以上（推荐7.9版本）。 查看Gazebo版本方法 1$ gazebo -v #确认7.0以上，推荐7.9 升级方法 1234$ sudo sh -c 'echo "deb http://packages.osrfoundation.org/gazebo/ubuntu-stable `lsb_release -cs` main" &gt; /etc/apt/sources.list.d/gazebo-stable.list'$ wget http://packages.osrfoundation.org/gazebo.key -O - | sudo apt-key add -$ sudo apt-get update$ sudo apt-get install gazebo7 确保所有依赖都已安装，如gazebo_ros, gmapping, slam_karto, amcl。 Copyright 项目运行ROS 场景搭建 前言目前这个项目是借鉴的XBot机器人和中科院软件博物馆仿真，在此做操作备注 运行指令如下1. 编译并刷新环境123$ cd to/catkin_ws/$ catkin_make$ source ./devel/setup.bash #source devel/setup.bash 2.执行打开指令123porter@porter-Aspire:~/ROS_Project/catkin_ws$ source ./devel/setup.bashporter@porter-Aspire:~/ROS_Project/catkin_ws$ rospack profileporter@porter-Aspire:~/ROS_Project/catkin_ws$ roslaunch robot_sim_demo robot_spawn.launch 3.等待启动将会花费数秒时间，然后才会出现效果 4.运行12porter@porter-Aspire:~/ROS_Project/catkin_ws$ source devel/setup.bashporter@porter-Aspire:~/ROS_Project/catkin_ws$ rosrun robot_sim_demo robot_keyboard_teleop.py 注意每次运行rosrun 都source一下。 聚焦控制程序窗口，按下i、j、l等按键，这样你就可以通过键盘来控制机器人的移动了。javascript:void(0);]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.11 极大似然估计]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-11-%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[摘要极大似然估计, 摘要 原理： 举个例子 贝叶斯的参数估计 先验概率的极大似然估计 条件概率极大似然估计 参考 原理： 极大似然估计是建立在极大似然原理的基础上的一个统计方法，是概率论在统计学中的应用。 极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。 通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。 [x] Edit By Porter, 积水成渊,蛟龙生焉。 举个例子由于样本集中的样本都是独立同分布，可以只考虑一类样本集D，来估计参数向量θ。记已知的样本集为： $$D={x_{1}, x_{2},…, x_{N}}$$ 似然函数（linkehood function）：联合概率密度函数$P(D|\theta )$称为相对于$${x_{1}, x_{2},…, x_{N}}$$的$\theta$的似然函数。 $$l(\theta)=P(D|\theta)=P(x_{1}, x_{2},…,x_{N}|\theta)=\prod {i=1}^{N}P(x{i}|\theta)$$ 如果 $\hat{\theta}$是参数空间中能使似然函数$l(\theta)$最大的θ值，$\hat{\theta}$则应该是“最可能”的参数值，那么 $\hat{\theta}$ 就是θ的极大似然估计量。它是样本集的函数，记作： $$\hat{\theta}=d(x_{1},x_{2},…,xx_{N})=d(D)$$ $$\theta(x_{1},x_{2},…,xx_{N})$$,称为极大似然估计值 贝叶斯的参数估计先验概率的极大似然估计$$P(Y=c_{k})=\frac{\sum_{N}^{i=1}I(y_{i}=c_{k})}{N},k=1,2,…,K$$ I 为指示函数，上式的分子，表示$y_{i}=c_{k}$时的统计次数，分母表示一共有多少个样本。 条件概率极大似然估计$$P(X^{j}=a_{jl}|Y=c_{k})=\frac{\sum_{i=1}^{N}I(x_{i}^{j}=a_{jl},y_{i}=c_{k})}{\sum_{i=1}^{N}I(y_{i}=c_{k})}, j=1,2,…,n;l=1,2,..,S_{j};k=1,2,…,K$$ 参考参考文献1：鹏大大大-CSDN参考文档来源2:李航-极大似然估计]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>最大似然估计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[朴素贝叶斯法]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-10-%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要朴素贝叶斯方法是基于贝叶斯定理与条件假设的分类方法 [1] 特征条件独立假设，求输入/出的联合概率分布d [2] 利用贝叶斯定理求出最大后验概率 [x] Edit By Porter, 积水成渊,蛟龙生焉。 贝叶斯公式$$p(c|x)= \frac{p(x|c)P(c)}{P(x)}$$ 朴素贝叶斯基本方法(X,Y 独立同分布)训练数据集T: $$T={(x_{1},y_{1}),(x_{2},y_{2}),…,(x_{N},y_{N}),} $$ 由$$P(x,y)$$独立同分布产生. $$P(Y=c_{k}|X=x)=\frac{P(X=x|Y=c_{k})P(Y=c_{k})}{\sum_{k}^{}P(X=x|Y=c_{k})P(Y=c_{k}) }$$ 公式概念 联合概率分布 $$P(X,Y)$$ 是独立同分布产生的联合概率分布。 先验概率分布 $$P(Y=c_{k}),k=1,2,3,…,k$$ 条件概率分布 $$P(X=x|Y=c_{k}) = P(X^{1}=x^{1},X^{2}=x^{2},…X^{N}=x^{N}|Y=c_{k}) , k=1,2,3,…,k$$ 后验概率分布 $$P(Y=c_{k}|X=x)$$ 朴素贝叶斯的表达式由于朴素二字的前提是独立特征分布概率，所以条件独立假设为(条件概率)为： $$P(X=x|Y=c_{k})=P(X^{1}=x^{1},X^{2}=x^{2},…,X^{n}=x^{n}|Y=c_{k})$$$$=\prod {j=1}^{n}P(X^{j}=x^{j}|Y=c{k})$$ 朴素贝叶斯实际上是学习到生成数据的机制，所以属于生成学习模型 朴素贝叶斯分类器于是朴素贝叶斯分类器可表示为: $$y=f(x)=arg\;max_{c_{k}}\frac{P(Y=c_{k})\prod_{j} P(X^{j}=x^{j}|y=c_{k})}{\sum_{k}^{}P(Y=c_{k})\prod_{j}P(X^{j}=x^{j}|Y=c_{k}) }$$ 由于上式分母对$$c_{k}$$，都是相同的，所以分类器的输出y又可以是： $$y=f(x)=arg\;max_{c_{k}}P(Y=c_{k})\prod_{j} P(X^{j}=x^{j}|y=c_{k})$$ 贝叶斯估计条件概率贝叶斯估计$$P(X^{j}=a_{jl}|Y=c_{k})=\frac{\sum_{i=1}^{N}I(x_{i}^{j}=a_{jl},y_{i}=c_{k})+\lambda }{\sum_{i=1}^{N}I(y_{i}=c_{k})+S_{j}\lambda }, j=1,2,…,n;l=1,2,..,S_{j};k=1,2,…,K$$ 先验概率的贝叶斯估计$$P(Y=c_{k})=\frac{\sum_{N}^{i=1}I(y_{i}=c_{k})+lambda }{N+k\lambda },k=1,2,…,K$$ 参考参考文档来源2:李航-朴素贝叶斯]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>Bayes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K近邻算法]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-9-K%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要K近邻算法(K-nearest neighbor, k-NN)是一种基本的分类与回归的方法。 k近邻算法： 输入：训练数据集 $$T={(x_{1},y_{1}), (x_{2},y_{2})…, (x_{N},y_{N})}$$ 其中 $$x_{i}\epsilon \chi \subseteq R^{n}$$ 为实例的特征向量 $$y_{i} \epsilon Y={c_{1}, c_{2}……, c_{K}, }$$ 为实例的类别,i=1,2,…,N 输出：给定实例x，要能输出新给的特征向量所属y中的类 (1). 根据给定的距离度量，在训练集T中找出与x最邻近的k个点，涵盖这k个点的x的邻域基座 $$N_{k} (x)$$ ; (2). 在 $$N_{k} (x)$$ 中根据分类决策规则（如多数表决表，对$$N_{k} (x)$$ 进行排序，然后取出现频率最高的第k个点的类）决定x的类别y： $$y=arg\, \max_{c_{j}}^{\ } \sum_{x_{i}\subseteq N_{k}(x)}^{\ } I(y_{i}=c_{j})$$ 其中I为指示函数，为$$y_{i}=c_{j}$$情况下, I = 1 否则I = 0 Edit By Porter, 积水成渊,蛟龙生焉。 更通俗的理解可以为如下： KNN是通过测量不同特征值之间的距离进行分类 它的思路是： 如果选择一个待分类的样本，其在特征空间中有k个最相似的样本值（即特征空间中和这个待分类的点为最邻近点集）。 这k个样本集中的绝大多数属于某一类别，则该待分类的样本也属于这个绝大多数的同一类别。 其中K通常是不大于20的整数。 KNN算法中，所选择的邻居都是已经正确分类的对象。该方法在定类决策上只依据最邻近的一个或者几个样本的类别来决定待分样本所属的类别。 例子下面通过一个简单的例子说明一下：如下图，绿色圆要被决定赋予哪个类，是红色三角形还是蓝色四方形？如下图所示 如果K=3，最小的圆, 由于红色三角形所占比例为2/3，绿色圆将被赋予红色三角形那个类。 如果K=5，虚线内，由于蓝色四方形比例为3/5，因此绿色圆被赋予蓝色四方形类。 由此也说明了KNN算法的结果很大程度取决于K的选择。 在KNN中，通过计算对象间距离来作为各个对象之间的非相似性指标，避免了对象之间的匹配问题，在这里距离一般使用欧氏距离或曼哈顿距离： 欧氏距离：$$d(x,y)=\sqrt{\sum_{k=1}^{n}(x_{k}-y_{k})^{2}}$$ 曼哈顿距离：$$d(x,y)=\sqrt{\sum_{k=1}^{n}|x_{k}-y_{k}|}$$ 同时，KNN通过依据k个对象中占优的类别进行决策，而不是单一的对象类别决策。这两点就是KNN算法的优势。 接下来对KNN算法的思想总结一下就是在训练集中数据和标签已知的情况下，输入测试数据，将测试数据的特征与训练集中对应的特征进行相互比较，找到训练集中与之最为相似的前K个数据，则该测试数据对应的类别就是K个数据中出现次数最多的那个分类，其算法的描述为： 1）计算测试数据与各个训练数据之间的距离； 2）按照距离的递增关系进行排序； 3）选取距离最小的K个点； 4）确定前K个点所在类别的出现频率； 5）返回前K个点中出现频率最高的类别作为测试数据的预测分类。 python 代码实现： 123456789101112131415161718192021222324252627282930313233343536#coding:utf-8from numpy import *import operator##给出训练数据以及对应的类别def createDataSet(): group = array([[1.0,2.0],[1.2,0.1],[0.1,1.4],[0.3,3.5]]) labels = ['A','A','B','B'] return group,labels###通过KNN进行分类def classify(input,dataSe t,label,k): dataSize = dataSet.shape[0] ####计算欧式距离 diff = tile(input,(dataSize,1)) - dataSet sqdiff = diff ** 2 squareDist = sum(sqdiff,axis = 1)###行向量分别相加，从而得到新的一个行向量 dist = squareDist ** 0.5 ##对距离进行排序 sortedDistIndex = argsort(dist)##argsort()根据元素的值从大到小对元素进行排序，返回下标 classCount=&#123;&#125; for i in range(k): voteLabel = label[sortedDistIndex[i]] ###对选取的K个样本所属的类别个数进行统计 classCount[voteLabel] = classCount.get(voteLabel,0) + 1 ###选取出现的类别次数最多的类别 maxCount = 0 for key,value in classCount.items(): if value &gt; maxCount: maxCount = value classes = key return classes 测试代码如下： 12345678910#-*-coding:utf-8 -*-import syssys.path.append("...文件路径...")import KNNfrom numpy import *dataSet,labels = KNN.createDataSet()input = array([1.1,0.3])K = 3output = KNN.classify(input,dataSet,labels,K)print("测试数据为:",input,"分类结果为：",output) 回车之后的结果为： 测试数据为： [ 1.1 0.3] 分类为： A 答案符合我们的预期，要证明算法的准确性，势必还需要通过处理复杂问题进行验证，之后另行说明。 【提示】python版本为3.7 具体的KNN视频教程地址为： 参考参考文档来源1:Yabea-博客 参考文档来源2:李航-统计学习方法]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.2 矩阵相关基础知识]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-2-%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍矩阵相关基础相关实际应用搞得入门例子，很简单，但是能说明矩阵相关基础的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 矩阵相关基础知识]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>矩阵相关基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.7 神经网络浅学笔记]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-7-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%B5%85%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录神经网络相关的基础知识 Edit By Porter, 积水成渊,蛟龙生焉。 一、神经网络神经网络是一种模拟人脑的神经网络以期能够实现类人工智能的机器学习技术。 对于神经元的研究由来已久，1904年生物学家就已经知晓了神经元的组成结构。 一个神经元通常具有多个树突，主要用来接受传入信息；而轴突只有一条，轴突尾端有许多轴突末梢可以给其他多个神经元传递信息。轴突末梢跟其他神经元的树突产生连接，从而传递信号。这个连接的位置在生物学上叫做“突触”。 1.1 神经元1.1.1 让我们来看一个经典的神经网络。这是一个包含三个层次的神经网络。 红色的是输入层，绿色的是输出层，紫色的是中间层（也叫隐藏层）。 输入层有3个输入单元，隐藏层有4个单元，输出层有2个单元。 后文中，我们统一使用这种颜色来表达神经网络的结构。 1.1.2 在开始介绍前，有一些知识可以先记在心里 设计一个神经网络时，输入层与输出层的节点数往往是固定的，中间层则可以自由指定； 神经网络结构图中的拓扑与箭头代表着预测过程时数据的流向，跟训练时的数据流有一定的区别； 结构图里的关键不是圆圈（代表“神经元”），而是连接线（代表“神经元”之间的连接）。每个连接线对应一个不同的权重（其值称为权值），这是需要训练得到的。 1.1.3 神经元结构神经元模型是一个包含输入，输出与计算功能的模型。输入可以类比为神经元的树突，而输出可以类比为神经元的轴突，计算则可以类比为细胞核。 下图是一个典型的神经元模型：包含有3个输入，1个输出，以及2个计算功能。注意中间的箭头线。这些线称为“连接”。每个上有一个“权值”。 连接是神经元中最重要的东西。每一个连接上都有一个权重。 一个神经网络的训练算法就是让权重的值调整到最佳，以使得整个网络的预测效果最好。 我们使用a来表示输入，用w来表示权值。一个表示连接的有向箭头可以这样理解：在初端，传递的信号大小仍然是a，端中间有加权参数w，经过这个加权后的信号会变成aw，因此在连接的末端，信号的大小就变成了aw。 在其他绘图模型里，有向箭头可能表示的是值的不变传递。而在神经元模型里，每个有向箭头表示的是值的加权传递。 如果我们将神经元图中的所有变量用符号表示，并且写出输出的计算公式的话，就是下图。 可见z是在输入和权值的线性加权和叠加了一个函数g的值。在MP模型里，函数g是sgn函数，也就是取符号函数。这个函数当输入大于0时，输出1，否则输出0。 下面对神经元模型的图进行一些扩展。首先将sum函数与sgn函数合并到一个圆圈里，代表神经元的内部计算。其次，把输入a与输出z写到连接线的左上方，便于后面画复杂的网络。最后说明，一个神经元可以引出多个代表输出的有向箭头，但值都是一样的。 神经元可以看作一个计算与存储单元。计算是神经元对其的输入进行计算功能。存储是神经元会暂存计算结果，并传递到下一层。 当我们用“神经元”组成网络以后，描述网络中的某个“神经元”时，我们更多地会用“单元”（unit）来指代。同时由于神经网络的表现形式是一个有向图，有时也会用“节点”（node）来表达同样的意思。 1.1.4 神经元模型的使用可以这样理解 我们有一个数据，称之为样本。样本有四个属性，其中三个属性已知，一个属性未知。我们需要做的就是通过三个已知属性预测未知属性。 具体办法就是使用神经元的公式进行计算。三个已知属性的值是a1，a2，a3，未知属性的值是z。z可以通过公式计算出来。 这里，已知的属性称之为特征，未知的属性称之为目标。假设特征与目标之间确实是线性关系，并且我们已经得到表示这个关系的权值w1，w2，w3。那么，我们就可以通过神经元模型预测新样本的目标。 1.2 单层神经网络（感知器）1958年，计算科学家Rosenblatt提出了由两层神经元组成的神经网络。他给它起了一个名字–“感知器”（Perceptron） 感知器是当时首个可以学习的人工神经网络。 1.2.1 感知器模型结构在原来MP模型的“输入”位置添加神经元节点，标志其为“输入单元”。其余不变，于是我们就有了下图：从本图开始，我们将权值w1, w2, w3写到“连接线”的中间。 在“感知器”中，有两个层次。分别是输入层和输出层。输入层里的“输入单元”只负责传输数据，不做计算。输出层里的“输出单元”则需要对前面一层的输入进行计算。 我们把需要计算的层次称之为“计算层”，并把拥有一个计算层的网络称之为“单层神经网络”。有一些文献会按照网络拥有的层数来命名，例如把“感知器”称为两层神经网络。但在本文里，我们根据计算层的数量来命名。 假如我们要预测的目标不再是一个值，而是一个向量，例如[2,3]。那么可以在输出层再增加一个“输出单元”。 可以看到，z1的计算跟原先的z并没有区别。 我们已知一个神经元的输出可以向多个神经元传递，因此z2的计算公式如下图。 可以看到，z2的计算中除了三个新的权值：w4，w5，w6以外，其他与z1是一样的。整个网络的输出如下图。 目前的表达公式有一点不让人满意的就是：w4，w5，w6是后来加的，很难表现出跟原先的w1，w2，w3的关系。 因此我们改用二维的下标，用wx,y来表达一个权值。下标中的x代表后一层神经元的序号，而y代表前一层神经元的序号（序号的顺序从上到下）。 例如，w1,2代表后一层的第1个神经元与前一层的第2个神经元的连接的权值（这种标记方式参照了Andrew Ng的课件）。根据以上方法标记，我们有了下图。 如果我们仔细看输出的计算公式，会发现这两个公式就是线性代数方程组。因此可以用矩阵乘法来表达这两个公式。 例如，输入的变量是[a1，a2，a3]T（代表由a1，a2，a3组成的列向量），用向量a来表示。方程的左边是[z1，z2]T，用向量z来表示。 系数则是矩阵W（2行3列的矩阵，排列形式与公式中的一样）。 于是，输出公式可以改写成： $$g(W * a) = z;$$ 这个公式就是神经网络中从前一层计算后一层的矩阵运算。 1.2.2 效果与神经元模型不同，感知器中的权值是通过训练得到的。因此，根据以前的知识我们知道，感知器类似一个逻辑回归模型，可以做线性分类任务。 我们可以用决策分界来形象的表达分类的效果。决策分界就是在二维的数据平面中划出一条直线，当数据的维度是3维的时候，就是划出一个平面，当数据的维度是n维时，就是划出一个n-1维的超平面。 下图显示了在二维平面中划出决策分界的效果，也就是感知器的分类效果。 感知器只能做简单的线性分类任务。 1.3 两层神经网络（多层感知器）Minsky说过单层神经网络无法解决异或问题。但是当增加一个计算层以后，两层神经网络不仅可以解决异或问题，而且具有非常好的非线性分类效果。不过两层神经网络的计算是一个问题，没有一个较好的解法。 1986年，Rumelhar和Hinton等人提出了反向传播（Backpropagation，BP）算法，解决了两层神经网络所需要的复杂计算量问题，从而带动了业界使用两层神经网络研究的热潮。目前，大量的教授神经网络的教材，都是重点介绍两层（带一个隐藏层）神经网络的内容。 这时候的Hinton还很年轻，30年以后，正是他重新定义了神经网络，带来了神经网络复苏的又一春。 1.3.1 两层神经网络的结构（多层感知器）Minsky说过单层神经网络无法解决异或问题。但是当增加一个计算层以后，两层神经网络不仅可以解决异或问题，而且具有非常好的非线性分类效果。不过两层神经网络的计算是一个问题，没有一个较好的解法。 两层神经网络除了包含一个输入层，一个输出层以外，还增加了一个中间层。此时，中间层和输出层都是计算层。我们扩展上节的单层神经网络，在右边新加一个层次（只含有一个节点）。 现在，我们的权值矩阵增加到了两个，我们用上标来区分不同层次之间的变量。 例如$$a_{x} ^{(y)}$$代表第y层的第x个节点。$$z_{1},z_{2}$$变成了$$a_{1} ^{(2)} , a_{2} ^{(2)}$$。下图给出了$$a_{1} ^{(2)} , a_{2} ^{(2)}$$的计算公式。 计算最终输出z的方式是利用了中间层的$$a_{1} ^{(2)}, a_{2} ^{(2)}$$和第二个权值矩阵计算得到的，如下图。 假设我们的预测目标是一个向量，那么与前面类似，只需要在“输出层”再增加节点即可。 我们使用向量和矩阵来表示层次中的变量。$$a_{1} , a_{2} , z $$是网络中传输的向量数据。$$W^{(1)}, W^{(2)}$$是网络的矩阵参数。如下图。 使用矩阵运算来表达整个计算公式的话如下： $$g(W^{(1)} a^{(1)}) = a^{(2)}; g(W^{(2)} a^{(2)}) = z;$$ 上面写的全是权重w但还未引入偏置。下面我们接着写偏置 由此可见，使用矩阵运算来表达是很简洁的，而且也不会受到节点数增多的影响（无论有多少节点参与运算，乘法两端都只有一个变量）。因此神经网络的教程中大量使用矩阵运算来描述。 需要说明的是，至今为止，我们对神经网络的结构图的讨论中都没有提到偏置节点（bias unit）。事实上，这些节点是默认存在的。它本质上是一个只含有存储功能，且存储值永远为1的单元。在神经网络的每个层次中，除了输出层以外，都会含有这样一个偏置单元。正如线性回归模型与逻辑回归模型中的一样。 偏置单元与后一层的所有节点都有连接，我们设这些参数值为向量b，称之为偏置。如下图。 可以看出，偏置节点很好认，因为其没有输入（前一层中没有箭头指向它）。有些神经网络的结构图中会把偏置节点明显画出来，有些不会。一般情况下，我们都不会明确画出偏置节点。 在考虑了偏置以后的一个神经网络的矩阵运算如下： $$g(W^{(1)} a^{(1)}+b^{(1)}) = a^{(2)}; g(W^{(2)} a^{(2)}+b^{(1)}) = z;$$ 需要说明的是，在两层神经网络中，我们不再使用sgn函数作为函数g，而是使用平滑函数sigmoid作为函数g。我们把函数g也称作激活函数（active function）。 事实上，神经网络的本质就是通过参数与激活函数来拟合特征与目标之间的真实函数关系。初学者可能认为画神经网络的结构图是为了在程序中实现这些圆圈与线，但在一个神经网络的程序中，既没有“线”这个对象，也没有“单元”这个对象。实现一个神经网络最需要的是线性代数库。 1.4 多层神经网络（深度学习）1.4.1 多层神经网络的结构（深度学习）我们延续两层神经网络的方式来设计一个多层神经网络。 在两层神经网络的输出层后面，继续添加层次。原来的输出层变成中间层，新加的层次成为新的输出层。所以可以得到下图。 依照这样的方式不断添加，我们可以得到更多层的多层神经网络。公式推导的话其实跟两层神经网络类似，使用矩阵运算的话就仅仅是加一个公式而已。 在已知输入$$a^{(1)}$$，参数$$W^{(1)},W^{(2)},W^{(3)}$$的情况下，输出z的推导公式如下：$$g(W^{(1)} * a^{(1)}) = a^{(2)}; g(W^{(2)} * a^{(2)}) = a^{(3)}; g(W^{(3)} * a^{(3)}) = z;$$ 多层神经网络中，输出也是按照一层一层的方式来计算。从最外面的层开始，算出所有单元的值以后，再继续计算更深一层。只有当前层所有单元的值都计算完毕以后，才会算下一层。有点像计算向前不断推进的感觉。所以这个过程叫做“正向传播”。 下面讨论一下多层神经网络中的参数。 首先我们看第一张图，可以看出$$W^{(1)}$$中有6个参数，$$W^{(2)}$$中有4个参数，$$W^(3)$$中有6个参数，所以整个神经网络中的参数有16个（这里我们不考虑偏置节点，下同）。 假设我们将中间层的节点数做一下调整。第一个中间层改为3个单元，第二个中间层改为4个单元。 经过调整以后，整个网络的参数变成了33个。 虽然层数保持不变，但是第二个神经网络的参数数量却是第一个神经网络的接近两倍之多，从而带来了更好的表示（represention）能力。表示能力是多层神经网络的一个重要性质，下面会做介绍。 在参数一致的情况下，我们也可以获得一个“更深”的网络。 上图的网络中，虽然参数数量仍然是33，但却有4个中间层，是原来层数的接近两倍。这意味着一样的参数数量，可以用更深的层次去表达。 1.4.2 多层神经网络的效果（深度学习）与两层层神经网络不同。多层神经网络中的层数增加了很多。 增加更多的层次有什么好处？更深入的表示特征，以及更强的函数模拟能力。 更深入的表示特征可以这样理解，随着网络的层数增加，每一层对于前一层次的抽象表示更深入。在神经网络中，每一层神经元学习到的是前一层神经元值的更抽象的表示。例如第一个隐藏层学习到的是“边缘”的特征，第二个隐藏层学习到的是由“边缘”组成的“形状”的特征，第三个隐藏层学习到的是由“形状”组成的“图案”的特征，最后的隐藏层学习到的是由“图案”组成的“目标”的特征。通过抽取更抽象的特征来对事物进行区分，从而获得更好的区分与分类能力。 关于逐层特征学习的例子，可以参考下图。 更强的函数模拟能力是由于随着层数的增加，整个网络的参数就越多。而神经网络其实本质就是模拟特征与目标之间的真实关系函数的方法，更多的参数意味着其模拟的函数可以更加的复杂，可以有更多的容量（capcity）去拟合真正的关系。 通过研究发现，在参数数量一样的情况下，更深的网络往往具有比浅层的网络更好的识别效率。这点也在ImageNet的多次大赛中得到了证实。从2012年起，每年获得ImageNet冠军的深度神经网络的层数逐年增加，2015年最好的方法GoogleNet是一个多达22层的神经网络。 在最新一届的ImageNet大赛上，目前拿到最好成绩的MSRA团队的方法使用的更是一个深达152层的网络！关于这个方法更多的信息有兴趣的可以查阅ImageNet网站。 1.4.3 多层神经网络的训练（深度学习）在单层神经网络时，我们使用的激活函数是sgn函数。到了两层神经网络时，我们使用的最多的是sigmoid函数。而到了多层神经网络时，通过一系列的研究发现，ReLU函数在训练多层神经网络时，更容易收敛，并且预测性能更好。因此，目前在深度学习中，最流行的非线性函数是ReLU函数。ReLU函数不是传统的非线性函数，而是分段线性函数。其表达式非常简单，就是y=max(x,0)。简而言之，在x大于0，输出就是输入，而在x小于0时，输出就保持为0。这种函数的设计启发来自于生物神经元对于激励的线性响应，以及当低于某个阈值后就不再响应的模拟。 在多层神经网络中，训练的主题仍然是优化和泛化。当使用足够强的计算芯片（例如GPU图形加速卡）时，梯度下降算法以及反向传播算法在多层神经网络中的训练中仍然工作的很好。目前学术界主要的研究既在于开发新的算法，也在于对这两个算法进行不断的优化，例如，增加了一种带动量因子（momentum）的梯度下降算法。 在深度学习中，泛化技术变的比以往更加的重要。这主要是因为神经网络的层数增加了，参数也增加了，表示能力大幅度增强，很容易出现过拟合现象。因此正则化技术就显得十分重要。目前，Dropout技术，以及数据扩容（Data-Augmentation）技术是目前使用的最多的正则化技术。 文章参考来源：计算机的潜意识]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3 隐马尔科夫HMM]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-3-%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%ABHMM%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍隐马尔科夫HMM相关实际应用搞得入门例子，很简单，但是能说明隐马尔科夫HMM的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook HMM（隐马尔可夫模型）隐马尔可夫模型是一种统计模型，用来描述一个含有隐含未知参数的马尔可夫过程。其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。 是在被建模的系统被认为是一个马尔可夫过程与未观测到的（隐藏的）的状态的统计马尔可夫模型。 本文简述的是离散情况下的隐马尔可夫模型. 一、贝叶斯公式定义：假设以硬币的例子，从5角和1元的一堆硬币中，随意取出一枚硬币，然后然我们猜这枚硬币是5角还是1元。假设允许我们称这枚硬币的重量x（单位：g），(但是不允许我们直接看硬币，一般1元是比5角重的)。现在应考察在一直这枚硬币的重量x的情况下硬币属于各类（5角还是一元)的概率，分别记$$P(\omega_{1}|x)$$,(知重量为x时，是5角的概率),$$P(\omega_{2}|x)$$, (知重量为x时，是一元的概率)，这种概率成为后验概率（我们需要求的）。这时的决策为：如果$$P(\omega_{1}|x)&gt;P(\omega_{2}|x)$$,则$$x \epsilon \omega_{1} $$; 反之，则$$x \epsilon \omega_{2} $$ 最终我们要的就是这个决策。 概率论中的贝叶斯公式： $$P(\omega_{i}|x)=\frac{p(x,\omega_{i})}{p(\omega_{i})}=\frac{p|\omega_{i}P(\omega_{i})}{p(x)} ,i=1,2$$ 分布 表示 $$x \epsilon \left { \omega_{1},\omega_{2} \right }$$ 类条件概率： $$p(x\mid \omega_{i})$$ 表示得到硬币结果是$$\omega_{i}$$条件下，得到x的概率密度 后验概率： $$P(\omega_{i}\mid x)$$ 在重量为x，的条件下，得到是哪种硬币（5/1）的概率 先验概率： $$P(\omega_{i})$$ 根据之前的经验，得到5角和1元各自取得的概率 硬币重量概率密度函数: $$p(x)$$ 硬币重量的概率密度函数 联合概率密度： $$p(x,\omega_{i})$$ 在重量不同条件下，每种情况对应的取得不同硬币结果的联合概率 $$P(Q_{i}|O)=\frac{P(O,Q_{i})}{P(O)}=\frac{P(O|Q_{i})P(Q)}{P(O)}$$ $$P(Q_{i}|O)=\frac{P(O,Q_{i})}{P(O)}=\frac{P(O|Q_{i})P(Q)}{P(O)}$$ $$P(Q_{i}|O)$$ ,后验概率，$$P(O,Q_{i})$$ ,表示O与Q的联合概率密度；P(O)表示两类所有的概率密度； P(Q_{i})是先验概率；$$P(O|Q_{i})$$是第i类状态随机序列的类条件概率密度 贝叶斯决策：在类条件概率密度和鲜艳概率已知（或可估计）的情况下，通过贝叶斯公式比较样本属于两类的后验概率，将类别决策为后验概率大的一类，这样做的目的是为了使总体错误率最小。 一条隐藏的马尔可夫链生成的 状态随机序列 (State sequence, 图中的白色节点) $$Q=(q_{1},q_{2},…..,q_{T})$$是不可观测的，并记所有可能状态的集合为$$S={S_{1},S_{2},…..,S_{N}}$$;由它们产生一个可观测的观测随机序列（observation sequence，图示的深色节点）$$O=(o_{1},o_{2},……,o_{T})$$, 并记所有可能观测的集合为$$V={v_{1},v_{2},……,v_{M}}$$。 序列的值可以看作是随时刻产生的，每个时刻对应着序列的一个值。所以HMM是个双重随机过程（doubly embedded stochastic process），一个是状态转移，另一个是由状态释放出观测值。在序列标注（Sequence labelling）任务中，模型就是需要对状态序列进行标注。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>隐马尔科夫HMM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3 线性回归]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍线性回归相关基础相关实际应用搞得入门例子，很简单，但是能说明线性回归相关基础的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook LinearRegression算法 学习参考来源 一、最小二乘法的拟合原理 最小二乘法定义如上图所示，但是初看可能会有点懵，上面的表示是啥意思，好接下来总结下我的理解 最小二乘法（又称最小平方法）是一种数学优化技术，除了能拟合直线还能拟合曲线问题。 书中截取部分如果可以这样理解$$\alpha_{i}$$，如果是二次项的话$$y=\alpha_{1} x^{2}+\alpha_{2} x + \alpha_{3} $$，知道了吧，就是一个二项式子中的待解参数。 本文为了推导和笔记的简单化，直接以拟合直线 $$f(x;a,b): y=ax+b$$ 1.1 代数推导： [1]. 假设拟合直线 $$f(x;a,b): y=ax+b$$ [2]. 已经由n个样本$$(x_{n}, y_{n})$$ [3]. 误差$$e_{i}=y_{i}-(ax_{i}+b)$$ [4]. 当$$S = \sum_{i=1}^{n} e_{i}^{2}$$为最小值时，即得到的a,b参数就是最小二乘法得到的解. 如何求解这些参数（a，b） $$\frac{\partial S}{\partial b}=-2(\sum_{i=1}^{n}y_{i}-nb-a\sum_{i=1}^{n}x_{i})$$ $$\frac{\partial S}{\partial a}=-2(\sum_{i=1}^{n}x_{i}y_{i}-b\sum_{i=1}{n}x_{i}-a\sum_{i=1}^{n}x_{i}^{2})$$ 分别令上式中对a,b求偏导数的有点等于0,以此求取对a,b的最值.有：$$n\bar x=\sum_{i=1}^{n}x_i,n\bar y=\sum_{i=1}^{n}y_i$$ 得到： $$a=\frac {\sum_{i=1}^{n}({x_i-\bar x})(y_i-\bar y)} {\sum_{i=1}^{n}({x_i-\bar x})^2}$$ $$b=\bar y-a\bar x$$ $$a=\frac {n\sum_{}^{}{x_iy_i}-\sum_{}^{}{x_i}\sum_{}^{}{y_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ $$b=\frac {\sum_{}^{}{x_i}^2\sum_{}^{}{y_i}-\sum_{}^{}{x_i}\sum_{}^{}{x_iy_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ 1.1.1 代数推导的代码实现123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltdef calcAB(x,y): n = len(x) sumX,sumY,sumXY,sumXX =0,0,0,0 for i in range(0,n): sumX += x[i] sumY += y[i] sumXX += x[i]*x[i] sumXY += x[i]*y[i] a = (n*sumXY -sumX*sumY)/(n*sumXX -sumX*sumX) b = (sumXX*sumY - sumX*sumXY)/(n*sumXX-sumX*sumX) return a,b,xi = [1,2,3,4,5,6,7,8,9,10]yi = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]a,b=calcAB(xi,yi)print("y = %10.5fx + %10.5f" %(a,b))x = np.linspace(0,10)y = a * x + bplt.plot(x,y)plt.scatter(xi,yi)plt.show() 1.2 矩阵推导对于$$y=ax+b$$,转为向量的形式为$$W=\begin{bmatrix}w_0\w_1\end{bmatrix},X=\begin{bmatrix}1\x_1\end{bmatrix}$$ 于是：$$y=w_1x_1+w_0=W^TX$$ 损失函数为: $$L=\frac{1}{n}\sum_{i=1}^{n}(y_n-(W^TX)^2)=\frac{1}{n}(y-XW)^T(y-XW)$$ 最后可化为 $$\frac{1}{n}X^TW^TXW-\frac{2}{n}X^TW^Ty+\frac{1}{n}y^Ty$$ 令偏导为0 $$\frac{\partial L}{\partial W}=\frac{2}{n}X^TXW-\frac{2}{n}X^Ty=0$$ 另外： $$(X^TX)^{-1}X^TX=E,EW=W$$,则 $$(X^TX)^{-1}X^TXW=(X^TX)^{-1}X^Ty,W=(X^TX)^{-1}X^Ty$$ 1.2.1 代码实现：12345678910111213141516import numpy as npimport matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8,9,10]y = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]A = np.vstack([x,np.ones(len(x))]).Ta,b = np.linalg.lstsq(A,y)[0]print("y = %10.5fx + %10.5f" %(a,b))x = np.array(x)y = np.array(y)plt.plot(x,y,'o',label='data',markersize=10)plt.plot(x,a*x+b,'r',label='line')plt.show() 拟合的效果（蓝线） 1.3 小结 二、线性回归线性回归的目的是找到一个与这些数据最为温和的线性函数，用来预测或者分类，主要解决线性问题。一般来说，线性回归问题都可以通过最小二乘法来求出方程。线性回归属于监督学习,因此方法和监督学习应该一样，先给一个训练集，根据这个训练集学习出一个线性函数，然后测试这个函数训练的好不好（拟合是否恰当）。Cost Function 越小的函数，说明训练数据拟合程度越好。 线性回归，通过数据集的线性组合来预测函数： $$f(x)=\omega_{1}x_{1}+\omega_{2}x_{2}+\omega_{3}x_{3}+…+\omega_{d}x_{d}+b$$ 一般向量形式写为： $$f(x)=\omega^{T}x+b$$ 其中的$$\omega=(\omega_{1};\omega_{2};\omega_{2};…\omega_{d})$$ $$x_{1},x_{2},…x_{k}$$是一组独立的预测变量 $$\omega_{1},\omega_{2},…\omega_{k}$$为模型从训练数据中学习得到的参数，或称赋予每个变量的权值。 b是一个学习到的参数，这个现行函数中的常量也称模型的偏置（Bias） 根据输入属性可分为一元，二元……多元线性回归。 多元数据集的定义如下： $$D=\left [ x_{i,j}, y_{i}\right ]$$，其中i,表示数据集第i位序列的值，而j则表示在第i位x的属性是j种属性，即数据集中，x(i,j)，i维行，j维纵坐标的矩阵。 即数据集j元的属性矩阵表示为：$$\begin{bmatrix}x_{1,1} &amp; x_{1,2} &amp; … &amp; x_{1,j-1} &amp; x_{1,j}\x_{2,1} &amp; x_{2,2} &amp; … &amp; x_{2,j-1} &amp; x_{2,j}\… &amp; … &amp; … &amp; … &amp; …\x_{i,1} &amp; x_{i,2} &amp; … &amp; x_{i,j-1} &amp; x_{i,j}\end{bmatrix}$$ 比如3元的表示一个西瓜好坏，【hue, root, echo】，加入预测函数的参数已经求得$$\omega=\left [ 0.2, 0.5, 0.3 \right ],b=1$$，则好瓜（good)函数$$f_{good}(x)=0.2 \cdot x_{hue}+0.5 \cdot x_{root}+0.3 \cdot x_{echo}+1$$ 2.1 一元线性回归 输入属性只有一个的情况，称一元线性回归 属性： 这里考虑一元的情况则数据集为： $$D=\left [ x_{i}, y_{i}\right ]_{i=1}^{m} $$,即上面矩阵表示的j元数据集中j=1，现在我们来尝试一元的线性回归。 [1] 假设我们预测函数形式：$$f(x_{i})=\omega x_{i}+b_{i}$$,使得$$f(x_{i})\approx y_{i}$$. 接下来我们引入上面的最小二乘法求参数$$\omega , b$$. [2] 假设最小均方误差函数为： $$e_{\omega^,b^}=arg_{(\omega,b)}min \sum_{i=1}^{m}(f(x_{i})-y_{i})^2 $$ [3] 对上式e的函数分别对$$\omega,b$$求偏导，对偏导结果赋值0，求$$\omega,b$$值。 [4] 偏导数 $$\frac{\partial E_{\omega,b}}{\partial \omega}=2(\omega\sum_{i=1}^{m}x_{i}^{2}-\sum_{i=1}^{m}(y_{i}-b)x_{i})$$ $$\frac{\partial E_{\omega,b}}{\partial b}=2(mb-\sum_{i=1}^{m}(y_{i} - \omega x_{i}))$$ [5] 上一步骤中的偏导数都设为零，以此来求得$$\omega , b$$. $$\omega = \frac{\sum_{i=1}^{m} y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^{2}-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^2}$$ $$b=\frac{1}{m}\sum_{i=1}^{m}(y_{i}-\omega x_{i}),\bar{x}=\frac{1}{m}\sum_{i=1}^{m}x_{i}$$,$$\bar{x}$$为序列x的均值。 这里一元的线性回归，用最小二乘法求解的参数估计，称为线性回归模型的最小二乘法“参数估计”(parameter estimation). 2.2 多元线性回归类似一元，但是求解 估计的参数矩阵$$\omega, b$$，就需要全部看成矩阵的求解方法求出。见最小二乘法矩阵推导那一节，不再具体推推导了，在2.1节基础上明白线性回归，多元回归思想即可明白。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>线性回归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2 最大熵模型]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-2-%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍最大熵相关实际应用搞得入门例子，很简单，但是能说明最大熵的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 2.1.2 隐马尔科夫HMM在讲HMM前先看看什么是熵的概念 一、什么是熵(Entropy)信息熵的概念这个得从 热熵 开始说起，信熵是香农老先生从热力学引进来的，为了表示把信息中排除了冗余后的平均信息量称为“信息熵”。 热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。 1.1 热力学中–热熵从能量角度来看,熵定律意味着自然进行的能量转化过程总是由有序度高的能量向有序度低的能量转化,这个过程必定朝着熵增加的方向进行。 高温物体所有分子的平均能量要高于低温物体,所以相接触时总是从高温物体向低温物体传递热量,因为碰撞使它们的状态向平衡过渡,系统才会稳定; 热熵是向着熵增大的方向进行。从宇宙形成到地球诞生以及地球生命的形成,热熵一直有缓慢变大的趋势。 热熵改变是指在某个空间内热量分布的变化。 1、在热力学中熵是对热量状态的描述，空间内热量分布差异越大则熵越小，做功的能力越强；空间内热量分布差异越小则熵越大，做功的能力越弱。热熵改变是指在某个空间内热量分布的变化，熵越大则热量分布的差异越小。正常情况下熵会从小到大的变化，最终熵达到最大而呈热寂。 2、根据热力学第二定律，作为一个“孤立”的系统，宇宙的熵会随着时间的流逝而增加，由有序向无序，当宇宙的熵达到最大值时，宇宙中的其他有效能量已经全数转化为热能，所有物质温度达到热平衡。这种状态称为热寂。这样的宇宙中再也没有任何可以维持运动或是生命的能量存在。 3、热熵改变的本质是热量分布由有序向无序发展，所以也可以看成系统混乱程度的改变。 4、熵最初是根据热力学第二定律引出的一个反映自发过程不可逆性的物质状态参量。热力学第二定律是根据大量观察结果总结出来的规律，有下述表述方式：热量总是从高温物体传到低温物体，不可能作相反的传递而不引起其他的变化；功可以全部转化为热，但任何热机不能全部地，连续不断地把所接受的热量转变为功；在孤立系统中，实际发生过程总使整个系统的熵值增大，此即熵增原理。 简单总结：热熵是熵增的过程，热量由有序的状态，转移，或是机械能，或是向其他低温物体转移，产生的影响是，最终达到系统平衡的目的，但也使得整个系统不再是以前清晰的状态，相反是变成了另一种混乱的状态，可以这样白话理解。 1.2 信息论中的信息熵–信熵 香农用信息熵的概念来描述信源的不确定度。 信息量信息量：一个事件发生的概率越小，信息量越大，所以信息量应该为概率的减函数，对于相互独立的两个事有p(xy)=p(x)p(y)，对于这两个事件信息量应满足h(xy)=h(x)+h(y)，那么信息量应为对数函数： 信息熵根据Charles H. Bennett对Maxwell’s Demon的重新解释，对信息的销毁是一个不可逆过程，所以销毁信息是符合热力学第二定律的。而产生信息，则是为系统引入负（热力学）熵的过程。所以信息熵的符号与热力学熵应该是相反的。 假设离散随机变量X的概率分布为P(x)，则其熵为： H(x) = E[I(xi)] = E[ log(2,1/p(xi)) ] = -∑p(xi)log(2,p(xi)) (i=1,2,..n) 其中，x表示随机变量，与之相对应的是所有可能输出的集合，定义为符号集,随机变量的输出用x表示。P(x)表示输出概率函数。变量的不确定性越大，熵也就越大 ，把它搞清楚所需要的信息量也就越大. 能量角度，高温向低温转变，一般是熵增的过程；而信息论中，为了最大可能接收到正确的（发出==收到）的信息，我们处理（优化）系统，是一种熵减的过程，信熵越小，系统有用信息量越大。 信息熵：信息的基本作用就是消除人们对事物的不确定性 。多数粒子组合之后，在它似像非像的形态上押上有价值的数码，具体地说，这就是一个在博弈对局中现象信息的混乱。 举个例子-(p1log(2,p1) + p2 log(2,p2) + ．．． +p32 *log(2,p32))，其中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。 有兴趣的读者可以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基础的读者还可以证明上面公式的值不可能大于五。因为得冠军的频率相同代表整个系统信息量最小。 熵是随机变量不确定性的度量，不确定性越大，熵值就越大；若随机变量退化成定值，熵为0。均匀分布(信熵最大)是“最不确定”的分布。 熵最早来原于物理学. 德国物理学家鲁道夫·克劳修斯首次提出熵的概念，用来表示任何一种能量在空间中分布的均匀程度，能量分布得越均匀，熵就越大。 总结：香农，描述一个信息系统的时候就借用了熵的概念，这里熵表示的是这个信息系统的平均信息量(平均不确定程度),信熵越小，系统信息不确定程度越低，反之，系统信息输出越混乱，有用信息越不容易被确认。 1.3 联合熵联合熵是一集变量之间不确定性的衡量手段。两个变量和的联合信息熵定义为： 一集变量的联合熵大于或等于这集变量中任一个的独立熵。 少于独立熵的和 这表明，两个变量关联之后不确定性会增大，但是又由于相互有制约关系，不确定小于单独两个变量的不确定度之和。 1.4 条件熵 条件熵H(X|Y) = H(X,Y) - H(Y) X在条件Y下的条件熵 条件熵 H(Y|X) 表示在已知随机变量 X 的条件下随机变量 Y 的不确定性。条件熵 H(Y|X) 定义为 X 给定条件下 Y 的条件概率分布的熵对 X 的数学期望： 证明如下： 条件熵 H(Y|X) 相当于联合熵 H(X,Y) 减去单独的熵 H(X)，即 举个例子，比如环境温度是低还是高，和我穿短袖还是外套这两个事件可以组成联合概率分布 H(X,Y)，因为两个事件加起来的信息量肯定是大于单一事件的信息量的。假设 H(X) 对应着今天环境温度的信息量，由于今天环境温度和今天我穿什么衣服这两个事件并不是独立分布的，所以在已知今天环境温度的情况下，我穿什么衣服的信息量或者说不确定性是被减少了(条件熵减少，联合熵是不变)。当已知 H(X) 这个信息量的时候，H(X,Y) 剩下的信息量就是条件熵： H(Y|X)=H(X,Y)−H(X) 1.5 相对熵与互信息 相对熵 (Relative entropy)，也称KL散度 (Kullback–Leibler divergence) 设p(x),q(x)是X中取值的两个概率分布，则p对q的相对熵是： 性质： 1、如果 p(x) 和 q(x) 两个分布相同，那么相对熵等于0 2、 ,相对熵具有不对称性。大家可以举个简单例子算一下。 3、DKL(p||q)≥0 证明如下（利用Jensen不等式https://en.wikipedia.org/wiki/Jensen%27s_inequality）： 因为： 所以： 总结：相对熵可以用来衡量两个概率分布之间的差异，上面公式的意义就是求 p 与 q 之间的对数差在 p 上的期望值。 相对熵，两者相同，那么相对熵等于0，两者差距越大，则相对熵值越大。 互信息两个随机变量X，Y的联合分布与独立分布乘积的相对熵，即： 1.6 交叉熵 (Cross entropy)熵的公式：$$H(p)=-\displaystyle\sum_{x}p(x)logp(x)$$ 相对熵的公式： $$H(p,q)=\displaystyle\sum _{x}p(x)log\frac{1}{q(x)}=-\sum _{x}p(x)logq(x)$$ 所以有： $$D_{KL}(p||q)=H(p,q)-H(p)$$ 当用非真实分布 q(x) 得到的平均码长比真实分布 p(x) 得到的平均码长多出的比特数就是相对熵） 并且当 H(p) 为常量时（注：在机器学习中，训练数据分布是固定的），最小化相对熵 DKL(p||q) 等价于最小化交叉熵 H(p,q) 也等价于最大化似然估计（具体参考Deep Learning 5.5）。 在机器学习中，我们希望在训练数据上模型学到的分布 P(model) 和真实数据的分布 P(real) 越接近越好，所以我们可以使其相对熵最小。 信息熵是衡量随机变量分布的混乱程度，是随机分布各事件发生的信息量的期望值，随机变量的取值个数越多，状态数也就越多，信息熵就越大，混乱程度就越大。当随机分布为均匀分布时，熵最大；信息熵推广到多维领域，则可得到联合信息熵；条件熵表示的是在 X 给定条件下，Y 的条件概率分布的熵对 X的期望。 相对熵可以用来衡量两个概率分布之间的差异。 交叉熵可以来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小。 几种熵的关系： 二、最大熵模型 最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是，在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。 达拉皮垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的数学工具对股票预测，获得了巨大的成功。(值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用)。 我们平常说的最大熵模型，只是运用最大熵思想的多分类模型，最大熵的思想却是一种通用的思维方法。所以，理解最大熵模型只需要搞清楚两件事就可以： 最大熵思想是什么 最大熵模型是如何运用最大熵思想的 2.1 最大熵思想我们知道，分类模型有判别模型和生成模型两种，判别模型是要学习一个条件概率分布 P(y|x)。举例说明 ，设：x是病人身体指标，体温、血压、血糖，y是各种可能的疾病，可简化为小病、中病、大病三种。 现在，我们有一个样本x1={体温：30，血压：160，血糖：60}，那么P(y|x1)就是一个概率分布，该分布的值就是上面简化的三种，小病、中病、大病。可能的概率分布如下所示： 之前参考样本\病况 小病 中病 大病 假设之前有和X1一样的情况有1/2的患者为小病，则此时的最大熵参考样本为 1/2 1/4 1/4 先前12个人和X1一样，结果有3个小病，4个中病的患者，则5个大病 1/4 1/3 5/12 无先前参考样本，假设取最大熵的概率 1/3 1/3 1/3 当然，这样的分布有无数种，上面只是举例说明而已。那么，问题来了，在这无数种概率分布中，哪一个才是好的呢？ 1、也就是说我们没有过往的经验可以参考，那么，就直接选一个熵最大的分布就是，也就是上面表格中的第三个分布，因为均匀分布总是同类分布中熵最大的分布。 2、如果查看以往病例后，我们得到一个经验，指标x1={体温：30，血压：160，血糖：60}有1/2的概率是小病，于是我们有了一定的经验知识，此时，最好的分布就是符合这个经验知识的前提下，熵最大的分布，显然，第一个分布就是最好的分布。 以上，我们就是运用了 最大熵的思想 。总结来说，最大熵的思想是，当你要猜一个概率分布时，如果你对这个分布一无所知，那就猜熵最大的均匀分布，如果你对这个分布知道一些情况，那么，就猜满足这些情况的熵最大的分布。 2.2 运用最大熵思想来做多分类问题 最大熵原理认为，学习概率模型时，在所有可能的概率模型（分布）中，上最大的模型是最好 的模型。 假设离散随机变量X的概率分布是P(X)，则其熵是： 熵取值范围为（当且仅当X是均匀分布时右边的等号成立）： 直观的，最大熵原理认为，要选择的概率模型首先必须要满足已有的事实，即约束条件后，对那些不确定的部分进行等可能概率分配。最大熵原理通过熵的最大化来表示为约束部分等可能性。 最大熵定义 2.3 最大熵的例题解说题：假设随机变量X有5个取值{A,B,C,D,E}, 要估计取各个值的概率P(A),P(B),P(C),P(D),P(E). 假设约束条件如下： 满足上述两个约束条件的可能取值任然很多，于是在求最大熵的过程中，为了得到最大熵，认为为约束的概率分布为等概率分布（等概率分布能确定为最大熵） 解：有约束条件和概率分布知识可知, $$min -H(P) = \sum_{i=1}^{5}P(y_{i})logP(y_{i})$$ 1s.t. P(y_&#123;1&#125;)+P(y_&#123;2&#125;)=\widetilde&#123;P(y_&#123;1&#125;)&#125;+\widetilde&#123;P(y_&#123;2&#125;)&#125;=\frac&#123;3&#125;&#123;10&#125; 1\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;) = \sum_&#123;i=1&#125;^&#123;5&#125;\widetilde&#123;P(y_&#123;i&#125;)&#125;=1 其中带波浪的是实际经验分布概率函数。 引进拉格朗日乘子、 。由上面的约束条件得到的三个方程式结合拉格朗日乘子得到如下拉格朗日函数L(P,w)的表达式。 1L(P,w)=-H(P)+\omega _&#123;0&#125;(\sum_&#123;y&#125;^&#123; &#125;)P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_&#123;1&#125;(E_&#123;\widetilde&#123;P&#125;&#125;(f_&#123;i&#125;)-E_&#123;P&#125;(f_&#123;i&#125;))=\sum_&#123;x,y&#125;\widetilde&#123;P(x)&#125;P(y|x)logP(y|x)+\omega_&#123;0&#125;(1-\sum_&#123;y&#125;^&#123; &#125;P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_1(\sum_&#123;x,y&#125;\widetilde&#123;P(x,y)&#125;-\sum_&#123;x,y&#125;^&#123; &#125;\widetilde&#123;P(x)&#125;P(y|x)f_&#123;i&#125;(x,y)) 带入题干信息可得如下的拉格朗日函数对应本题的表达式： 1L(P,w)=-H(P)+\omega_&#123;0&#125;(1-\sum_&#123;y&#125;^&#123; &#125;P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_&#123;i&#125;(E_&#123;\widetilde&#123;P&#125;&#125;(f_&#123;i&#125;)-E_&#123;P&#125;(f_&#123;i&#125;))=\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;)logP(y_&#123;i&#125;)+\omega_&#123;1&#125;(P(y_&#123;1&#125;)+P(y_&#123;2&#125;)-\frac&#123;3&#125;&#123;10&#125;)+\omega_&#123;0&#125;(\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;)-1) 这里只有3个限制条件，所以带入三个变量w得： 原始问题和对偶问题 根据拉格朗日函数（Ｌ)的对偶性，可以通过求解Ｌ(w)函数的对偶最优化问题得到我们原是函数（Ｌ(p))的最优解。即： 即，对于构造的Ｌ函数，求Ｐ的最小值问题对应ｗ参数的最大值最优解问题，Ｐ是要求的原始问题。Ｐ是原始问题的对偶问题的求解函数变量。 接下来开始求解了原始问题和对偶问题的最优解问题，步骤如下： 第一步先将原始问题（Ｐ参数的Ｌ函数）的最优解换化出来，即 令各偏导数等于0，解得： 于是， 第二步，将原始问题对应的对偶问题（ｗ参数，对应Ｌ函数的最优解）的最优解解出来，即 $$L(P_{w},w)$$ 关于$$w$$的极大化问题。 $$\max_{\omega}L(P_{w},w)=-2e^{-w_{1}-w_{0}-1}-3e^{-w_{1}-1}-\frac{3}{10}w_{1}-w_{0}$$ 分别求$$L(P_{w},w)$$关于$$w_{0},w_{1}$$的偏导数并令其为0，得到： $$e^{-w_{1}-w_{0}-1}=\frac{3}{20},e^{-w_{0}-1}=\frac{7}{30}$$ 于是得到所要求的概率分布为： $$P(y_{1})=P(y_{2})=\frac{3}{20},P(y_{3})=P(y_{4})=P(y_{5})=\frac{7}{30}$$ 总结：最大熵模型，形式简单，但是训练的代价太大，比如最原始的最大熵训练模型GIS（通用迭代算法）和IIS（改进迭代算法），每次迭代时间都很长，而且每步需要迭代很多次，实现复杂了。 追加 ：此处记录下拉格朗日函数的相关性质： 拉格朗日中值定理： 如果函数f(x)满足：（1）在闭区间[a, b]上连续；（2）在开区间[a, b]内可导；那么在开区间(a, b)内至少有一点 使等式 成立。 拉格朗日差值法： 1、两点确定一条直线，这条直线就是线性插值 2、 ，这个$$P_{1}(x)$$函数就是线性插值函数 为了和后面公式进行对比，上面公式可以转化为下面表达式， 这两个都是叫做线性插值的基函数 . 得到的插值效果如下： 线性插值仅仅利用两个节点信息，精确度很低，故接下来讲二次差值(考察曲线问题) 3、拉格朗日二次插值 如果按照线性插值的形式，以每3个相邻点做插值，就得到了二次插值(3个点：xi,xi+1,xi+2)： 得到的曲线效果是： 二次插值在每段二次曲线内是光滑的，但在每条曲线的连接处其光滑性可能甚至比线性插值还差。二次插值只适合3个节点的情形，当节点数超过3个时，就需要分段插值了。 4、拉格朗日多项式插值 一个n次的拉格朗日插值函数可以绘制经过(n+1)个节点的曲线，但运算量非常大。而且在次数比较高时，容易产生剧烈的震荡（龙格现象）。所以要选择位置特殊的节点（比如切比雪夫多项式的零点）进行插值，或使用多个次数较低的拉格朗日函数分段插值。（关于拉格朗日多项式和龙格现象，详见维基百科链接） 使用4次拉格朗日多项式分段插值： 如果直接使用20次的拉格朗日插值，得到的图像如下： 等，更多的插值，[请参考这里] 数值分析（拟合、插值和逼近）之数据插值方法（线性插值、二次插值、Cubic插值、埃米尔特、拉格朗日多项式插值、牛顿插值、样条插值 参考地址1参考地址2参考地址3]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>最大熵模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.6 递归算法与迭代算法]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-6-%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%B8%8E%E8%BF%AD%E4%BB%A3%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[摘要本文主要记录迭代算法的相关笔记 Edit By Porter, 积水成渊,蛟龙生焉。 一、引入实例举个例子(引用)我想求1+2+3+4+..+100的值。 迭代的做法： 从1到100，顺着往下累加。1+2=3,3+3=6,6+4=10,10+5=15……程序表示 1234int i=1,sum=0;while(i&lt;=100)&#123; sum = sum +i; &#125; 递归的做法： 我要求1到100的累加值，如果我已经得到1到99的累加值，将这个值加上100就是1到100的累加值； 要得到1到99的累加值，如果已经得到1到98的累加值，将这个值加上99，就是1到99的累加值…… 最后我要得到1到2的累加值，我如果得到1自身累加值，再加上2即可，1自身的累加值显然就是1了。 于是现在我们得到了1到2的累加值，将这个值加3就得到了1到3的累加值，……最后直到得到1到100的累加值。 程序表示，其中函数会调用自身，这就是递归方法的典型特征 12345int GetSum(int n)&#123; if(n&lt;=0) return 0; else return n+GetSum(n-1);&#125; 上述例子中，其实递归最后得到结果也是用迭代方法完成的，只是在程序的处理上直观看不出来。 两者都能很好的完成计算任务，不同之处在于思维方式上，从而导致不同的计算方法： 迭代是正向思维，从头到尾思考问题； 递归是逆向思维，他假设我们已经得到了部分结果(假设我已经知道了1到99的累加值，把这个值加上100我们就得到了1到100的累加值了)，从尾部追溯到头部，从而让问题简化(当然这个例子中看不出来，这里只是方便理解）]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>迭代算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prioritized Experience Replay]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-8-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0-%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE%2F</url>
    <content type="text"><![CDATA[摘要 创新点：在抽取经验池中过往经验样本时，采取按优先级抽取的方法 改进：同上 改进原因： 原来随机抽取经验忽略了经验之间的重要程度，实际上如人脑中一定会有更为重要的记忆 带来益处：使得算法更快收敛，效果更好 经验回放使得在线强化学习的agent能够记住和重新利用过去的经验，在以往的研究中，过去的经验（transition，经验池中的一条记录，表示为元祖形式，包含state，action，reward,discount factor,next state），只是通过均匀采样来获取。然而这种方法，只要原来有过这个经验，那么就跟别的经验以相同的概率会被再次利用，忽略了这些经验各自的重要程度。 本文我们提出了一种优先回放结构，这种方法可以使重要的经验被回放的概率大，从而使学习变得更有效率。 Edit By Porter, 积水成渊,蛟龙生焉。 论文笔记7：Prioritized Experience Replay]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Prioritized Experience Replay]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-8-%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%9B%9E%E6%94%BE%2F</url>
    <content type="text"><![CDATA[摘要 创新点：在抽取经验池中过往经验样本时，采取按优先级抽取的方法 改进：同上 改进原因： 原来随机抽取经验忽略了经验之间的重要程度，实际上如人脑中一定会有更为重要的记忆 带来益处：使得算法更快收敛，效果更好 经验回放使得在线强化学习的agent能够记住和重新利用过去的经验，在以往的研究中，过去的经验（transition，经验池中的一条记录，表示为元祖形式，包含state，action，reward,discount factor,next state），只是通过均匀采样来获取。然而这种方法，只要原来有过这个经验，那么就跟别的经验以相同的概率会被再次利用，忽略了这些经验各自的重要程度。 本文我们提出了一种优先回放结构，这种方法可以使重要的经验被回放的概率大，从而使学习变得更有效率。 Edit By Porter, 积水成渊,蛟龙生焉。 论文笔记7：Prioritized Experience Replay]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>Algorithm</tag>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1 马尔科夫简单模型预测实战笔记]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-1-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍马尔科夫相关实际应用搞得入门例子，很简单，但是能说明马尔科夫的原理相关。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 马尔科夫简单模型预测实战笔记一、基于马尔可夫链的公交停靠站乘客数预测1.1 题设 假设站点乘客数的状态具有马尔可夫性，当某一时刻有公交车停靠时， 会有一些乘客上车， 则下一时刻车辆到达时停靠站的乘客数与这一时刻剩余的乘客相关， 这一特征符合了马尔可夫链的马尔可夫性，同时在任意时刻的候车乘客只与上一时刻的乘客数相关， 而与候车时间无关。—-满足马尔科夫。 数据 以该停靠站点的候车乘客数为统计对象， 按照离散时间， 在状态转移中将以时间间隔为五分钟而对停靠站点的乘客数进行计数。以工作日某一天的上午8∶ 00 ～ 10∶ 00 的两小时为统计的时间段， 其中第一组数据为时刻 8∶05 时的乘客数， 可得到 24 组数据。如下图所示： 图1-1 8-10点的24组数据 由表 1 可知， 该站点的乘客数区间为［12， 27］，为保证预测的准确性， 根据建模步骤可将站点的乘客数分为 3 种状态， 即状态空间为( E1， E2， E3 ) ， 其中 E1 表示乘客数为 11 ～ 16， E2 表示乘客数为 17 ～22， E3 表示乘客数为 23 ～ 28， 因此有乘客数状态空间的频数分布， 如表 2 所示。 于是得到对应上表的如下状态分布表 表二 时间点 乘客人数 时间表 乘客人数 时间表 乘客人数 时间表 乘客人数 1 E1 7 E2 13 E1 9 E2 2 E1 8 E3 14 E2 20 E1 3 E2 9 E2 15 E2 21 E1 4 E2 10 E2 16 E3 22 E1 5 E2 11 E1 17 E3 22 E1 6 E2 12 E2 18 E2 24 E1 于是可以得到状态转移频次表如下表所示： 表三 单位(人) E1 E2 E3 E1 5 3 0 E2 3 7 2 E3 0 2 1 1.2 计算模型根据马尔可夫变量的特征， 结合变量状态转移概率矩阵， 对站点乘客数的预测步骤如下: 统计时需注意: 引起乘客数状态变化的转入包括下车后仍留在站点候车的乘客; 引起乘客数状态变化的转出则包括经过停靠车辆后上车的乘客， 则有表 1。 由表二可统计得到如下信息： E1 E2 E3 当前统计总数(人) 8 12 3 由此可得到表三对应的转移概率矩阵，如下 转移概率 E1 E2 E3 E1 5/8 3/8 0/8 E2 3/12 7/12 2/12 E3 0/3 2/3 1/3 即： 转移概率 E1 E2 E3 E1 0.625 0.375 0 E2 0.25 0.58 0.17 E3 0 0.67 0.33 设初始时刻的状态分布为10点的时刻。由于10点出行人数是14人，在E1(11~16)之间，故设出事时刻的概率分布为: N(0)=(1, 0, 0) 由N(1)=N(0).*P(1)=(0.625, 0.375, 0) 12345678910111213import numpy as npdef markov(): init_array = np.array([1, 0, 0]) transfer_matrix = np.array([[0.625, 0.375, 0], [0.25, 0.58, 0.17], [0, 0.67, 0.33]]) restmp = init_array for i in range(25): res = np.dot(restmp, transfer_matrix) print('N(',i+1,')', "\t", res ) restmp = res markov() N(0), 代表10：00的乘客数。N(1)代表10:05分的乘客数.N(2)代表10:10分的乘客数，以此类推。 取上面设定的状态范围（11~16）， （17-22）， （18~28），分别对上面的取值区间做中值得到13.5， 19.5， 25.5； 设 E1=13.5, E2=19.5, E3=25.5. 由10:05分的站点乘客数量状态分布，N(1)=[0.625, 0.375, 0],和E=[13.5, 19.5, 25.5]可求得10:05的期望值Ex $$E_{x}=\sum_{i=1}^{3} (N(1,i)*E(i)) = 0.625\times 13.5 + 0.375\times19.5 + 0\times25.5 = 15.75$$ 在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。 即，在10:05的时刻，车站人数最可能有15.75个人在等车。 同理在10:10分，N(2)=[0.484375, 0.451875, 0.06375], 则此时刻（10:05），车站最可能（该时刻的期望值）出现的候车人数经计算为： 16.7503125（人），具体计算过程如下： $$E_{x}=\sum_{i=1}^{3} (N(1,i)*E(i)) = 0.484375\times 13.5 + 0.451875\times19.5 + 0.06375\times25.5 = 16.7503125$$ 推荐下在线Latex公式编辑网站 10:15时刻，10:20时刻，10:25时刻，……计算方法一次类推，于是可得到整个时间段站台候车人数的预测表，如下表： 时刻 状态 转移率 站台乘客数预测值 站台人数实际值 E1 0.625 — — 10:05 E2 0.375 15.75 14 E3 0 — — — — — — — E1 0.484375 — — 10:10 E2 0.50358792 16.7503125 16 E3 0.09785625 — — — — — — — E1 0.38142461 — — 10:15 E2 0.50358792 17.90137716 17 E3 0.11498747 — — — — — — — E1 0.36428736 — — 10:20 E2 0.51215683 18.0556107 18 E3 0.12355581 — — — — — — — E1 0.35571881 — — 10:25 E2 0.51644111 18.13272762 18 E3 0.12784008 — — — — — — — E1 0.35143453 — — 10:30 E2 0.51858325 18.17128614 18 E3 0.12998222 — — 以上的基于马尔科夫的模型预测和实际值的趋势图如下图所示： 图像在线生成：推荐下在线绘图做表的网站 预测结果表明在马尔可夫链理论下的预测会受到时间长短的影响， 在短时间内的统计， 预测结果与实际值间的误差较为明显， 当统计量足够多时， 预测的趋势会更加符合实际情况。 C-K方程( Chapman- Kolmogorov方程)-马尔可夫链定义如下: 参考文献：[1]刘哲华.基于马尔可夫链的公交停靠站乘客数预测[J].黑龙江交通科技,2018,41(11):155-157. 二、最佳经营策略应用]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>马尔科夫模型实战</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1 马尔科夫链]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍马尔科夫相关的性质和几个实例进行论述。状态空间中经过从一个状态到另一个状态的转换的随机过程，需要具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作马尔可夫性质。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 马尔科夫链一、常见的马尔可夫过程：(1) 独立随机过程为马尔可夫过程。 (2) 独立增量过程为马尔可夫过程：没{X(t)，t∈[0，+∞)}为一独立增量过程，且有P(X(0)=x0)=1，x0为常数，则X(t)为马尔可夫过程。 (3) 泊松过程为马尔可夫过程。 (4) 维纳过程为马尔可夫过程。 (5) 质点随机游动过程为马尔可夫过程。 二、模型的创立条件 无后效性—只与前一时刻状态相关和其他历史时刻无关。 图2-1 马尔科夫表示式 系统平稳性—平稳分布（马尔可夫链的）具有某种不变（或者说平稳）性质的概率分布。 图2-2 马尔科夫平稳分布表示式 2.1 无后效性状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作马尔可夫性质。马尔科夫链作为实际过程的统计模型具有许多应用。 在马尔可夫链的每一步，系统根据概率分布，可以从一个状态变到另一个状态，也可以保持当前状态。状态的改变叫做转移，与不同的状态改变相关的概率叫做转移概率。随机漫步就是马尔可夫链的例子。随机漫步中每一步的状态是在图形中的点，每一步可以移动到任何一个相邻的点，在这里移动到每一个点的概率都是相同的（无论之前漫步路径是如何的）。 作者：bitcarmanlee来源：CSDN原文：https://blog.csdn.net/bitcarmanlee/article/details/82819860版权声明：本文为博主原创文章，转载请附上博文链接！ 2.2 平稳分布概念 平稳分布是一种概率分布。平稳分布（马尔可夫链的）具有某种不变（或者说平稳）性质的概率分布。 图2-3 平稳分布，百度百科解释 三、马尔科夫相关的例子直接看理论是有点头痛的，但是接下来直接上例子，学习致用，在应用中学习。 3.1 马尔科夫股市模型实例假设股市三种状态：牛市（Bull market）, 熊市（Bear market）和横盘（Stagnant market），每一个状态都以一定的概率转化到下一个状态。 3.1 题设 图3-1 股市概率转移状态图 比如，牛市以0.025的概率转化到横盘的状态。这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i, j)的值为P(j|i)， 即从状态i变为状态j的概率 。另外定义牛市、熊市、横盘的状态分别为0、1、2，这样我们得到了马尔科夫链模型的状态转移矩阵为： 图3-2 马尔科夫状态转移概率矩阵 当这个状态转移矩阵P确定以后，整个股市模型就已经确定！ 3.1.1 用计算结果说明马尔科夫的性质（无后效性，和系统平稳性） 步骤一、假设初始状态：t0​=[0.1,0.2,0.7]，然后算之后的状态。 步骤二、计算方法是用这个初始的状态分布概率向量(t0)点乘我们的马尔科夫状态转移概率矩阵(P)。 如图2-2 所说的，当P^n –&gt; 会趋向一个稳定的转移概率矩阵。 Python 代码验证： 1234567891011import numpy as npdef markov(): init_array = np.array([0.1, 0.2, 0.7]) transfer_matrix = np.array([[0.9, 0.075, 0.025], [0.15, 0.8, 0.05], [0.25, 0.25, 0.5]]) restmp = init_array for i in range(25): res = np.dot(restmp, transfer_matrix) print i, "\t", res restmp = res markov() 执行以上代码后，输出结果，如图所示 图3-3 马尔科夫股市代码输出 从第18次开始，状态就开始收敛至[0.624,0.312,0.0625]。最终数字上略有不同，只是计算机浮点数运算造成的罢了。 如果我们换一个初始状态t0​，比如[0.2,0.3.0.5]，继续运行上面的代码，只是将init_array变一下，最后结果为： 到第18次的时候，又收敛到了[0.624,0.312,0.0625]!这个转移矩阵就厉害了。不管我们的初始状态是什么样子的，只要状态转移矩阵不发生变化，当n→∞时，最终状态始终会收敛到一个固定值。 3.1.2 后续接着代码验证 图2-2 马尔科夫平稳分布表示式（3点）我们也看看这个状态转移矩阵P的25(本是n-&gt;∞幂次方) 幂次方有什么有意思的地方？ 12345678910def matrixpower(): transfer_matrix = np.array([[0.9, 0.075, 0.025], [0.15, 0.8, 0.05], [0.25, 0.25, 0.5]]) restmp = transfer_matrix for i in range(25): res = np.dot(restmp, transfer_matrix) print i, "\t", res restmp = res matrixpower() 执行以上代码 发现了，从第20次开始，结果开始收敛，并且每一行都为[0.625,0.312,0.0625]! 再次验证了图2.2的定理0.4.2的 3.2 马尔科夫的人类上中下阶层分布模型假设，社会学家把人按其经济状况分为3类：下层，中层，上层，我们用1,2,3表示这三个阶层。社会学家发现决定一个人的收入阶层最重要的因素就是其父母的收入阶层。如果一个人的收入属于下层类别，则它的孩子属于下层收入的概率为0.65，属于中层收入的概率为0.28，属于上层收入的概率为0.07。从父代到子代，收入阶层转移概率如下 我们用P表示这个转移矩阵，则 假设第1代人的阶层比例为 则前10代人的阶层分布如下 第二代人是第一代任PI0，点乘以P（转移概率），第三代人是第二代人点乘以P 我们可以看到，在相同的转移矩阵作用下，状态变化最终会趋于平稳。对于第n代人的阶层分布，我们有 从表达式上我们可以看到，π是一维向量，P是两维矩阵，P进行足够多次自乘后，值趋于稳定。 3.2.1 马尔科夫的人类农村转城市人口分布模型假设城市化进程中，农村人转移为城市人的概率为0.5，城市人转移为农村人的概率为0.1。 人口 农村人 城市人 农村人 0.5 0.5 城市人 0.1 0.9 假设一开始有100个农村人，0个城市人，每代转移人数矩阵如下 代数 农村人 城市人 农村人转移为城市人 城市人转移为农村人 1 100 0 50 0 2 50 50 25 5 3 30 70 15 7 4 22 78 11 8 5 19 81 10 8 6 17 83 8 8 7 17 83 8 8 可以看到，城市化进程中马尔科夫平稳状态就是农村人转移为城市人的速度等于城市人转移为农村人的速度。对于上述转移矩阵P，平稳分布为农村人17%，城市人83%。如果我们可以得到当前中国城市化转移矩阵P，我们就可以算出中国最终城市化率大概为多少（这里不考虑P的变化）。同时如果我们知道了中国城市化人口比例，我们就能知道城市化进程还可以持续多少代人。 3.3 车站候车人数预测模型具体的实例过程请移步 [2.1.1 马尔科夫简单模型预测实战笔记] 章节部分 四、总结4.1 马尔科夫的平稳随机性 非周期马氏链：马氏链转移要收敛，就一定不能是周期性的。不做特别处理，我们处理的问题基本上都是非周期性的 存在概率转移矩阵P，任意两个状态是连通的，如上，例题中的每个不同的阶层人的角色通过某种方式，他们之间是可以相互转化，前后转化的两种状态是联通的可以转化的，底层人士可以转化成中层等。 不论初始状态是什么，经过足够多次概率转移后，会存在一个稳定的状态π。概率转移矩阵自乘足够多次后，每行值相等。即 显然，由于马氏链稳定后，所有状态转移到状态j的概率之和稳定。 则π为马氏链稳定状态，并且π是方程π=πP的唯一非负解。结合上面结论，很明显。]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>马尔科夫模型实战</tag>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计基础笔记]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要 网页效果图设计，可以Fireworks,也可以Photoshop以及其他的平面设计软件 根据网页效果图进行切图 为什么要切图：提高网站下载速率，规律：能用CSS效果表现出来的就少用图像，也是为了提高下载速率]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的方法，获取在线付费设计log的方法]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%B6%8A%E8%BF%87%E4%BB%98%E8%B4%B9%E8%8E%B7%E5%8F%96%E5%9C%A8%E7%BA%BF%E7%9A%84log%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要有时人穷则需要志坚，花别人返工心情的时间，做别人不愿做的尝试。 今天的目标对象是他：Log设计网 不是我不支持他，而是因为，太穷，没那么多钱钱，用到啥买啥，所以，看能省钱的地方就省了吧。 本文档是教如何免费获取99元套餐的log设计资源。 点击进入Log官网的个人中心 选择你目前编辑的Log 点击页面的分享 在浏览页面中鼠标右键，进入inspect界面 点击Source 查看源码 搜索关键字“jpg” 复制图片链接，下载，好了，这就是你自己的Log了 以上步骤结束，不贴图了，贴图影响不好了]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中忽略提交项]]></title>
    <url>%2F%E9%99%84%E5%BD%95-gitignre-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要：本文记录了git的忽略提交的git规则配置，及一些举例。 参考博客资料 在Git项目中定义.gitignore文件对于经常使用Git的朋友来说，.gitignore配置一定不会陌生。这种方式通过在项目的某个文件夹下定义.gitignore文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。.gitignore 文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。在.gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如： 123*.log*.temp/vendor 在Git项目的设置中指定排除文件这种方式只是临时指定该项目的行为，需要编辑当前项目下的 .git/info/exclude文件，然后将需要忽略提交的文件写入其中。需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。 定义Git全局的 .gitignore 文件除了可以在项目中定义 .gitignore 文件外，还可以设置全局的git .gitignore文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置Git： 1# git config --global core.excludesfile ~/.gitignore 首先要强调一点，这个文件的完整文件名就是”.gitignore”，注意最前面有个“.”。一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。实际项目中，很多文件都是不需要版本管理的，比如Python的.pyc文件和一些包含密码的配置文件等等。这个文件的内容是一些规则，Git会根据这些规则来判断是否将文件添加到版本控制中。 Git忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件的使用方法 首先，在你的工作区新建一个名称为.gitignore的文件。 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。 有时对于git项目下的某些文件，我们不需要纳入版本控制，比如日志文件或者IDE的配置文件，此时可以在项目的根目录下建立一个隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件），然后在.gitignore中写入需要忽略的文件。 1234[root@kevin ~]# cat .gitignore*.xml*.log*.apk .gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。 .gitignore配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。 .gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）： 1）从命令行中读取可用的忽略规则 2）当前目录定义的规则 3）父级目录定义的规则，依次递推 4）$GIT_DIR/info/exclude 文件中定义的规则 5）core.excludesfile中定义的全局规则 .gitignore忽略规则的匹配语法在 .gitignore 文件中，每一行的忽略规则的语法如下：1）空格不匹配任意文件，可作为分隔符，可用反斜杠转义2）以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。3）可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。4）以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。5）以星号”*”通配多个字符，即匹配多个任意字符；使用两个星号”“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。6）以问号”?”通配单个字符，即匹配一个任意字符；7）以方括号”[]”包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。8）以叹号”!”表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。 需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； .gitignore忽略规则简单说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 表示忽略根目录下的bin文件/*.c: 表示忽略cat.c，不忽略 build/cat.cdebug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件/mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 温馨提示： 如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一单push，处理起来会非常麻烦。 .gitignore忽略规则常用示例1）示例 比如你的项目是java项目，.java文件编译后会生成.class文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用github的.gitignore文件模板将这些忽略文件信息复制到你的.gitignore文件中去： 1234567891011121314151617181920212223# Compiled class file*.class # Log file*.log # BlueJ files*.ctxt # Mobile Tools for Java (J2ME).mtj.tmp/ # Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid* 可以看到github为我们提供了最流行的.gitignore文件配置。保存.ignore文件后我们查看下git status，检查下是否还有我们不需要的文件会被添加到git中去：123456789101112131415$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.java Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) Config.ini 比如我的项目目录下有一个Config.ini文件，这个是个本地配置文件我不希望上传到git中去，我们可以在gitignore文件中添加这样的配置：1Config.ini 或者你想忽略所有的.ini文件你可以这样写：1*.ini 如果有些文件已经被你忽略了，当你使用git add时是无法添加的，比如我忽略了*.class，现在我想把HelloWorld.class添加到git中去：1234$ git add HelloWorld.classThe following paths are ignored by one of your .gitignore files:HelloWorld.classUse -f if you really want to add them. git会提示我们这个文件已经被我们忽略了，需要加上-f参数才能强制添加到git中去：1234567891011$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.class new file: HelloWorld.java 这样就能强制添加到缓存中去了。如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用rm命令将其从中移除：12$ git rm HelloWorld.class --cachedrm 'HelloWorld.class' 如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。 2）示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657下面是曾经线上使用过的一个gerrit里项目代码的.gitignore的配置（在项目中添加.gitignore过滤文件，在git push到gerrit里即可）[wangshibo@gerrit-server hq_ios]$ cat .gitignore#Built application files*.apk*.ap_ # Files for the Dalvik VM*.dex # Java class files*.class # Generated files*/bin/*/gen/*/out/ # Gradle files.gradle/build/*/build/gradlewgradlew.bat # Local configuration file (sdk path, etc)local.properties # Proguard folder generated by Eclipseproguard/ # Log Files*.log # Android Studio Navigation editor temp files.navigation/ # Android Studio captures foldercaptures/ # Intellij*.iml*/*.iml # Keystore files#*.jks#gradle wrappergradle/ #some local files*/.settings/*/.DS_Store.DS_Store*/.idea/.idea/gradlewgradlew.batunused.txt 3）示例123456789101112131415161718192021222324252627[wangshibo@gerrit-server hq_ios$ cat .gitignore# Lines that start with '#' are comments.# IntelliJ IDEA Project files.idea*.iml*.ipr*.iwsout # Eclipse Project files.classpath.project.settings/ bin/gen/local.properties .DS_StoreThumbs.db *.bak*.tem*.temp#.swp*.*~~*.* .gitignor忽略规则查看如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：12$ git check-ignore -v HelloWorld.class.gitignore:1:*.class HelloWorld.class 可以看到HelloWorld.class匹配到了我们的第一条*.class的忽略规则所以文件被忽略了。 简单来说，要实现过滤掉Git里不想上传的文件，如上介绍三种方法能达到这种目的，只不过适用情景不一样：12345678910111213141516171819202122232425262728293031323334353637383940414243============第一种方法===========针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。 配置步骤如下：在工程根目录下建立.gitignore文件，将要排除的文件或目录 写到.gitignore这个文件中，其中有两种写入方法： a)使用命令行增加排除文件排除以.class结尾的文件 echo "*.class" &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore的文件。排除bin目录下的文件 echo "bin/" &gt;.gitignore b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个，例如：*.class*.apkbin/gen/.settings/proguard/ ===========第二种方法===========全局设置排除文件，这会在全局起作用，只要是Git管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。配置步骤如下：a）像方法（1）一样，也需要建立一个.gitignore文件，把要排除的文件写进去。b）但在这里，我们不规定一定要把.gitnore文件放到某个工程下面，而是任何地方，比如我们这里放到了Git默认的Home路径下，比如：/home/wangshibo/hqsb_iosc）使用命令方式可以配置全局排除文件: # git config --global core.excludesfile ~/.gitignore 你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore。 说明Git把文件过滤规则应用到了Global的规则中。 ===========第三种方法===========单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去：*.class*.apkbin/gen/.settings/proguard/ 这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法一和方法二比较起来没有一点优势。 Git忽略规则(.gitignore配置）不生效原因和解决12345678910111213141516171819第一种方法:.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。 解决方法: git清除本地缓存（改变成未track状态），然后再提交:[root@kevin ~]# git rm -r --cached .[root@kevin ~]# git add .[root@kevin ~]# git commit -m 'update .gitignore'[root@kevin ~]# git push -u origin master 需要特别注意的是：1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件， 对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 第二种方法:（推荐）在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。[root@kevin ~]# git update-index --assume-unchanged PATH //在PATH处输入要忽略的文件 在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。这时候不可以直接使用”git rm directory”，这样会删除本地仓库的文件。可以使用”git rm -r –cached directory”来删除缓冲，然后进行”commit”和”push”，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用”git add -A”来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。 额外说明：git库所在的文件夹中的文件大致有4种状态 123456789101112131415161718Untracked:未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify:文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified:文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态,使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged:暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.执行git reset HEAD filename取消暂存, 文件状态为Modified Git 状态 untracked 和 not staged的区别- [x] 1）untrack 表示是新文件，没有被add过，是为跟踪的意思。- [ ] 2）not staged 表示add过的文件，即跟踪文件，再次修改没有add，就是没有暂存的意思 文献参考来源：https://www.cnblogs.com/kevingrace/p/5690241.html]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得收藏的网站]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要本文主要是收集比较好用的网站。 包括学术，电影，音乐，下载资源，和用的网站 1、 虫部落搜索 2、 虫部落学术 3、 虫部落设计搜索 4、 latexstudio排版学习 5、 短网链生成 wailian suo 6、 盒子部落便民工具系列 7、 艺术字+ 二维码设计 艺术字设计 个性二维码 最终效果： 8、 图床 路过图床 SM.MS图床，生成后每次i.loli.net后缀的名字，更多可以参见百度搜索。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32串口通信配置（USART1+USART2+USART3+UART4）]]></title>
    <url>%2F%E9%99%84%E5%BD%95-STM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要：本文是通过分享几个通用的串口函数，实现对STM32芯片的多个串口操作和多种收发数据方式，实现串口通信的功能，本文的各个驱动代码经测试都可以直接使用，本人写的这部分代码开源 (。^_^。) 一、串口一的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗主函数必须在4s内进行一次喂狗不然系统会复位； 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART1_RX_BUF[21]; u8 USART1_RX_CNT=0;void IWDG_Configuration(void); void Usart1_Init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE);//使能USART1,GPIOA,C时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART1, ENABLE); //使能串口1 &#125;/*** USART1发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART1_Send_Data(u8 *buf,u16 len)&#123; u16 t; GPIO_SetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(USART1,buf[t]); &#125; while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); GPIO_ResetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Usart1_Init(9600);//串口1波特率设置为9600 IWDG_Configuration(); while(1) &#123; IWDG_ReloadCounter();//4s内必须喂狗不然复位 if(USART1_RX_CNT==21)//数据接收完成 &#123; USART1_RX_CNT=0;//指针复位 //将接收到的数据发送出去 USART1_Send_Data(USART1_RX_BUF,21);//通过串口1将接收到的固定长度字符发送出去 &#125; &#125; &#125;/*** 接收指定长度的字符串* 比如接收固定大小为21个字节的字符串**/void USART1_IRQHandler(void) //串口1中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据 if(USART1_RX_CNT&lt;21)//对于接收指定长度的字符串 &#123; USART1_RX_BUF[USART1_RX_CNT]=Res; //记录接收到的值 USART1_RX_CNT++; //接收数据增加1 &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART1,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART1); USART_ClearFlag(USART1,USART_FLAG_ORE); &#125; USART_ClearFlag(UART1,USART_IT_RXNE); //一定要清除接收中断&#125;/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description:配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗 主函数必须在4s内进行一次喂狗不然系统会复位revise Description:===============================================================================*/void IWDG_Configuration(void) &#123; /* 写入0x5555,用于允许狗狗寄存器写入功能 */ IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); /* 狗狗时钟分频,40K/256=156HZ(6.4ms)*/ IWDG_SetPrescaler(IWDG_Prescaler_256); /* 喂狗时间 5s/6.4MS=781 .注意不能大于0xfff*/ IWDG_SetReload(781);//781（5s时间） IWDG_SetReload(3125);//781（20s时间） IWDG_Enable();//启用定时器 IWDG_ReloadCounter();&#125; 二、串口二的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART2_RX_BUF[250]; u8 USART2_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记 void Usart2_Init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; //|RCC_APB2Periph_AFIO RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//使能GPIOA时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能USART2时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,ENABLE);//复位串口2 RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,DISABLE);//停止复位 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //使能串口2中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级2级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级2级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 USART_InitStructure.USART_BaudRate = bound;//波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//8位数据长度 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;///奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART2, &amp;USART_InitStructure); ; //初始化串口 USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启中断 USART_Cmd(USART2, ENABLE); //使能串口 &#125;/*** USART2发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART2_Send_Data(u8 *buf,u16 len)&#123; u16 t; for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); USART_SendData(USART2,buf[t]); &#125; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); &#125;/*** 这也是一个接收函数，可以用，也可以用下面main函数的方法调用* USART2查询接收到的数据* buf:接收缓存首地址* len:读到的数据长度**/void USART2_Receive_Data(u8 *buf)&#123; u8 rxlen=USART2_RX_CNT; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 while(rxlen!=USART2_RX_CNT) &#123; rxlen=USART2_RX_CNT; delay_ms(10); &#125; for(i=0;i&lt;(USART2_RX_CNT);i++) &#123; buf[i] = USART2_RX_BUF[i]; USART2_RX_BUF[i] = 0; &#125; USART2_RX_CNT=0; //清零 &#125;void main(void)&#123; Usart2_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA)//数据接收完成 &#123; USART2_RX_STA=0; //将接收到的数据发送出去 USART2_Send_Data(USART2_RX_BUF,USART2_RX_CNT);//通过串口1将接收到的固定长度字符发送出去 USART2_RX_CNT=0;//指针复位 &#125; &#125; &#125;void USART2_IRQHandler(void)&#123; u8 res; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收到数据 &#123; res =USART_ReceiveData(USART2); //读取接收到的数据 if(USART2_RX_STA==0) &#123; USART2_RX_BUF[USART2_RX_CNT] = res; //记录接收到的值 //当数据结尾收到0xA0和0xA1代表数据接收完成，是一串完整的数据 if(USART2_RX_BUF[USART2_RX_CNT-1]==0xA0&amp;&amp;USART2_RX_BUF[USART2_RX_CNT]==0xA1) USART2_RX_STA=1;//表示接收数据结束 USART2_RX_CNT++; //接收数据增加1 &#125; &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART2); USART_ClearFlag(USART2,USART_FLAG_ORE); &#125; USART_ClearFlag(UART2,USART_IT_RXNE); //一定要清除接收中断 &#125; 三、串口三的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART3_TIMEOUT_Setting 800 //(ms)u8 USART3_RX_BUF[250]; u16 USART3_RX_CNT=0;u16 USART3_RX_TIMEOUT=0; //接收状态标记 void Timer1CountInitial(void);void USART3_Init(u32 baud) &#123; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量，用来初始化GPIO //使能串口的RCC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); //使能UART3所在GPIOB的时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); //串口使用的GPIO口配置 // Configure USART3 Rx (PB.11) as input floating GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); // Configure USART3 Tx (PB.10) as alternate function push-pull GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //配置串口 USART_InitStructure.USART_BaudRate = baud; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // Configure USART3 USART_Init(USART3, &amp;USART_InitStructure);//配置串口3 // Enable USART3 Receive interrupts 使能串口接收中断 USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); // Enable the USART3 USART_Cmd(USART3, ENABLE);//使能串口3 //串口中断配置 //Configure the NVIC Preemption Priority Bits NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // Enable the USART3 Interrupt NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); &#125; void USART3_Sned_Char(u8 temp) &#123; USART_SendData(USART3,(u8)temp); while(USART_GetFlagStatus(USART3,USART_FLAG_TXE)==RESET); &#125;void USART3_Sned_Char_Buff(u8 buf[],u32 len) &#123; u32 i; for(i=0;i&lt;len;i++) USART3_Sned_Char(buf[i]); &#125;void main(void)&#123; Timer1CountInitial(); Usart3_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART3_RX_TIMEOUT==USART3_TIMEOUT_Setting) &#123; USART3_RX_TIMEOUT=0; USART3_Sned_Char_Buff(USART3_RX_BUF,USART3_RX_CNT);//将接收到的数据发送出去 USART3_RX_CNT=0; &#125; &#125; &#125;void USART3_IRQHandler(void) //串口3中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) &#123; USART3_RX_TIMEOUT=0; USART3_RX_BUF[USART3_RX_CNT++] = USART_ReceiveData(USART3); //读取接收到的数据 &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART3,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART3); USART_ClearFlag(USART3,USART_FLAG_ORE); &#125; USART_ClearITPendingBit(USART3, USART_IT_RXNE);&#125;//放到主函数的初始化中初始化void Timer1CountInitial(void)&#123; //定时=36000/72000x2=0.001s=1ms; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; /////////////////////////////////////////////////////////////// RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） TIM_TimeBaseStructure.TIM_Prescaler = 7200-1;//时钟预分频 TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频1 TIM_TimeBaseStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure); TIM_ClearFlag(TIM1,TIM_FLAG_Update); TIM_ITConfig(TIM1,TIM_IT_Update,ENABLE); TIM_Cmd(TIM1, ENABLE);&#125;void TIM1_UP_IRQHandler(void)&#123; //TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） if (TIM_GetITStatus(TIM1, TIM_IT_Update) != RESET) &#123; if(USART3_RX_TIMEOUT&lt;USART3_TIMEOUT_Setting) USART3_RX_TIMEOUT++; &#125; TIM_ClearITPendingBit(TIM1,TIM_IT_Update);&#125; 四、串口四的配置 （初始化+中断配置+中断接收函数） 注意串口四的中断优先级没有贴出来，和前面的三个一样的配置，为了不占用过多的篇幅就不贴中断优先级配置了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART4_TIMEOUT_Setting 800 //(ms)u8 USART4_RX_BUF[250]; u16 USART4_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记void Systick_delay_init(u8 SYSCLK);u8 virtual_delay(u32 num,u8 unit);//通用异步收发器UART4void UART4_Init(u32 bound)&#123; USART_InitTypeDef USART_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //used for USART3 full remap //GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);//for UART4 //Configure RS485_TX_EN PIN GPIO_InitStructure.GPIO_Pin = RS485_TX_EN_PIN; //PC9端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(RS485_TX_EN_PORT, &amp;GPIO_InitStructure); RS485_TX_EN=0; //设置485默认为接收模式 /* Configure USART Tx as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* Configure USART Rx as input floating */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(UART4, &amp;USART_InitStructure); //USART_Init(USART3, &amp;USART_InitStructure); /* Enable the USART */ USART_Cmd(UART4, ENABLE); USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_ClearFlag(UART4,USART_FLAG_TC); &#125;//USART1查询接收到的数据//buf:接收缓存首地址//len:读到的数据长度void UART4_Receive_Data(u8 *buf)&#123; u8 rxlen=21; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 RS485_RX_FLAG = 0; if((UART4_RX_BUF[0]==0x01)&amp;&amp;(UART4_RX_BUF[1]==0x03)) &#123; for(i=0;i&lt;rxlen;i++) &#123; buf[i]=UART4_RX_BUF[i]; UART4_RX_BUF[i] = 0; &#125; RS485_RX_FLAG = 1; &#125; UART4_RX_CNT=0; //清零&#125;//USART1发送len个字节.//buf:发送区首地址//len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)void UART4_Send_Data(u8 *buf,u16 len)&#123; u16 t; RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(UART4,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(UART4,buf[t]); &#125; while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET); RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Systick_delay_init(72); Usart4_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA) &#123; if(virtual_delay(USART4_TIMEOUT_Setting,MS))//超过800ms空闲则可以读取数据 &#123; UART4_Send_Data(UART4_RX_BUF,UART4_RX_CNT); USART2_RX_STA=0; UART4_RX_CNT=0; &#125; &#125; &#125; &#125;void UART4_IRQHandler(void) //UART4 Receive Interrupt &#123; u8 Res; if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(UART4);//(USART1-&gt;DR); //读取接收到的数据 UART4_RX_BUF[UART4_RX_CNT&amp;0XFF]=Res; //回传的数据存入数组,0X3F限制为64个数值 UART4_RX_CNT++; USART2_RX_STA=1; &#125; if( USART_GetITStatus(UART4, USART_IT_TC) == SET ) &#123; USART_ClearFlag(UART4, USART_FLAG_TC); &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(UART4,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(UART4); USART_ClearFlag(UART4,USART_FLAG_ORE); &#125;// USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);//临时关闭接收中断 USART_ClearFlag(UART4,USART_IT_RXNE); //一定要清除接收中断 &#125; //初始化延迟函数//SYSTICK的时钟固定为HCLK时钟的1/8//SYSCLK:系统时钟void Systick_delay_init(u8 SYSCLK)&#123; SysTick-&gt;CTRL&amp;=0xfffffffb;//bit2清空,选择外部时钟 HCLK/8// SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //选择外部时钟 HCLK/8 fac_us=SYSCLK/8; fac_ms=(u16)fac_us*1000;&#125;/*===============================================================================Author:peter panDate: Description: 查询式分时或叫做轮询式（近似延时）。本函数是用于执行高效率场合的查询延时，但是一个for or while 循环中只能用一次。revise Description: @ num : //分时查询的周期计数值 @ unit : //分时查询的周期单位 @@ParaValue ： MS //周期单位为MS毫秒级 US //周期单位为US微秒级@ virtual_delay_status : //静态变量 @@ParaValue ： SET //SYSTICK正在占用中，请勿用 RESET //SYSTICK空闲，可以使用@ReValue : with zero mean Time non-arrive ,one representative Time arrived ,you can do task;##example if(virtual_delay(1000,MS)) LedFlash(); //1000ms LED闪烁一下===============================================================================*/u8 virtual_delay(u32 num,u8 unit)&#123; u32 temp; if(virtual_delay_status==RESET) // SYSTICK空闲，可以使用 &#123; if(unit==MS) &#123; SysTick-&gt;LOAD=(u32)num*Delay_SYSCLK*125;//时间加载(SysTick-&gt;LOAD为24bit) SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125;else if(unit==US) &#123; SysTick-&gt;LOAD=num*Delay_SYSCLK/8; //时间加载 SysTick-&gt;VAL=0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125; virtual_delay_status=SET; return 0; &#125; else &#123; //virtual_delay_status==SET SYSTICK被占用 temp=SysTick-&gt;CTRL; if(!(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16))))//等待时间到达 &#123; SysTick-&gt;CTRL=0x00; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 virtual_delay_status=RESET; return 1; &#125;else return 0; &#125;&#125; 附上本人这篇博客地址]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32复位及通过函数判断是何种条件出发的复位]]></title>
    <url>%2F%E9%99%84%E5%BD%95-STM32%E5%A4%8D%E4%BD%8D%E5%8F%8A%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E6%98%AF%E4%BD%95%E7%A7%8D%E6%9D%A1%E4%BB%B6%E5%87%BA%E5%8F%91%E7%9A%84%E5%A4%8D%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[摘要STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。本文将通过实际的代码来解释各种情况下，软、硬件导致芯片复位的判别和怎样采取措施。 一、系统复位系统复位将复位所有寄存器至它们的复位状态。 当发生以下任一事件时，产生一个系统复位： NRST引脚上的低电平(外部复位) 2. 窗口看门狗计数终止(WWDG复位) 独立看门狗计数终止(IWDG复位) 软件复位(SW复位) 低功耗管理复位 可通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源。软件复位通过将Cortex™-M3中断应用和复位控制寄存器中的SYSRESETREQ位置’1’，可实现软件复位。请参考Cortex™-M3技术参考手册获得进一步信息。 1.1 低功耗管理复位在以下两种情况下可产生低功耗管理复位： 在进入待机模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STDBY位置’1’将使能该复位。这时，即使执行了进入待机模式的过程，系统将被复位而不是进入待机模式。 在进入停止模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STOP位置’1’将使能该复位。这时，即使执行了进入停机模式的过程，系统将被复位而不是进入停机模式。关于用户选择字节的进一步信息，请参考STM32F10xxx闪存编程手册。 电源复位电源复位当以下事件中之一发生时，产生电源复位： 上电/掉电复位(POR/PDR复位) 从待机模式中返回 图4) 电源复位将复位除了备份区域外的所有寄存器。(见图中复位源将最终作用于RESET引脚，并在复位过程中保持低电平。复位入口矢量被固定在地址0x0000_0004。 芯片内部的复位信号会在NRST引脚上输出，脉冲发生器保证每一个(外部或内部)复位源都能有至少20μs的脉冲延时；当NRST引脚被拉低产生外部复位时，它将产生复位脉冲。 三、备份域复位 备份区域拥有两个专门的复位，它们只影响备份区域(见图4)。 当以下事件中之一发生时，产生备份区域复位。 软件复位，备份区域复位可由设置备份域控制寄存器 (RCC_BDCR)(见6.3.9节)中的BDRST位产生。 在VDD和VBAT两者掉电的前提下，VDD或VBAT上电将引发备份区域复位。 四、复位的标志位 五、复位标志位检索/判断什么原因导致的复位标志位判断的代码由官方库中给定代码如下： FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)；//FlagStatus 分为SET和RESET两种； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @brief Checks whether the specified RCC flag is set or not. * @param RCC_FLAG: specifies the flag to check. * * For @b STM32_Connectivity_line_devices, this parameter can be one of the * following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_PLL2RDY: PLL2 clock ready * @arg RCC_FLAG_PLL3RDY: PLL3 clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * For @b other_STM32_devices, this parameter can be one of the following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * @retval The new state of RCC_FLAG (SET or RESET). */FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)&#123; uint32_t tmp = 0; uint32_t statusreg = 0; FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_RCC_FLAG(RCC_FLAG)); /* Get the RCC register index */ tmp = RCC_FLAG &gt;&gt; 5; if (tmp == 1) /* The flag to check is in CR register */ &#123; statusreg = RCC-&gt;CR; &#125; else if (tmp == 2) /* The flag to check is in BDCR register */ &#123; statusreg = RCC-&gt;BDCR; &#125; else /* The flag to check is in CSR register */ &#123; statusreg = RCC-&gt;CSR; &#125; /* Get the flag position */ tmp = RCC_FLAG &amp; FLAG_Mask; if ((statusreg &amp; ((uint32_t)1 &lt;&lt; tmp)) != (uint32_t)RESET) &#123; bitstatus = SET; &#125; else &#123; bitstatus = RESET; &#125; /* Return the flag status */ return bitstatus;&#125; 当然判断完后，我们需要将复位类型的标志置位以防后期出现重复多次判断 void RCC_ClearFlag(void)；//清除复位执行函数 代码原型如下: 12345678910111213141516171819202122232425262728293031/** * @brief Clears the RCC reset flags. * @note The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST, * RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST * @param None * @retval None */void RCC_ClearFlag(void)&#123; /* Set RMVF bit to clear the reset flags */ RCC-&gt;CSR |= CSR_RMVF_Set;&#125;``` * 在使用时，只需要执行如下语句即可：```Cif(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET) &#123; //这是上电复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET) &#123; //这是外部RST管脚复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_SFTRST)!= RESET) &#123; //这是外部RST管脚复位 &#125; RCC_ClearFlag();//清除RCC中复位标志 六、STM32软件复位方法在Cortex-M3权威指南中有这么一句话这里有一个要注意的问题：从SYSRESETREQ 被置为有效，到复位发生器执行复位命令，往往会有一个延时。在此延时期间，处理器仍然可以响应中断请求。但我们的本意往往是要让此次执行到此为止，不要再做任何其它事情了。所以，最好在发出复位请求前，先把FAULTMASK 置位。所以最好在将FAULTMASK 置位才万无一失。 12345void mcuRestart(void)&#123; __set_FAULTMASK(1); //关闭所有中断 NVIC_SystemReset(); //复位｝]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之tkinter入坑Pack]]></title>
    <url>%2F%E9%99%84%E5%BD%95-python%E4%B9%8Btkinter%E5%85%A5%E5%9D%91Pack%2F</url>
    <content type="text"><![CDATA[摘要：python 中写GUI界面还是有很多方法的，下面我就说说这个tkinter吧，感觉刚上手不久，感觉不好用的样子，可能是我自己的原因导致的用不顺手。这篇主要写tkinter的pack（）方法。 tkinter 的pack()可以设置的属性 我从官网帮助手册中看到的是这样 pack_configure(self, cnf={}, **kw)Pack a widget in the parent widget. Use as options: 12345678910111213after=widget - pack it after you have packed widgetanchor=NSEW (or subset) - position widget according to given directionbefore=widget - pack it before you will pack widgetexpand=bool - expand widget if parent size growsfill=NONE or X or Y or BOTH - fill widget if widget growsin=master - use master to contain this widgetin_=master - see 'in' option descriptionipadx=amount - add internal padding in x directionipady=amount - add internal padding in y directionpadx=amount - add padding in x directionpady=amount - add padding in y directionside=TOP or BOTTOM or LEFT or RIGHT - where to add this widget. 上面的部分中文意思是说 12anchor=NSEW,表示设置我们要加的当前部件的位置side=TOP or BOTTOM or LEFT or RIGHT 表示在父类容器的什么地方家我们的部件 上面的界面代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8import tkinter# 导入TK的符号常亮from tkinter.constants import *def sendStr(): print('Data Send Ok!')# 实例化TK类，主窗口必须为.TK(),而其他子窗口为.Toplevel()top = tkinter.Tk()# 设置窗口的尺寸大小top.wm_geometry('320x480+1000+100')# 不允许 改变 窗口的宽和高top.wm_resizable(False,False)# 设置窗口标题top.title('TCP Server')# 设置label标签L1 = tkinter.Label(top, text='TCP Sever;\n20108/09/15', width=15, justify=LEFT, relief=RIDGE, background='#6699ff', )\ .pack_configure(anchor=S, side=TOP, ipady=2, pady=2, fill=NONE)# 设置容器frame1 = tkinter.Frame(top,height=80,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame1.pack(fill=NONE,ipady=2,expand=False)# 添加接收区文字标签L2 = tkinter.Label(frame1,text='接\n收\n区',width=2, justify=LEFT, font=("宋体", 12, "bold"),)\ .pack(padx=2,pady=40,side=LEFT,anchor=N)# 添加接收区的文本框txt1 = tkinter.Text(frame1,width = 40, height = 10).pack(padx=2,pady=10,side=RIGHT,anchor=N)frame2 = tkinter.Frame(top, relief=RIDGE,bg='#3366ff')frame2.pack(fill=X, padx=2,pady=10,side=TOP)# 加一个复选框，一个按键chk_text = 'Hex Display'int_if_choise = tkinter.IntVar()chk1 = tkinter.Checkbutton(frame2,text=chk_text,font=('黑体',12),variable=int_if_choise,onvalue='OK',offvalue='NO')chk1.pack(fill=NONE,side=LEFT,padx=2,pady=10)print('shuchu:',int_if_choise)# 设置容器frame3 = tkinter.Frame(top,height=120,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame3.pack(fill=X,ipady=2,expand=False)# 设置字符串变量ServerReceiveVar = tkinter.StringVar(top,'')L3 = tkinter.Label(frame3, text='Cache&amp;Input:',font=('黑体',12))L3.pack(fill=NONE, expand=NO, side=TOP, anchor=W, padx=2,pady=10)txt2 = tkinter.Text(frame3, height = 2, width = 30).pack(padx=2, pady=2, ipady=4, side=LEFT, anchor=N)button1 = tkinter.Button(frame3,text='Send Str', command=sendStr).pack(side=TOP, anchor=W, padx=2, pady=4)# IP 列表button2 = tkinter.Button(frame3,text="Exit",command=top.destroy).pack(side=TOP, anchor=N, padx=2, pady=10)top.mainloop() 123456789101112from Tkinter import *root = Tk()w = Label(root, text="red", bg="red", fg="white")w.pack(padx=5, pady=10, side=LEFT)w = Label(root, text="green", bg="green", fg="black")w.pack(padx=5, pady=20, side=LEFT)w = Label(root, text="blue", bg="blue", fg="white")w.pack(padx=5, pady=20, side=LEFT)mainloop()]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ MFC 界面实现套接字（socket) 通信]]></title>
    <url>%2F%E9%99%84%E5%BD%95-MFC-Socket-%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[摘要 Socket 套接字的概念 Socket 函数功能 MFC 介绍 TCP 变成步骤 TCP 上位机实现 Socket 套接字的概念引用百度百科的一句话：网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 一段形象的比喻： 建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 Socket的英文原义是“孔”或“插座”。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 SuperSocke,可扩展的 Socket 服务器框架 socket.io github 网页或者官网 Socket 函数功能具体函数如下： socket()函数 bind()函数 connect()函数 listen()函数 accept()函数 send()和recv()函数 sendto()和recvfrom()函数 close()和shutdown()函数 getpeername()函数 gethostname()函数 socket() 函数1int socket(int domine,int type,int protocol); 参数(int domin)： 函数参数，即协议域，又称为协议族。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。通常情况下我们使用AF_INET。 AF_INET的定义是：#define AF_INET 2，所以这里的参数都是int型的 参数(int type)： :是套接口类型，主要SOCK_STREAM(建立TCP连接)、SOCK_DGRAM（建立UDP）、SOCK_RAW；SOCK_STREAM(建立TCP连接)：提供面向连接的可靠的数据传输服务。数据被看作是字节流，无长度限制。例如FTP协议就采用这种。SOCK_DGRAM（建立UDP）：提供无连接的数据传输服务，不保证可靠性。 SOCK_RAW：该接口允许对较低层次协议，如IP，ICMP直接访问。 参数(int protocole)： 指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。通常情况系设为0。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 函数返回值(int): 成功：返回套接字描述符（套接字的索引） 失败：返回-1 bind() 函数一旦你有一个套接字，你可能要将套接字和机器上的一定的端口关联 起来。(如果你想用listen()来侦听一定端口的数据，这是必要一步–MUD 告 诉你说用命令 “telnet x.y.z 6969”。)如果你只想用 connect()，那么这个步 骤没有必要。但是无论如何，请继续读下去。 1int bind(int sockfd, struct sockaddr *my_addr, int addrlen); 参数(int sockfd)： sockfd 是调用 socket 返回的文件描述符。 参数(struct sockaddr *my_addr)： my_addr 是指向数据结构 struct sockaddr 的指针，它保存你的地址(即端口和 IP 地址) 信息。 参数(int addrlen)： addrlen 设置为 sizeof(struct sockaddr)。 connect()函数现在我们假设你是个 telnet 程序。你的用户命令你得到套接字的文件 描述符。你听从命令调用了socket()。下一步，你的用户告诉你通过端口 23(标准 telnet 端口)连接到”132.241.5.10”。你该怎么做呢? 幸运的是，你正在阅读 connect()–如何连接到远程主机这一章。你可 不想让你的用户失望。 1int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 参数(int sockfd)： sockfd 是系统调用 socket() 返回的套接字文件描述符。 参数(struct sockaddr *serv_addr)： serv_addr 是 保存着目的地端口和 IP 地址的数据结构 struct sockaddr。 参数(int addrlen)： addrlen 设置 为 sizeof(struct sockaddr)。 listen()函数是换换内容得时候了。假如你不希望与远程的一个地址相连，或者说， 仅仅是将它踢开，那你就需要等待接入请求并且用各种方法处理它们。处 理过程分两步：首先，你听–listen()，然后，你接受–accept() (请看下面的 内容)。 1int listen(int sockfd, int backlog); 参数(int sockfd)： sockfd 是调用 socket() 返回的套接字文件描述符。 参数(int backlog)： backlog 是在进入 队列中允许的连接数目。 accept()函数send()和recv()函数sendto()和recvfrom()函数close()和shutdown()函数getpeername()函数gethostname()函数本节参考了博文 MFC 介绍TCP 上位机实现]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Socket</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 每次写好后deploy博客]]></title>
    <url>%2F%E9%99%84%E5%BD%95-Hexo-%E6%AF%8F%E6%AC%A1%E5%86%99%E5%A5%BD%E5%90%8Edeploy%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要：github page 结合Hexo-Yelee或者Next主题,搭建个人博客主页，是很不错的一个选择，个人使用情况，感觉Yelee界面布局啥的还是很不错的。 这篇文章中我将介绍每次我们写好的md博文怎么部署到github page 上去。 本文主要使用的命令行如下： 1、直接部署到网站 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 也可以本地部署，查看浏览效果 2、部署到本地，查看浏览效果 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 我们每次写好的博文如何正确推送至github每次我们写好了博文后，需要上传至我们的github空间中,只需要每次将我们写好的博文放到文件路径：1D:\Github\smritipertor.github.io\source\_posts 如果之前没有安装过 hexo-deployer-git 的话，先执行： 1npm install hexo-deployer-git --save 然后执行如下命令操作： 首先在你之前建好的博文路径：比如我的是 12345hexo generatehexo s //(或者:hexo server)hexo deploy //(或者:hexo d) 说明 一般我们在站点根目录中的“_config.yml”中的文件中设定我们hexo d，的部署文件到那个ID和分支中，设置内容如下： 1234deploy: type: git repository: https://github.com/smritipertor/smritipertor.github.io.git branch: master 以上内容表示，不管我们当前工作在那个分区，只要站点根目录中的“_config.yml”中branch 分区设置好，直接 1hexo d 就可以发布了。 如果你执行：1hexo generate -d 常见错误及解决办法第一种，部署出错出现错误提示，如下：1fatal: in unpopulated submodule '.deploy_git' FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: fatal: in unpopulated submodule '.deploy_git' at ChildProcess.&lt;anonymous&gt; (D:\GitWebsite\smritipertor.github.io\node_modules\hexo-util\lib\spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at ChildProcess.cp.emit (D:\GitWebsite\smritipertor.github.io\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:962:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:251:5) 则你可以直接执行以下命令即可： 12rm -rf .deploy_githexo generate -d 即，删除地电脑本地的.deploy_git文件夹（可能是你上个版本是另一台电脑），然后再生成、部署即可。 至此你的网站上就有了网站数据]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr+freenom实现主机域名的绑定]]></title>
    <url>%2F%E9%99%84%E5%BD%95-vultr-freenom%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[vultr+freenom实现主机域名的绑定 摘要本文将通过实例进行演示，给大家介绍如何用免费的域名，绑定我们的云主机，只需要登录Freenom注册个账号就可以免费申请免备案域名了，心动请先不要忙行动，点击阅读更多，先看看本文的免费域名申请绑定主机的方法吧。 1、注册freenom域名 进入 freenom 网站,在界面的菜单中选择“Servers”–&gt;”Register a New Domains”，如下图所示: 可能在此之前需要先注册一个账号，具体网站的账号怎么注册，自己摸索下，并不复杂，这里我们只讲怎么注册域名并解析到你的主机。 接下来在“My Domains”页面上的输入框中输入你想注册的免费域名，并搜索下是否已经被注册了，输入框在如下图中的红框所示，例如我输入：smriti 搜索结果显示，好几个是免费的，我们只需要选择一个就行，如下截图所示： 随便选择一个，“Get it now” 即可比如我选择TK域名，然后进入我的购物车，选择免费12个月，如下图： 接下来在USE DNS处选择自己需要解析到的主机IP地址上，也就是把你的云服务器的主机地址填到下图的红框中，Hostname不要动，保持默认（ 一个是yourdot.tk,另一个是www.yourdot.tk ），如下图： 接下来点击“COntinue”即可。 注意如果你现在没有主机IP，你可以先不填，后期再填写，后期填写只需要进入“My Domains” 选择你注册的域名，点击右边的“Manage Domain”，然后选择第四个菜单，”Manage Freenom DNS”,然后添加域名解析到主机，如下图所示： 接下来就是等待，因为域名解析，不会一下子就解析成功的所以你需要等5-30分钟不等，如果一个小时后还是解析不成功，可能就是你的主机IP填写错误 重要的事情再说一遍，就是以上域名解析填写完成后，还需要进行等待，一般5-30分钟。5分钟内访问该网站可能提示解析错误，所以要等待啊。 有的需要主机上面也要填写DNS绑定域名,比如阿里云主机,但是我这是国外的主机和国外的免费域名，好像不要要云主机上面操作，直接在域名服务商网页上绑定主机IP就成功访问了。 2、主机注册 推荐好用的还便宜的云主机：vultr 、 和 搬瓦工 加入你已经购买了云虚拟主机，点击进入主机管理，如下图所示： 添加主机域名绑定 最后一步，主机中绑定域名，如下图：]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.2 Tensorflow????]]></title>
    <url>%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-3-2-tensorflow%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[?????????&lt;&gt;???????, ???????????????????????????????????tensorflow????1.94? 12345678910Python 3.5.6 |Anaconda, Inc.| (default, Aug 26 2018, 21:41:56) Type 'copyright', 'credits' or 'license' for more informationIPython 6.5.0 -- An enhanced Interactive Python. Type '?' for help.PyDev console: using IPython 6.5.0Python 3.5.6 |Anaconda, Inc.| (default, Aug 26 2018, 21:41:56) [GCC 7.3.0] on linuxIn[2]: import tensorflow as tfIn[3]: tf.__version__Out[3]: '1.9.0' ?????????????????????github??????github?????? Edit By Porter, ????,????? ?????? ??????? ????? ???? ?????? ???? ??????????????????????? ?????????????????????????????????????????AlexNet ???????ILSVRC(ImageNet LargeScale Visual Recongnition Challenge)???. ????????LFW(Labeled Faces in the Wild)?????????????DeepID2 ????99.47%????? ???????????????? ?????????????? ????????? ???????TIMIT????????????????(gaussian mixture model, GMM)?????21.7%?????????????17.9%. ?2012?????????????????????????????????????????20%, ?????? ?????????????????????????????????????????????????????????????????? ???? AlphaGo ?????????????????????????????AlphaGo?????????????????????????????????????????????????DeepMind????????????????????????????2?API ????????????????????????????????????????????????????????????????????????????????????????????????????? TensorFlow?????????tensorflow???? 1234567891011import tensorflow as tfa = tf.constant([1.0, 2.0], name="a")b = tf.constant([2.0, 3.0], name="b")result = a + bsess = tf.Session()sess.run(result)print(a, b, result) ?TensorFlow???????????????????????????????????????????result???????????(session), ??????????(session)?????? TensorFlow??TensorFlow ????TensorFlow???????Tensor?Flow?tensor?????????????????Flow???????????????????????????TensorFlow???????????????????? TensorFlow ??????????????????tensor a?????????a.graph???? tf.get_default_graph???????????123456789101112tf.get_default_graph()Defined in tensorflow/python/framework/ops.py.Returns the default graph for the current thread.The returned graph will be the innermost graph on which a Graph.as_default() context has been entered, or a global default graph if none has been explicitly created.NOTE: The default graph is a property of the current thread. If you create a new thread, and wish to use the default graph in that thread, you must explicitly add a with g.as_default(): in that thread's function.Returns:The default Graph being used in the current thread. ??????????????????????????????? 1print(a.graph is tf.get_default_graph()) ???true???????????????????????? TensorFlow????tf.Grap????????????????????????????????????????????????????? ????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????? tf.Graph?????????,??????????????????tensorflow???????? Class GraphDefined in tensorflow/python/framework/ops.py. A TensorFlow computation, represented as a dataflow graph. A Graph contains a set of tf.Operation objects, which represent units of computation; and tf.Tensor objects, which represent the units of data that flow between operations. A default Graph is always registered, and accessible by calling tf.get_default_graph. To add an operation to the default graph, simply call one of the functions that defines a new Operation: 12c = tf.constant(4.0)assert c.graph is tf.get_default_graph() Another typical usage involves the tf.Graph.as_default context manager, which overrides the current default graph for the lifetime of the context: 12345g = tf.Graph()with g.as_default(): # Define operations and tensors in `g`. c = tf.constant(30.0) assert c.graph is g ???TensorFlow ???12345678910import tensorflow as tfa = tf.constant([1.0,2.0,3.0], name='input_a')b = tf.Variable(tf.random_uniform([3]), name='input_b')add = tf.add_n([a, b], name='addOP')with tf.Session() as sess: sess.run(tf.global_variables_initializer()) writer = tf.summary.FileWriter("./logs", sess.graph) print(sess.run(add))writer.close() ???????????????tensorflow?????? 1tensorboard --logdir=logs –logdir=logs??logs???????????? ????????? 12345porter@porter-Aspire:~/??/????/MNIST$ tensorboard --logdir=logsW0417 10:54:21.140615 Reloader tf_logging.py:120] Found more than one graph event per run, or there was a metagraph containing a graph_def, as well as one or more graph events. Overwriting the graph with the newest event.W0417 10:54:21.153187 Reloader tf_logging.py:120] Found more than one graph event per run, or there was a metagraph containing a graph_def, as well as one or more graph events. Overwriting the graph with the newest event.W0417 10:54:21.153477 Reloader tf_logging.py:120] Found more than one metagraph event per run. Overwriting the metagraph with the newest event.TensorBoard 1.9.0 at http://porter-Aspire:6006 (Press CTRL+C to quit) ??????????http://porter-Aspire:6006??????????????? 什么]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%E9%99%84%E5%BD%95-hello-world%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要欢迎来到我的博文主页，你可以进一步了解我，通过聚水渊主页 Hexo !和我的github 写作目的 为了更好的学习 每天总结 看到自己每天的进步 遇见最优秀的自己，下面是我的其他博客地址 我的博客园 我的CSDN 新浪博客 网易博客 说说我之前的英文名和现在的英文名之前我的firstname 是pertor 现在是porter，不是一个人 ？不，是一个人的，因为pertor是西班牙的名字，porter是英文名字。都是一个人。 我的网易云最后我贴下我的网易笔记]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 中安装sublime_text3]]></title>
    <url>%2F%E9%99%84%E5%BD%95-ubuntu-%E4%B8%AD%E5%AE%89%E8%A3%85sublime-text3%2F</url>
    <content type="text"><![CDATA[摘要Porter PanEnter “Alt+m” will show Markdown Preview 安装 输入注册码 汉化 安装插件 中文输入bug修复 1.1 安装&emsp;&emsp;建议和我一样初学的直接安装，不要直接下载官方的离线包解压了，不然还得自己配置什么dash中显示，什么的环境配置乱七八糟的 123451、 wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -2、 sudo apt-get install apt-transport-https3、 echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list4、 sudo apt-get update5、 sudo apt-get install sublime-text 1.2 输入注册码&emsp;&emsp;在输入注册码之前先更改hosts，ubuntu中hosts位于： vim /etc/hosts或者gedit /etc/hosts,然后加入如下两行 121、 127.0.0.1 www.sublimetext.com2、 127.0.0.1 license.sublimehq.com &emsp;&emsp;然后保存，此时dash中输入sublime，找到我们安装的软件，打开后在界面菜单中选择help–&gt;enter license，然后输入如下注册码12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 点击确定，然后就可以 enjoy it! 在这还没结束，下面开始汉化 1.3 汉化 &emsp;&emsp;打开软件，直接按下“shift+ctrl+p”在弹出的框内输入ip,然后点击”package control：install pakage”,出来后输入”Chinese​Localizations”来安装Chinese​Localizations插件，然后重启，至此汉化结束。 1.4 安装markdown插件 &emsp;&emsp;在软件界面输入“shift+ctrl+p”,然后输入“ip”，然后选择，packageinstall ，然后输入“Markdown Editing“ + ”MarkdownLivePreview”,分别安装上，然后新建md文件，在编辑界面输入“alt+m”,则进入markdown preview实时显示模式。 1.5 解决Markdown不能输入汉字的问题打开终端： 在终端中输入以下代码12git clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix &amp;&amp; ./sublime-imfix 或者直接进入github的这个仓库：直接下载这个zip包，然后解压，然后在终端中cd到这个解压后的文件夹路径中，最后是在终端中输入1./sublime-imfix 此时重启sublimetext3 然后就可以进行汉字的输入了。 参考：https://blog.csdn.net/qq_41590417/article/details/80461075 https://blog.csdn.net/woaidouya123/article/details/81476551 https://www.cnblogs.com/james-lee/p/6847906.html]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>sublime-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1 PyTorch 学习]]></title>
    <url>%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-3-1-PyTorch-%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[摘要本节主要是学习PyTorch相关的学习，主要是基础的学习路线，包括简单的实例笔记等。 Edit By Porter, 积水成渊,蛟龙生焉。 帮助文档见PyTorch官网 一、张量(tensor)和变量(Variable)PyTorch的官方介绍是一个拥有强力GPU加速的张量和动态构建网络的库，其主要构建是张量，所以可以把PyTorch当做Numpy来用，Pytorch的很多操作好比Numpy都是类似的，但是其能够在GPU上运行，所以有着比Numpy快很多倍的速度。 12345678910import torchimport numpy as npnumpy_tensor = np.random.randn(3, 4)pytorch_tensor1 = torch.Tensor(numpy_tensor)pytorch_tensor2 = torch.from_numpy(numpy_tensor)print(pytorch_tensor1)print(pytorch_tensor2) 输出结果： 12345pytorch_tensor1:tensor([[ 1.3511, 0.2016, -0.9728, 0.7997], [-1.0706, -0.0768, -1.3627, -0.8809], [-0.6040, -0.0030, 0.4871, 0.6634]]) 12345pytorch_tensor2:tensor([[ 1.3511, 0.2016, -0.9728, 0.7997], [-1.0706, -0.0768, -1.3627, -0.8809], [-0.6040, -0.0030, 0.4871, 0.6634]], dtype=torch.float64) 使用以上两种方法进行转换的时候，会直接将Numpy ndarray的数据类型转换为对应的Pytorch Tensor数据类型,同时我们也可以使用下面的方法将pytorch tensor转换为numpy ndarray 12345678910111213import torchimport numpy as npnumpy_tensor = np.random.randn(3, 4)pytorch_tensor1 = torch.Tensor(numpy_tensor)pytorch_tensor2 = torch.from_numpy(numpy_tensor)# 如果pytorch tensor在cpu上numpy_array1 = pytorch_tensor1.numpy()numpy_array2 = pytorch_tensor2.cpu().numpy()print(numpy_array1)print(numpy_array2) 1234567891011numpy_array1:[[ 0.9646071 1.0680387 -1.4145772 -1.1733457 ] [ 0.14683424 0.15183815 0.3256755 2.5129247 ] [-1.0027096 0.02551154 -0.60790646 -0.22400694]] numpy_array2:[[-2.09633392 -2.08986247 0.02169762 0.15833546] [ 1.24929483 -1.3953018 1.03153148 -0.06309232] [ 0.24348084 -1.42512446 1.45863934 0.92882537]] 需要注意GPU上的Tensor不能直接转换为Numpy ndarray，需要使用.cpu()先将GPU上的Tensor转到CPU上 PyTorch Tensor 使用GPU加速可以使用下面两种方法将Tensor放到GPU上. 1234567# 第一种方式是定义cuda数据类型dtype = torch.cuda.FloatTensorgpu_tensor = torch.randn(10,20).type(dtype)# 第二种方式更简单，推荐使用gpu_tensor = torch.randn(10,20).cuda(0) # 将tensor放到第一个GPU上gpu_tensor = torch.randn(10,20).cuda(1) # 将tensor放到第二个GPU上 使用第一种方式将tensor放到GPU上的时候会将数据类型转换成定义的类型。 而使用第二种方式能够直接将tensor放到GPU上，类型跟之前保持一致。 推荐在定义tensor的时候就明确数据类型，然后直接使用第二种方法将tensor放到GPU上 我的测试代码： 12345678910111213141516171819202122232425import torchimport numpy as npnumpy_tensor = np.random.randn(3, 4)pytorch_tensor1 = torch.Tensor(numpy_tensor)pytorch_tensor2 = torch.from_numpy(numpy_tensor)# 如果pytorch tensor在cpu上numpy_array1 = pytorch_tensor1.numpy()numpy_array2 = pytorch_tensor2.cpu().numpy()print(numpy_array1)print(numpy_array2)print("输出数据模式1：")# 第一种方式是定义cuda数据类型dtype = torch.cuda.FloatTensorgpu_tensor1 = torch.randn(3,4).type(dtype)print(gpu_tensor1)gpu_tensor2 = torch.randn(3,4).cuda(0) # 将tensor放到第一个GPU上print("输出数据模式2：")print(gpu_tensor2) 二、Torch的数据类型2.1 torch.Tensor torch.Tensor是一种包含单一数据类型元素的多维矩阵。 Torch定义了七种CPU tensor类型和八种GPU tensor类型： Data tyoe CPU tensor GPU tensor 32-bit floating point torch.FloatTensor torch.cuda.FloatTensor 64-bit floating point torch.DoubleTensor torch.cuda.DoubleTensor 16-bit floating point N/A torch.cuda.HalfTensor 8-bit integer (unsigned) torch.ByteTensor torch.cuda.ByteTensor 8-bit integer (signed) torch.CharTensor torch.cuda.CharTensor 16-bit integer (signed) torch.ShortTensor torch.cuda.ShortTensor 32-bit integer (signed) torch.IntTensor torch.cuda.IntTensor 64-bit integer (signed) torch.LongTensor torch.cuda.LongTensor torch.Tensor是默认的tensor类型（torch.FlaotTensor）的简称。 一个张量tensor可以从Python的list或序列构建： 1234&gt;&gt;&gt; torch.FloatTensor([[1, 2, 3], [4, 5, 6]])1 2 34 5 6[torch.FloatTensor of size 2x3] 一个空张量tensor可以通过规定其大小来构建： 1234&gt;&gt;&gt; torch.IntTensor(2, 4).zero_()0 0 0 00 0 0 0[torch.IntTensor of size 2x4] 三、 Torch 的多种数学操作3.1 Torch包torch包含了多维张量的数据结构以及基于其上的多种数学操作。另外，它也提供了多种工具，其中一些可以更有效地对张量和任意类型进行序列化。 它有CUDA 的对应实现，可以在NVIDIA GPU上进行张量运算(计算能力&gt;=2.0)。 3.2 张量 Tensors3.2.1 torch.is_tensor[source]1torch.is_tensor(obj) 如果obj 是一个pytorch张量，则返回True 参数： obj (Object) – 判断对象 3.2.2 torch.is_storage1torch.is_storage(obj) 如何obj 是一个pytorch storage对象，则返回True 参数： input (Object) – 判断对象 3.2.3 torch.set_default_tensor_type[source]1torch.set_default_tensor_type(t) 3.2.4 torch.numel1torch.numel(input)-&gt;int 返回input 张量中的元素个数 例子: 123456&gt;&gt;&gt; a = torch.randn(1,2,3,4,5)&gt;&gt;&gt; torch.numel(a)120&gt;&gt;&gt; a = torch.zeros(4,4)&gt;&gt;&gt; torch.numel(a)16 3.2.5 torch.set_printoptions[source]1torch.set_printoptions(precision=None, threshold=None, edgeitems=None, linewidth=None, profile=None) 设置打印选项。 完全参考自 Numpy。 参数: precision – 浮点数输出的精度位数 (默认为8 ) threshold – 阈值，触发汇总显示而不是完全显示(repr)的数组元素的总数 （默认为1000） edgeitems – 汇总显示中，每维（轴）两端显示的项数（默认值为3） linewidth – 用于插入行间隔的每行字符数（默认为80）。Thresholded matricies will ignore this parameter. profile – pretty打印的完全默认值。 可以覆盖上述所有选项 (默认为short, full) 3.3 创建操作 Creation Ops3.3.1 torch.eye1torch.eye(n, m=None, out=None) 返回一个2维张量，对角线位置全1，其它位置全0 参数: n (int ) – 行数 m (int, optional) – 列数.如果为None,则默认为n out (Tensor, optinal) - Output tensor 返回值: 对角线位置全1，其它位置全0的2维张量 返回值类型: Tensor 例子: 12345&gt;&gt;&gt; torch.eye(3) 1 0 0 0 1 0 0 0 1[torch.FloatTensor of size 3x3] 更多参考Pytorch 文档]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Chrome67版本以后不能离线安装插件的情况]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E8%A7%A3%E5%86%B3Chrome67%E7%89%88%E6%9C%AC%E4%BB%A5%E5%90%8E%E4%B8%8D%E8%83%BD%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要通过本文安装方法可以快速，解决Chrome67版本以后不能离线安装插件的情况。 一般情况下，我们如果使用的Chrome版本为67以后的版本，安装离线插件会出现如下图信息 但是这样我们就真的没法安装离线插件了吗？特别是对想安装翻墙的插件 Proxy SwitchyOmega 的同学来说是一件噩梦。这篇文章讲会告诉读者，这个问题是可以解决的 解决方法如下： 首代开终端输入以下代码 /opt/google/chrome/google-chrome –enable-easy-off-store-extension-install 将会打开google Chrome 浏览器，然后进入浏览器的扩展插件工具界面，如下图所示： 此时请再次将离线下载的插件拖进去，看看是不是能够安装了。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 推送新的文章到github其他分支上]]></title>
    <url>%2F%E9%99%84%E5%BD%95-git-%E6%8E%A8%E9%80%81%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0%E5%88%B0github%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要每次编辑博文并通过命令部署网站到github page上时，我们想每天都能将改动后的博文备份到github的一个分支上，实现本地数据同步到云仓库中。 实现本地博客云同步到github page其他分支上 实现本地博客部署到github page上的master分支上 网站部署（建议隔段时间再部署到网站上，短时间内直接部署本地，本地浏览下就好部署到网上 直接部署到github page的master上 123451 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git pull origin proworking #从我的工作分支更新最新的博文和站点配置文件3 git checkout master #将我们的本地切换到master分支4 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中5 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署到本地 本地部署，本地浏览效果 12341 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git checkout master #将我们的本地切换到master分支3 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中4 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 实现从github上获取我仓库中的Proworking分支数据，病拉取到我的本地 将本地的博文再重新push到我的云仓库（proworking) 123git add .git commit -m "添加了：file1.md\file2.md"git push origin HEAD:proworking #一定要添加HEAD 不然会 其他注意事项 下面贴上我遇到的问题 [1] 若果你直接输入命令：1$ git push proworking 可能会出现如下的不正常信息： 12345678Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push proworkingfatal: 'proworking' does not appear to be a git repositoryfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 正确的解决办法是，命令中输入如下代码（加HEAD) 12Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push origin HEAD:proworking 此时会输出正确的提示，具体提示信息如下： 123456789Enumerating objects: 1498, done.Counting objects: 100% (1480/1480), done.Delta compression using up to 4 threadsCompressing objects: 100% (1219/1219), done.Writing objects: 100% (1461/1461), 1.17 MiB | 390.00 KiB/s, done.Total 1461 (delta 187), reused 1300 (delta 139)remote: Resolving deltas: 100% (187/187), completed with 10 local objects.To https://github.com/smritipertor/smritipertor.github.io.git 06b21dd..1ff56b7 HEAD -&gt; proworking]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索技巧]]></title>
    <url>%2F%E9%99%84%E5%BD%95-%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍百度搜索技巧和google的搜索技巧。 Edit By Porter, 积水成渊,蛟龙生焉。 关于搜索技巧 &copy;date:2017年9月1日 1 百度搜索技巧1.1 高级搜索语法 1.1 英文短语搜索（” ”） 引号中的关键词将作为一个整体在搜索结果中出现。双引号中的词语（比如”like this”） 1.2 指定网域 有一些词后面加上冒号对Google有特殊的含义。其中有一个词是“site:”。要在某个特定的域或站点中进行搜索，可以在Google搜索框“site xxxx.com”。 例如，要在Google 站点上查找新闻，可以输入：新闻site:www.google.com 1.3 查找特定文件 Google已经可以支持13种非HTML文件的搜索:PDF文件、Microsoft Office (doc, ppt, xls, rtf）、Shockwave Flash (swf)PostScript(ps)和其它类型文档。 新的文档类型只要与用户的搜索相关，就会自动显示在搜索结果中。例如，如果您只想查找PDF或Flash 文件，而不要一般网页，只需搜索 “关键词filetype:pdf” 或 “关键词filetype:swf” 就可以了。 1.4 按链接搜索 例如，“link:www.google.com”将找出所有指向Google主页的网页。不能将link:搜索与普通关键词搜索结合使用。 1.5 限定关键词只在标题中 &emsp;&emsp;例如“allintitle：中国苹果”表示“中国”和“苹果”都必须出现在标题中“intitle：中国苹果”表示“中国”必须出现在标题中，“苹果”可以出现在网页的任意位置，可以是标题也可以不是。。 1.6 限定关键词只在URL中 &emsp;&emsp;例如 “allinURL：koko com” 表示 “koko” 和 “com“ 都必须出现在URL中 “inURL：koko com” 表示 “koko” 必须出现在URL中， “com” 可以出现在网页的任意位置，可以是URL也可以不是。。 1.7 Info用来显示与某链接相关的一系列搜索提供cache、link、related和完全包含该链接的网页的功能。 1.8 Related &emsp;&emsp;用来搜索结构内容方面相似的网页例:搜索所有与中文新浪网主页相似的页面(如网易首页，搜狐首页，中华网首页等)，“related:www.sina.com.cn”。.9、Cache用来搜索GOOGLE服务器上某页面的缓存这个功能同“网页快照”，通常用于查找某些已经被删除的死链接网页，相当于使用普通搜索结果页面中的“网页快照”功能。 二、百度（baidu）搜索高级语法2.1 把搜索范围限定在网页标题中——intitle网页标题通常是对网页内容提纲挈领式的归纳。把查询内容范围限定在网页标题中，有时能获得良好的效果。使用的方式，是把查询内容中，特别关键的部分，用“intitle:”领起来。例如，找林青霞的写真，就可以这样查询：写真intitle:林青霞注意，intitle:和后面的关键词之间，不要有空格。 2.2 把搜索范围限定在特定站点中——site有时候，您如果知道某个站点中有自己需要找的东西，就可以把搜索范围限定在这个站点中，提高查询效率。使用的方式，是在查询内容的后面，加上“site:站点域名”。例如，天空网下载软件不错，就可以这样查询：msn site:skycn.com 注意，“site:”后面跟的站点域名，不要带“http://”；另外site:和站点名之间，不要带空格。 2.3 把搜索范围限定在url链接中——inurl网页url中的某些信息，常常有某种有价值的含义。于是，您如果对搜索结果的url做某种限定，就可以获得良好的效果。实现的方式，是用“inurl:”，后跟需要在url中出现的关键词。例如，找关于photoshop的使用技巧，可以这样查询：photoshop inurl:jiqiao 上面这个查询串中的“photoshop”，是可以出现在网页的任何位置，而“jiqiao”则必须出现在网页url中。注意，inurl:语法和后面所跟的关键词，不要有空格。 2.4 精确匹配——双引号和书名号 双引号和书名号如果输入的查询词很长，百度在经过分析后，给出的搜索结果中的查询词，可能是拆分的。如果您对这种情况不满意，可以尝试让百度不拆分查询词。给查询词加上双引号，就可以达到这种效果。 &emsp;&emsp;例如，搜索上海科技大学，如果不加双引号，搜索结果被拆分，效果不是很好，但加引号后，“上海科技大学”，获得的结果就全是符合要求的了。 &emsp;&emsp;书名号是百度独有的一个特殊查询语法。在其他搜索引擎中，书名号会被忽略，而在百度，中文书名号是可被查询的。 &emsp;&emsp;加上书名号的查询词，有两层特殊功能，一是书名号会出现在搜索结果中；二是被书名号扩起来的内容，不会被拆分。书名号在某些情况下特别有效果，例如，查名字很通俗和常用的那些电影或者小说。比如，查电影“手机”，如果不加书名号，很多情况下出来的是通讯工具——手机，而加上书名号后，《手机》结果就都是关于电影方面的了。 2.5 要求搜索结果中不含特定查询词&emsp;&emsp;如果您发现搜索结果中，有某一类网页是您不希望看见的，而且，这些网页都包含特定的关键词，那么用减号语法，就可以去除所有这些含有特定关键词的网页。 &emsp;&emsp;例如，搜神雕侠侣，希望是关于武侠小说方面的内容，却发现很多关于电视剧方面的网页。那么就可以这样查询：神雕侠侣-电视剧。 注意，前一个关键词，和减号之间必须有空格，否则，减号会被当成连字符处理，而失去减号语法功能。减号和后一个关键词之间，有无空格均可。 2.6 专业文档搜索&emsp;&emsp;很多有价值的资料，在互联网上并非是普通的网页，而是以Word、PowerPoint、PDF等格式存在。百度支持对Office文档（包括Word、 Excel、Powerpoint）、Adobe PDF文档、RTF文档进行了全文搜索。要搜索这类文档，很简单，在普通的查询词后面，加一个“filetype：”文档类型限定。“Filetype:”后可以跟以下文件格式：DOC、XLS、PPT、PDF、RTF、ALL。其中，ALL表示搜索所有这些文件类型。例如，查找张五常关于交易费用方面的经济学论文。“交易费用张五常filetype:doc”，点击结果标题，直接下载该文档，也可以点击标题后的“HTML版”快速查看该文档的网页格式内容。]]></content>
      <categories>
        <category>summary</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18 正确 安装ShadowSocket]]></title>
    <url>%2F%E9%99%84%E5%BD%95-ubuntu18-%E6%AD%A3%E7%A1%AE-%E5%AE%89%E8%A3%85ShadowSocket%2F</url>
    <content type="text"><![CDATA[ubuntu18 正确安装shadowsocket 摘要为达到能够自由访问全球学习资料，我可谓是绞尽脑汁莫寻方法，目前能做到的除了付费包月的vpn代理机构的，就只能是自己动手自己干的了，但是自己搞旺旺会出很多问题，本文结合晴子实践的经验，将所遇到的问题都一一列下并解决。 1、正常的安装步骤（ubuntu16版本）1234* Ctrl+Alt+T打开终端，输入以下命令安装好GUI界面shadowsocks-qt5* sudo add-apt-repository ppa:hzwhuang/ss-qt5* sudo apt-get update* sudo apt-get install shadowsocks-qt5 但是Ubuntu18.04在安装shadowsocks-qt5时就会出现错误 1仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有 Release 文件 原因： ppa:hzwhuang/ss-qt5 并没有18.04版本的源 解决方法：第一步、修改sources.list.d下文件名修改/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic（18.04版本代号）改成xenial（16.04版本代号） 第二步、设置如下图 bash 中打开软件更新器 —&gt; 设置 —&gt; 其他软件 –&gt; 编辑：http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu 将发行版改为xenial ,如上图所示。 然后再执行 sudo apt-get update sudo apt-get install shadowsocks-qt5]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python Tkinter 界面实现套接字（socket) 通信]]></title>
    <url>%2F%E9%99%84%E5%BD%95-Python-GUI-Socket%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>GUI</tag>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8 深度学习环境搭建]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.8 深度学习环境搭建，安装CUDA，安装NVIDIA驱动，pytorch，caffe框架等等。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 深度学习环境搭建一、安装CUDA运算平台+NVIDIA驱动这些安装的方法很简单，官方网站有具体的安装过程，这里一步带过 1.1 软件简介1.2 安装步骤二、安装PyTorch2.1 环境简介CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员现在可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。 —-来自百度百科 NVIDIA（纳斯达克股票代码：NVDA）是一家人工智能计算公司 。公司创立于 1993 年，总部位于美国加利福尼亚州圣克拉拉市。Jensen Huang (黄仁勋) 是创始人兼首席执行官。 Ultra：Nvidia的旗舰级产品，为本系列中的最强者。 GTX：其性能介于GTS和Ultra之间。一般为Nvidia首发的高端产品。 GTS：始终为Nvidia第三强的产品(GeForce 2 GTS与GeForce 8800GTS均可展示出来)，性能处于GTX之下，与GT相比有些模糊。 GT：频率提升版本”GeForce Technology”的缩写，频率和管线都较LE GS SE XT有较大的提升 GS：相比GT，渲染管线或者显存位宽的缩减，频率一般在GT之下，并且由于规格限制，性能在GT之下。 LE:”Limit Edition”的缩写，表示限制版本，代表某一产系列中的入门级产品，主要是频率和规格均与标准版本相比有一定的下降。 SE：在Nvidia卡中不常出现，与LE相似。 XT:”Cost Down”表示降频率版本，将标准版的频率降低，部分产品削减了管线。 由于我在笔记本上安装的，是NVIDIA GeForce 系列，所以不介绍其他的了。 配有NVIDIA GeForce 系列GPU的台式电脑和笔记本电脑带给用户无法比拟的性能，明快的照片，高清晰的视频回放，和超真实效果的游戏。GeForce 系列的笔记本GPU还包括先进的耗电管理技术，这种技术可以在不过分耗费电池的前提下保证高性能。 2.2 安装方法CUDA安装方法:linux中打开终端按照下面代码这个过程走完就好了CUDA 平台网站 12345Installation Instructions:`sudo dpkg -i cuda-repo-ubuntu1804-10-0-local-10.0.130-410.48_1.0-1_amd64.deb``sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub``sudo apt-get update``sudo apt-get install cuda` NVIDIA驱动 -[x] Ubuntu装好CUDA之后过段时间提示NVIDIA-SMI has failed because it couldn’t communicate with the NVIDIA driver. 直接进入boot引导界面，选择关闭安全模式即可解决。 2.3 使用说明三、 caffe框架安装]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7 gitbook 插件等相关设置]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-7-gitbook-%E6%8F%92%E4%BB%B6%E7%AD%89%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要本文记录了1.7 gitbook 插件等相关设置，解决gitbook不支持latex公式等问题。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook gitbook 插件等相关配置插件安装配置方法在你gitbook更目录中编辑book.json文件，文件配置好后，不会生效，需要先执行命令 1gitbook install # 安装命令 然后执行如下命令进行编译 1gitbook build Mermaid 图和流程图(甘特图之类的) Mermaid 的 plugins地址, Mermaid 的github地址 安装方法，在book.json加入以下内容，然后gitbook install { “plugins”: [“mermaid”]} graph TD; A–&gt;B; A–&gt;C; B–&gt;D; C–&gt;D; classDiagramClass01 &lt;|– AveryLongClass : CoolClass03 – Class04Class05 o– Class06Class07 .. Class08Class09 –&gt; C2 : Where am i?Class09 – C3Class09 –|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 C2: Cool label 具体使用帮助文档请移步github KaTex为了支持数学公式, 我们可以使用KaTex和MathJax插件, 官网上说Katex速度要快于MathJax 插件地址 123"plugins": [ "katex"] 用法： 1234567891011Inline math: $$\int_&#123;-\infty&#125;^\infty g(x) dx$$Block math:$$\int_&#123;-\infty&#125;^\infty g(x) dx$$Or using the templating syntax:&#123;% math %&#125;\int_&#123;-\infty&#125;^\infty g(x) dx&#123;% endblock %&#125; 安装视屏播放插件chinese-video InstallAdd the below to your book.json file, then run gitbook install : 123&#123; "plugins": ["chinese-video"]&#125; UsageCurrently, This plugin support: BilibiliYoukuIqiyiQQSohuMgtvPPTVThere are each methods which you should use to insert matched website’s video. Tips: [xxx] is optional parameter. You can ignore it but don’t ignore any @.The width x height, which is defined by you, is the largest size of the player and if you have a small screen to look through the page, Page will zoom the player with the scale of your width x height.Bilibilihtml5 https 1&#123;% bilibili %&#125; avCode @ [section] @ [width x height] &#123;% endbilibili %&#125; avCode is bilibili video’s serial number. Just like this: https://www.bilibili.com/video/av 170001 avCode should be a number. Don’t attach “av” to it. section is matched video’s sub video’s serial number. width x height is player’s size. Youkuhtml5 flash https 1&#123;% youku %&#125; videoCode @ [mode] @ [width x height] &#123;% endyouku %&#125; mode is player’s mode. js(html5) or flash. videoCode just like this: https://v.youku.com/v_show/id_ XNDU4MjQ3MzA0 .html width x height is player’s size. Iqiyihtml5 flash https(HTML5 player) http(Flash player) Iqiyi’s parameter just like shit!!! Flash player 1&#123;% iqiyi %&#125; flash @ parameter1 @ video @ albumId @ tvId @ [width x height] &#123;% endiqiyi %&#125; flash is key word. Don’t change it. You only can visit Iqiyi’s video’s Sharing page and copy its HTML to get these parameters. It just like this: 1&#123;% bilibili %&#125; 170001 @ [section] @ [640 x 480] &#123;% endbilibili %&#125;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Gitbook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3.1.2 Pytorch 之MNIST手写字识别分类.md]]></title>
    <url>%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0-3-1-2-Pytorch-%E4%B9%8BMNIST%E6%89%8B%E5%86%99%E5%AD%97%E8%AF%86%E5%88%AB%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[摘要本文记录的是学习Pytorch 之MNIST手写字识别分类过程实现的笔记，包括MNIST分类实现的算法定义和代码实现。 Edit By Porter, 积水成渊,蛟龙生焉。 一、MNISTMNIST数据集是一个关于手写的数字识别的数据集，详见MNIST数据集官网 1.1 数据集介绍 数据集分为4个部分： Training set images: train-images-idx3-ubyte.gz (9.9 MB, 解压后 47 MB, 包含 60,000 个样本) Training set labels: train-labels-idx1-ubyte.gz (29 KB, 解压后 60 KB, 包含 60,000 个标签) Test set images: t10k-images-idx3-ubyte.gz (1.6 MB, 解压后 7.8 MB, 包含 10,000 个样本) Test set labels: t10k-labels-idx1-ubyte.gz (5KB, 解压后 10 KB, 包含 10,000 个标签) MNIST 数据集来自美国国家标准与技术研究所, National Institute of Standards and Technology (NIST). 训练集 (training set) 由来自 250 个不同人手写的数字构成, 其中 50% 是高中学生, 50% 来自人口普查局 (the Census Bureau) 的工作人员. 测试集(test set) 也是同样比例的手写数字数据. 数据集并非-常规的文本文件或者图片文件，值得注意的是，我们下载解压后会发现文件是二进制的文件，如下图所示： MNIST（Mixed National Institute of Standards and Technology database）是一个计算机视觉数据集，它包含70000张手写数字的灰度图片，其中每一张图片包含 28 X 28 个像素点。可以用一个数字数组来表示这张图片： 每一张图片都有对应的标签，也就是图片对应的数字，例如上面这张图片的标签就是 1 数据集被分成两部分： 60000 行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。 其中：60000 行的训练集分拆为 55000 行的训练集和 5000 行的验证集。 60000行的训练数据集是一个形状为 [60000, 784] 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点。（28x28=784）在此张量里的每一个元素，都表示某张图片里的某个像素的强度值，值介于 0 和 1 之间。 1.2]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
        <tag>MNIST</tag>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.6 win10+ubuntu双系统修复ubuntu启动引导]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-6-win10-ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8Dubuntu%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[摘要本文记录了win10+ubuntu双系统修复ubuntu启动引导，解决最新版win10系统的UEFI快速启动带来的双系统安装启动问题（开机引导无法修复的解决方法）。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook win10+ubuntu双系统修复ubuntu启动引导摘要我的环境是：uefi启动模式下的win10 + ubutu18.04，其中win10 安装在 128G固态硬盘上，Ubuntu18.04LTS 安装在1T 机械硬盘上，由于我已安装好的ubuntu18 没有UEFI，但是ubuntu18确实是支持UEFI的，难道我必须要重新安装下ubuntu系统吗？（我ubuntu上好不容易安装好了好多软件，此时内心是崩溃的） 一、啥都不用改的解决办法（有点不推荐） 每次打开电脑后狂按F12按键，会进入Boot引导管理，然后选择你的Ubuntu系统进入即可打开ubuntu，如果你要打开window10 你可以按下开机电源后啥都不做就能进入，或者，也是狂按F12进入Boot管理界面，选择windows。 每次开机都得这么累，所以不推荐 二、先进入Ubuntu 然后执行如下命令（就是安装Ubuntu的引导修复工具软件）1234567$ sudo su# sudo add-apt-repository ppa:yannubuntu/boot-repair# apt-get update# apt-get install boot-repair1.在dash中搜索boot-repair2.点recommand repair 之后会自动执行 执行完以上步骤后会出现如下图所示的信息： 然后重启电脑，然后狂按F2,进入BOOT设置界面，设置UEFI 和 Enable。 接下来设置个Supervisor密码，注意后期退出并保存这个boot配置时，要重新设置这个密码，新密码直接全敲回车（这样代表不设置密码，面对你以后密码忘记了）如下图： 设置密码后，下面灰色的选项就可以用了。此时进入 Select an UEFI file as trust executing ,进入的界面如下图 || || || 接下来，回到Boot设置栏，讲EFI 的Ubuntu 重新排序，排到最高优先级，我这排到了我的windows启动选项的前面的，如果你了解你的windows启动标志，直接放到windows启动选项前也就可以的。 到此设置结束，但是不要忘了，把你之前的Security选项里的密码重新清楚掉哦，就是重新设置新密码，新密码内容设置为回车就好了，下次你要使用就会直接提示你输入新密码。 接下来F10保存并退出。然后启动你的电脑，会直接进入linux的引导界面，还包括了Windows的启动界面选项，这时你想进Ubuntu还是windows都是很好选择的。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>系统引导</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.5 Ubuntu下常用工具软件配置安装]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-5-Ubuntu%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[摘要本文记录了Ubuntu下常用工具软件配置、安装，包括高速下载的工具安装使用，具体安装和介绍见文章内容所述。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook Ubuntu下常用工具软件配置安装 终端打开软件，不占用终端的方法是在命令后面加&amp; 1sudo matlab &amp; 一、安装高速下载工具uGet：是一款图形化界面软件， 支持队列下载和恢复下载的功能。uGet官网aira2：是一个命令行下载工具，使用不方便，需要配合其他图形界面的下载软件使用。其下载原理类似于Windows上的迅雷，通过搜索资源、为己所用，而不是仅仅从原始地址这单一资源处下载。uGet采用aria2作为后端，安装aria2插件后可与其进行交互。支持的下载协议包括：HTTP，HTTPS，FTP，BitTorrent和Metalink。 作者：Geroff来源：CSDN原文：https://blog.csdn.net/fengyulinde/article/details/78309314版权声明：本文为博主原创文章，转载请附上博文链接！ 1.1 安装步骤 安装 uget aria2 123sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt updatesudo apt install uget aria2 1.2卸载 1.如果要移除uGet和aria2，可执行如下命令 1sudo apt-get remove --purge uget aria2 2.移除相应ppa，执行如下步骤 先安装ppa-purge 1sudo apt-get install ppa-purge 接着删除相应ppa 1sudo ppa-purge ppa:plushuang-tw/uget-stable 1.3 uGet设置如图界面选择插件–&gt; aria2即可，更多的帮助请在终端中输入，aria2c -h即可看到。 二、终端相关的配置 终端打开软件，但当软件打开后，不想让终端占用软件的方法 1software &amp; 即在软件的后面加上 &amp; 符号]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.4 Latex 排版使用笔记]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-4-Latex-%E6%8E%92%E7%89%88%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[摘要本文记录了Latex排版相关的语法句法使用，是对latex学习中的一种总结，笔记，具体笔记见文中内容所描述。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook Latex 排版使用笔记一、 简单的介绍 LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 LaTeX 是一款非常优秀的科技论文排版系统，除了编写学术论文、幻灯片、书籍、报告等之外，甚至可以画矢量图。尤其在学术界非常认可，各个主流的学术期刊都提供了相应的 latex 模板。与 word 排版不同，它不是一个所见即所得的编辑器，而是基于许多的规范的 TeX 语法。正是基于此，LaTeX 在使用时可以让作者花更少的时间在文章的格式排版上，而是更关注与内容的编辑。 1.1 TeXLiveTeXLive 是一款经典的官方发布的 TeX 系统，特点是跨平台（Unix、Linux、Windows 操作系统均可）安装，不断有开发人员在维护和更新，解决BUG。缺点是软件仅仅是一个编译系统，与 CTeX 相比缺少了编译器和查看器，需要另外安装； 当然也可以不使用编辑软件，直接使用命令行（command line）或记事本编辑，再使用命令行的指令进行编译（latex、pdflatex、bibtex、dvi2ps 等），一般人当然接受不了（只有极少数程序员会这么做），开发也不方便。 1.2 CTeX CTeX 环境（适合中国人使用的 Chinese TeX 环境）中文套装是基于 Windows 下的 MiKTeX 系统，集成了编辑器 WinEdt 和 PostScript 处理软件 Ghostscript 和 GSview 等主要工具。 CTeX 中文套装在 MiKTeX 的基础上增加了对中文的完整支持。 WinEdt 一款 CTeX 自带的编辑软件，并不是免费的软件，需要（和谐）之后才好使用，否则会不断提示你进行 register。 WinEdt 提供了许多按钮式的数学符号、运算、字母提示，不需要记忆很多命令； 1.3 TexStudio [推荐]TeXstudio 是一款非常精良的 LaTeX 免费开发软件（不包括 TeX 编译环境，需要另外安装 CTeX 或 TeXLive），有着许多实用、便捷的功能： 配置非常简单，基本使用默认的配置即可，个人喜欢修改字体为 Consolas，编译方式 DVI-&gt;PS-&gt;PDF，编码 UTF-8（对中文兼容）、加入英语拼写检查（Spell Check，en_US）； 自带 PDF 查看器，即界面左边为编辑文档，右边显示编译生成的 PDF 文档，在 pdflatex 编译之后，支持对象反查（代码 –&gt; PDF（右键 Go to PDF）、PDF–&gt; 代码（右键 Go to Source））； 代码自动提示，可以自动补全，菜单里含有丰富的命令； 二、Latex基本语法三、Latex 在线参考资料]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3 Ubuntu18 git命令使用总结]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-3-Ubuntu18-git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[摘要本文记录了 Ubuntu18 git命令使用总结，主要包括git的指令使用帮助，本文不是指导如何调试代码和修复代码，具体内容见文中内容所示。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook git 相关命令学习一、git remote 命令用法1.1 git remote 命令用法12345678910111213git remote [-v | --verbose] #不带参数，列出已经存在的远程分支git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…​git remote prune [-n | --dry-run] &lt;name&gt;…​git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] 二、例程代码2.1 例程代码 查看当前的远程库 12345678910111213$ git remote -v origin git://github.com/schacon/ticgit.git如果有多个远程仓库,此命令将全部列出.比如在我的 Grit 项目中,可以看到.$ git remote #不带参数，列出已经存在的远程分支 origin# 如果提示：error: 无法推送一些引用到 'https://github.com/porterpan/gitbook-tutorial.git'# 提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。# 提示：再次推送前，先与远程变更合并（如 'git pull ...'）。详见# 提示：'git push --help' 中的 'Note about fast-forwards' 小节。$ git fetch origin$ git merge origin/mastergit 正常流程 如果都是自己在开发的类，当然优先使用pull-&gt;commit-&gt;push，为什么我更倾向这种方式呢，因为这样会减少Git没有必要的merge。 如果有冲突的情况下，先pull了会出现什么问题呢？如果你的判断失误，在本地修改与远程代码有冲突的情况下，先执行了git-pull，即使是这样也不用担心，git会给你一个错误提示，这时候你再去执行commit-&gt;pull-&gt;push也是没有问题的。 git代理配置git设置代理 代理类型是socks5 12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 代理类型是普通的http/https 12git config --global https.proxy http://127.0.0.1:1080git config --global https.proxy https://127.0.0.1:1080 git取消代理12git config --global --unset http.proxygit config --global --unset https.proxy]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>git命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 Ubuntu18安装Gitbook]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-2-Ubuntu18%E5%AE%89%E8%A3%85Gitbook%2F</url>
    <content type="text"><![CDATA[摘要本文记录了 Ubuntu18安装Gitbook的相关步骤，和某些关键的终点输入指令，本文不是指导如何调试代码和修复代码，本文给出了一种安装的方法，具体修复方法见文中内容所示。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook Ubuntu18 安装Gitbook 记录1. 安装nodejs 进入nodejs官网，选择10.15.0 LTS下面的other Downloads. 然后进入下载界面 解压，开始安装 安装就是直接把解压后的放到你想安装的位置，我们直接解压到 /usr/local路径中。这就安装好了，不需要运行，直接执行下面步骤。 1sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/node /usr/local/bin/node sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/npm /usr/local/bin/npm 至此nodejs安装完成 #2. 安装gitbook 1npm install -g gitbook-cli 之后在终端输入以下命令，否则，你在终端执行 gitbook -V 会提示命令不存在。 12sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/gitbook /usr/local/bin/gitbookgitbook -v # 输出安装后的版本信息 安装结束然后 3. Gitbook使用教程3.1 gitbook 命令123456gitbook -V 检测安装成功 gitbook init 初始化 gitbook build 编译当前的生成网页，但是不启动本地服务器gitbook serve -p 8080 . 编译当前的生成网页，启动本地服务器gitbook serve . 启动本地服务器gitbook update 更新软件 README.md是关于你的书的介绍，而SUMMARY.md中则包含了书目，即章节结构，它的格式大致是： 1234* [第1章](./绪论/c1.md) # 注意章的要顶格写,此处第一章全放在根目录的绪论文件夹中的 * [第1节](c1s1.md) # 注意节要有空格号 * [第2节](c1s2.md) # 注意节要有空格号* [第2章](c2.md) # 注意章的要顶格写 剩下的东西就很好理解了，你只需要编写相应章节即可。在编辑完README.md和SUMMARY.md后，你可以运行以下命令： 1$ gitbook serve -p 8080 . Gitbook首先把你的Markdown文件编译为HTML文件，并根据SUMMARY.md生成书的目录。所有生存的文件都保存在当前目录下的一个名为_book的子目录中。完成这些工作后，Gitbook会作为一个HTTP Server运行，并在8080端口监听HTTP请求。 运行以上命令后，打开浏览器，在地址栏输入：http://localhost:8080即可看到你的书页了。 其中位于左侧书目顶部的Introduction一节就编译自README.md，而书目本身自编译自SUMMARY.md。你要在自己的网站上发布新书，只需把_book目录复制到服务器相应目录即可。至此Gitbook的基本用法就介绍完毕。 3.2 Gitbook的插件支持Gitbook可以生成HTML，因此它支持一些外部的JavaScript文件嵌入到HTML中，例如Google统计、Disqus评论系统等。以下以页面中嵌入Disqus评论为例。 首先是安装Gitbook的Disqus插件。 1234$ npm install gitbook-plugin-disqus或者先写好book.json 然后执行gitbook install #推荐这种方法 然后建立一个book.json文件，其格式如下： 12345678&#123; &quot;plugins&quot;: [&quot;disqus&quot;], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;NAME-FROM-DISQUS&quot; &#125; &#125;&#125; 把上面的 NAME-FROM-DISQUS 修改为你在Disqus上的项目名即可。 要卸载的话（假如我要卸载的插件是：gitchinese-video），执行如下命令 1npm uninstall gitchinese-video 再次运行命令： 1$ gitbook serve -p 8080 . 并刷新浏览器，即可看到附加了Disqus评论的页面。 3.3 生成图书当你在自己的电脑上编辑好图书之后，你可以使用Gitbook的命令行进行本地预览： 1$ gitbook serve . 然后浏览器中输入 http://localhost:4000 就可以预览生成的以网页形式组织的书籍。这里你会发现，你在你的图书项目的目录中多了一个名为_book的文件目录，而这个目录中的文件，即是生成的静态网站内容。使用build参数生成到指定目录与直接预览生成的静态网站文件不一样的是，使用这个命令，你可以将内容输入到你所想要的目录中去： 12$ mkdir /tmp/gitbook$ gitbook build --output=/tmp/gitbook 3.4 输出PDF文件输入为PDF文件，需要先使用NPM安装上gitbook pdf： 1$ sudo npm install gitbook-pdf -g 4 更多的gitbook 插件支持请访问 gitbook官方插件库参考来源]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>Github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1 Ubuntu18下有道词典的配置]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-1-Ubuntu18%E4%B8%8B%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要本文记录了ubuntu 17+，Debian 等新版本的linux系统中有道词典不能安装的问题修复，由于官方提供的deb安装文件，可以解包调试，会发现Qt5版本低的原因导致的出错，本文不是指导如何调试代码和修复代码，本文给出了一种修复的方法，具体修复方法见文中内容所示。 Edit By Porter, 积水成渊,蛟龙生焉。 文章同步于: 我的gitbook 有道词典解包dep，修改源码接着玩Ubnutu18 安装有道词典 若要成功安装Ubuntu18下的有道词典，请移步大牛的仓库，配置下就好 大牛Ubuntu16后都支持的有道词典安装包和安装方法,这个支持Qt5.5 到我的是Qt5.9也支持，貌似以后版本这个可能也支持的，移步去安装吧。 提示，建议你不要开有道词典的划词，因为会卡死你，太占内存了，你ps下会发现好多的啊，全是ORC识别的进程tesseract 进程,就是这句话 12#安装ORC插件，支持有道划词，桌面翻译功能apt install tesseract-ocr tesseract-ocr-eng tesseract-ocr-chi-sim tesseract-ocr-chi-tra 说实话，不知道怎么生成那么多进程，卡死了，所以我没装这个插件，也没用划词，划词我直接浏览器安装插件解决。仅供参考。 本来准备安装有道云笔记的，但是我的linux是ubuntu18的Qt是5.9 用不了啊，他的Qt是哪个版本的没弄清楚，好像是5.4的，结果就是我安装不上，做这个笔记就是为了想办法重新改写他的源码看看能不能好点支持。 文章参考来源 该版本依赖于python3，需要如下依赖包： 1Depends: python3, python3-pyqt5, python3-requests, python3-xlib, tesseract-ocr, tesseract-ocr-eng, tesseract-ocr-chi-sim, tesseract-ocr-chi-tra, python3-pil, ttf-wqy-microhei, python3-lxml, python3-xdg, python3-pyqt5.qtmultimedia, python3-pyqt5.qtquick, python3-pyqt5.qtwebkit, gir1.2-appindicator3-0.1, python3-dbus, qtdeclarative5-controls-plugin, libqt5multimedia5-plugins,gstreamer0.10-plugins-ugly gstreamer0.10-plugins-ugly 这个可以不用，用这个替换 这个模块主要用于单词的发音： sudo apt-get install gstreamer1.0-libav Ok， 没有条件我们开始创造条件 第一步、下载有道词典的dep包进入官网，然后选择ubuntu的包下载 下载的是deb包，文件名为：youdao-dict_1.1.0-0-ubuntu_amd64.deb 。 第二步、解包1234#解压deb包到youdao-dict目录dpkg -X youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict#解压deb包中的control信息，control中写有该软件的依赖信息dpkg -e youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict/DEBIAN 第三步、修改1234cd youdao-dictcd DEBIANvim control#进入解压目录，编辑control文件，删除文件中Depends：后面的gstreamer0.10-plugins-ugly，并保存 [v] 接着就是修改工程中的源码 [v] 接着就是保存修改 第四步、重新打包123cd ~/下载#将修改后的安装文件重新打包dpkg-deb -b youdao-dict youdao-dict_new.deb 第五步、重新安装 12#安装重新打包的deb包sudo dpkg -i youdao-dict_new.deb]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>System Conf</tag>
        <tag>有道词典</tag>
      </tags>
  </entry>
</search>
