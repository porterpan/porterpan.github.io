<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1.9 hexo 实现本地图片加载]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-9-hexo-%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了1.9 hexo 实现本地图片加载，要知道原作官方提供的hexo-asset-image，根本不能满足自己的需要，所以这里是基于原作的代码进行修改实现，原作并未其提供的代码做出解释说明，本文将对更改后能实现本地图片加载的代码进行解释，并有针对性的对后来遇到问题的，或者可以给你们提供二次修改说明的解释并提醒。 文章同步于: 我的gitbook hexo-asset-image,这是原作者提供的代码，有一个特别致命的问题，是每次hexo g,后，需要手动将图片一张张对应复制到public文件夹中对应你的博文对应生成的文件夹的路径下才可以实现，本地图片显示。那么问题来了，我如果写了很多博文，需要每次复制如此多的图片到不同博文对应生成的文件夹中去。太麻烦了 若，我是写的书的格式，分章分节，一章我有10几节，那一个文件一个文件复制太麻烦了。 一、要解决的问题 我们要解决既要加载本地图库在我们的站点显示 又不想一个博文一个博文区分开了分别拷贝对应图片到public文件夹中 假设：如果我们能够把每章节的很多文章的不同图片放到该章节的图库文件夹中，这样每章就一个图库文件，我们把图库（image1文件夹）直接复制到（source文件夹下），然后直接hexo clean &amp;&amp; hexo g 就可以，这样不用手动添加文件到问文件夹中。 二、操作2.1 下载原作者的文件，然后修改原文件代码 安装原作者的hexo-asset-image 1npm install hexo-asset-image --save 2,2 原始作者的代码如下（还未经过博主修改前的代码）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2.3 修改原作代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string//获取对应链接的'/'分开的某部分function getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; //调用上面的函数，取link链接的第三个'/'位置的数组下标值，做下面取链接的首地址区间。 var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". //取link链接的最后一个'/'，做下面取链接的尾地址区间。 var endPos = link.lastIndexOf('/') + 1; //取link连接中我们认为有用的地址部分。 link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); //取图片的名字，比如 x.png var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); //$(this).attr('src', config.root + link + src); //notes: src is image name,and config.root is localhost:port,the middle cahr string is my local image Repository //这我们做判断，判断原始link链接的前3个字是不是“第一章”,如果是，我们将link地址写成'image1'，（image1是我们存放第一章所有图片的图库文件夹） if(link.substring(0,3)=="第一章")&#123; //第一章的所有图片放到这个文件夹下 link="image1/"; console.info&amp;&amp;console.info("judement the fist capture!"); &#125; //这我们做判断，判断原始link链接的前3个字是不是“第二章”,如果是，我们将link地址写成'image2'，（image2是我们存放第二章所有图片的图库文件夹） else if(link.substring(0,3)=="第二章")&#123; link="image2/"; console.info&amp;&amp;console.info("judement the second capture!"); &#125; else if(link.substring(0,3)=="第三章")&#123; link="image3/"; console.info&amp;&amp;console.info("judement the third capture!"); &#125; else if(link.substring(0,3)=="第四章")&#123; link="image4/"; console.info&amp;&amp;console.info("judement the fourth capture!"); &#125; else if(link.substring(0,3)=="第五章")&#123; link="image5/"; console.info&amp;&amp;console.info("judement the fifth capture!"); &#125; else if(link.substring(0,3)=="第六章")&#123; link="image6/"; console.info&amp;&amp;console.info("judement the sixth capture!"); &#125; else if(link.substring(0,3)=="第七章")&#123; link="image7/"; console.info&amp;&amp;console.info("judement the seventh capture!"); &#125; //$(this).attr('src', config.root + "image1/" + src); //这里我们做字符串的拼接，将最终输出的图片链接地址改为：config.root + link + src //其中config.root 是'/'表示根目录。link使我们的图库相对根目录的位置。src是图片的名字: x.png或其他格式图片 $(this).attr('src', config.root + link + src); //终端上打印调试信息，供自己调试，是否每个图片输出地址是正确的。 console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + "==" + link + "==" + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;); 2.3 修改你站点文件根目录的_config.yml文件的配置信息找到如下条，将默认的false改为true,注意_config.yml不是你的主题文件家中的文件 1post_asset_folder: true # local image to url,revise true 2.4 我的博文目录格式如下图片所示： 2.5 将你的的博文直接放到你站点根目录下的：source-&gt;_post文件夹下，如下图 2.6 将你的所有章节的图库文件夹直接放到source文件夹中即可如图：]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.2 最大熵模型]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-2-%E6%9C%80%E5%A4%A7%E7%86%B5%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍最大熵相关实际应用搞得入门例子，很简单，但是能说明最大熵的原理相关。 文章同步于: 我的gitbook 2.1.2 隐马尔科夫HMM在讲HMM前先看看什么是熵的概念 一、什么是熵(Entropy)信息熵的概念这个得从 热熵 开始说起，信熵是香农老先生从热力学引进来的，为了表示把信息中排除了冗余后的平均信息量称为“信息熵”。 热力学中的热熵是表示分子状态混乱程度的物理量。香农用信息熵的概念来描述信源的不确定度。 1.1 热力学中–热熵从能量角度来看,熵定律意味着自然进行的能量转化过程总是由有序度高的能量向有序度低的能量转化,这个过程必定朝着熵增加的方向进行。 高温物体所有分子的平均能量要高于低温物体,所以相接触时总是从高温物体向低温物体传递热量,因为碰撞使它们的状态向平衡过渡,系统才会稳定; 热熵是向着熵增大的方向进行。从宇宙形成到地球诞生以及地球生命的形成,热熵一直有缓慢变大的趋势。 热熵改变是指在某个空间内热量分布的变化。 1、在热力学中熵是对热量状态的描述，空间内热量分布差异越大则熵越小，做功的能力越强；空间内热量分布差异越小则熵越大，做功的能力越弱。热熵改变是指在某个空间内热量分布的变化，熵越大则热量分布的差异越小。正常情况下熵会从小到大的变化，最终熵达到最大而呈热寂。 2、根据热力学第二定律，作为一个“孤立”的系统，宇宙的熵会随着时间的流逝而增加，由有序向无序，当宇宙的熵达到最大值时，宇宙中的其他有效能量已经全数转化为热能，所有物质温度达到热平衡。这种状态称为热寂。这样的宇宙中再也没有任何可以维持运动或是生命的能量存在。 3、热熵改变的本质是热量分布由有序向无序发展，所以也可以看成系统混乱程度的改变。 4、熵最初是根据热力学第二定律引出的一个反映自发过程不可逆性的物质状态参量。热力学第二定律是根据大量观察结果总结出来的规律，有下述表述方式：热量总是从高温物体传到低温物体，不可能作相反的传递而不引起其他的变化；功可以全部转化为热，但任何热机不能全部地，连续不断地把所接受的热量转变为功；在孤立系统中，实际发生过程总使整个系统的熵值增大，此即熵增原理。 简单总结：热熵是熵增的过程，热量由有序的状态，转移，或是机械能，或是向其他低温物体转移，产生的影响是，最终达到系统平衡的目的，但也使得整个系统不再是以前清晰的状态，相反是变成了另一种混乱的状态，可以这样白话理解。 1.2 信息论中的信息熵–信熵 香农用信息熵的概念来描述信源的不确定度。 信息量信息量：一个事件发生的概率越小，信息量越大，所以信息量应该为概率的减函数，对于相互独立的两个事有p(xy)=p(x)p(y)，对于这两个事件信息量应满足h(xy)=h(x)+h(y)，那么信息量应为对数函数： 信息熵根据Charles H. Bennett对Maxwell’s Demon的重新解释，对信息的销毁是一个不可逆过程，所以销毁信息是符合热力学第二定律的。而产生信息，则是为系统引入负（热力学）熵的过程。所以信息熵的符号与热力学熵应该是相反的。 假设离散随机变量X的概率分布为P(x)，则其熵为： H(x) = E[I(xi)] = E[ log(2,1/p(xi)) ] = -∑p(xi)log(2,p(xi)) (i=1,2,..n) 其中，x表示随机变量，与之相对应的是所有可能输出的集合，定义为符号集,随机变量的输出用x表示。P(x)表示输出概率函数。变量的不确定性越大，熵也就越大 ，把它搞清楚所需要的信息量也就越大. 能量角度，高温向低温转变，一般是熵增的过程；而信息论中，为了最大可能接收到正确的（发出==收到）的信息，我们处理（优化）系统，是一种熵减的过程，信熵越小，系统有用信息量越大。 信息熵：信息的基本作用就是消除人们对事物的不确定性 。多数粒子组合之后，在它似像非像的形态上押上有价值的数码，具体地说，这就是一个在博弈对局中现象信息的混乱。 举个例子-(p1log(2,p1) + p2 log(2,p2) + ．．． +p32 *log(2,p32))，其中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。 有兴趣的读者可以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基础的读者还可以证明上面公式的值不可能大于五。因为得冠军的频率相同代表整个系统信息量最小。 熵是随机变量不确定性的度量，不确定性越大，熵值就越大；若随机变量退化成定值，熵为0。均匀分布(信熵最大)是“最不确定”的分布。 熵最早来原于物理学. 德国物理学家鲁道夫·克劳修斯首次提出熵的概念，用来表示任何一种能量在空间中分布的均匀程度，能量分布得越均匀，熵就越大。 总结：香农，描述一个信息系统的时候就借用了熵的概念，这里熵表示的是这个信息系统的平均信息量(平均不确定程度),信熵越小，系统信息不确定程度越低，反之，系统信息输出越混乱，有用信息越不容易被确认。 1.3 联合熵联合熵是一集变量之间不确定性的衡量手段。两个变量和的联合信息熵定义为： 一集变量的联合熵大于或等于这集变量中任一个的独立熵。 少于独立熵的和 这表明，两个变量关联之后不确定性会增大，但是又由于相互有制约关系，不确定小于单独两个变量的不确定度之和。 1.4 条件熵 条件熵H(X|Y) = H(X,Y) - H(Y) X在条件Y下的条件熵 条件熵 H(Y|X) 表示在已知随机变量 X 的条件下随机变量 Y 的不确定性。条件熵 H(Y|X) 定义为 X 给定条件下 Y 的条件概率分布的熵对 X 的数学期望： 证明如下： 条件熵 H(Y|X) 相当于联合熵 H(X,Y) 减去单独的熵 H(X)，即 举个例子，比如环境温度是低还是高，和我穿短袖还是外套这两个事件可以组成联合概率分布 H(X,Y)，因为两个事件加起来的信息量肯定是大于单一事件的信息量的。假设 H(X) 对应着今天环境温度的信息量，由于今天环境温度和今天我穿什么衣服这两个事件并不是独立分布的，所以在已知今天环境温度的情况下，我穿什么衣服的信息量或者说不确定性是被减少了(条件熵减少，联合熵是不变)。当已知 H(X) 这个信息量的时候，H(X,Y) 剩下的信息量就是条件熵： H(Y|X)=H(X,Y)−H(X) 1.5 相对熵与互信息 相对熵 (Relative entropy)，也称KL散度 (Kullback–Leibler divergence) 设p(x),q(x)是X中取值的两个概率分布，则p对q的相对熵是： 性质： 1、如果 p(x) 和 q(x) 两个分布相同，那么相对熵等于0 2、 ,相对熵具有不对称性。大家可以举个简单例子算一下。 3、DKL(p||q)≥0 证明如下（利用Jensen不等式https://en.wikipedia.org/wiki/Jensen%27s_inequality）： 因为： 所以： 总结：相对熵可以用来衡量两个概率分布之间的差异，上面公式的意义就是求 p 与 q 之间的对数差在 p 上的期望值。 相对熵，两者相同，那么相对熵等于0，两者差距越大，则相对熵值越大。 互信息两个随机变量X，Y的联合分布与独立分布乘积的相对熵，即： 1.6 交叉熵 (Cross entropy)熵的公式：$$H(p)=-\displaystyle\sum_{x}p(x)logp(x)$$ 相对熵的公式： $$H(p,q)=\displaystyle\sum _{x}p(x)log\frac{1}{q(x)}=-\sum _{x}p(x)logq(x)$$ 所以有： $$D_{KL}(p||q)=H(p,q)-H(p)$$ 当用非真实分布 q(x) 得到的平均码长比真实分布 p(x) 得到的平均码长多出的比特数就是相对熵） 并且当 H(p) 为常量时（注：在机器学习中，训练数据分布是固定的），最小化相对熵 DKL(p||q) 等价于最小化交叉熵 H(p,q) 也等价于最大化似然估计（具体参考Deep Learning 5.5）。 在机器学习中，我们希望在训练数据上模型学到的分布 P(model) 和真实数据的分布 P(real) 越接近越好，所以我们可以使其相对熵最小。 信息熵是衡量随机变量分布的混乱程度，是随机分布各事件发生的信息量的期望值，随机变量的取值个数越多，状态数也就越多，信息熵就越大，混乱程度就越大。当随机分布为均匀分布时，熵最大；信息熵推广到多维领域，则可得到联合信息熵；条件熵表示的是在 X 给定条件下，Y 的条件概率分布的熵对 X的期望。 相对熵可以用来衡量两个概率分布之间的差异。 交叉熵可以来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小。 几种熵的关系： 二、最大熵模型 最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是，在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。 达拉皮垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的数学工具对股票预测，获得了巨大的成功。(值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用)。 我们平常说的最大熵模型，只是运用最大熵思想的多分类模型，最大熵的思想却是一种通用的思维方法。所以，理解最大熵模型只需要搞清楚两件事就可以： 最大熵思想是什么 最大熵模型是如何运用最大熵思想的 2.1 最大熵思想我们知道，分类模型有判别模型和生成模型两种，判别模型是要学习一个条件概率分布 P(y|x)。举例说明 ，设：x是病人身体指标，体温、血压、血糖，y是各种可能的疾病，可简化为小病、中病、大病三种。 现在，我们有一个样本x1={体温：30，血压：160，血糖：60}，那么P(y|x1)就是一个概率分布，该分布的值就是上面简化的三种，小病、中病、大病。可能的概率分布如下所示： 之前参考样本\病况 小病 中病 大病 假设之前有和X1一样的情况有1/2的患者为小病，则此时的最大熵参考样本为 1/2 1/4 1/4 先前12个人和X1一样，结果有3个小病，4个中病的患者，则5个大病 1/4 1/3 5/12 无先前参考样本，假设取最大熵的概率 1/3 1/3 1/3 当然，这样的分布有无数种，上面只是举例说明而已。那么，问题来了，在这无数种概率分布中，哪一个才是好的呢？ 1、也就是说我们没有过往的经验可以参考，那么，就直接选一个熵最大的分布就是，也就是上面表格中的第三个分布，因为均匀分布总是同类分布中熵最大的分布。 2、如果查看以往病例后，我们得到一个经验，指标x1={体温：30，血压：160，血糖：60}有1/2的概率是小病，于是我们有了一定的经验知识，此时，最好的分布就是符合这个经验知识的前提下，熵最大的分布，显然，第一个分布就是最好的分布。 以上，我们就是运用了 最大熵的思想 。总结来说，最大熵的思想是，当你要猜一个概率分布时，如果你对这个分布一无所知，那就猜熵最大的均匀分布，如果你对这个分布知道一些情况，那么，就猜满足这些情况的熵最大的分布。 2.2 运用最大熵思想来做多分类问题 最大熵原理认为，学习概率模型时，在所有可能的概率模型（分布）中，上最大的模型是最好 的模型。 假设离散随机变量X的概率分布是P(X)，则其熵是： 熵取值范围为（当且仅当X是均匀分布时右边的等号成立）： 直观的，最大熵原理认为，要选择的概率模型首先必须要满足已有的事实，即约束条件后，对那些不确定的部分进行等可能概率分配。最大熵原理通过熵的最大化来表示为约束部分等可能性。 最大熵定义 2.3 最大熵的例题解说题：假设随机变量X有5个取值{A,B,C,D,E}, 要估计取各个值的概率P(A),P(B),P(C),P(D),P(E). 假设约束条件如下： 满足上述两个约束条件的可能取值任然很多，于是在求最大熵的过程中，为了得到最大熵，认为为约束的概率分布为等概率分布（等概率分布能确定为最大熵） 解：有约束条件和概率分布知识可知, $$min -H(P) = \sum_{i=1}^{5}P(y_{i})logP(y_{i})$$ 1s.t. P(y_&#123;1&#125;)+P(y_&#123;2&#125;)=\widetilde&#123;P(y_&#123;1&#125;)&#125;+\widetilde&#123;P(y_&#123;2&#125;)&#125;=\frac&#123;3&#125;&#123;10&#125; 1\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;) = \sum_&#123;i=1&#125;^&#123;5&#125;\widetilde&#123;P(y_&#123;i&#125;)&#125;=1 其中带波浪的是实际经验分布概率函数。 引进拉格朗日乘子、 。由上面的约束条件得到的三个方程式结合拉格朗日乘子得到如下拉格朗日函数L(P,w)的表达式。 1L(P,w)=-H(P)+\omega _&#123;0&#125;(\sum_&#123;y&#125;^&#123; &#125;)P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_&#123;1&#125;(E_&#123;\widetilde&#123;P&#125;&#125;(f_&#123;i&#125;)-E_&#123;P&#125;(f_&#123;i&#125;))=\sum_&#123;x,y&#125;\widetilde&#123;P(x)&#125;P(y|x)logP(y|x)+\omega_&#123;0&#125;(1-\sum_&#123;y&#125;^&#123; &#125;P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_1(\sum_&#123;x,y&#125;\widetilde&#123;P(x,y)&#125;-\sum_&#123;x,y&#125;^&#123; &#125;\widetilde&#123;P(x)&#125;P(y|x)f_&#123;i&#125;(x,y)) 带入题干信息可得如下的拉格朗日函数对应本题的表达式： 1L(P,w)=-H(P)+\omega_&#123;0&#125;(1-\sum_&#123;y&#125;^&#123; &#125;P(y|x))+\sum_&#123;i=1&#125;^&#123;n&#125;\omega_&#123;i&#125;(E_&#123;\widetilde&#123;P&#125;&#125;(f_&#123;i&#125;)-E_&#123;P&#125;(f_&#123;i&#125;))=\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;)logP(y_&#123;i&#125;)+\omega_&#123;1&#125;(P(y_&#123;1&#125;)+P(y_&#123;2&#125;)-\frac&#123;3&#125;&#123;10&#125;)+\omega_&#123;0&#125;(\sum_&#123;i=1&#125;^&#123;5&#125;P(y_&#123;i&#125;)-1) 这里只有3个限制条件，所以带入三个变量w得： 原始问题和对偶问题 根据拉格朗日函数（Ｌ)的对偶性，可以通过求解Ｌ(w)函数的对偶最优化问题得到我们原是函数（Ｌ(p))的最优解。即： 即，对于构造的Ｌ函数，求Ｐ的最小值问题对应ｗ参数的最大值最优解问题，Ｐ是要求的原始问题。Ｐ是原始问题的对偶问题的求解函数变量。 接下来开始求解了原始问题和对偶问题的最优解问题，步骤如下： 第一步先将原始问题（Ｐ参数的Ｌ函数）的最优解换化出来，即 令各偏导数等于0，解得： 于是， 第二步，将原始问题对应的对偶问题（ｗ参数，对应Ｌ函数的最优解）的最优解解出来，即 $$L(P_{w},w)$$ 关于$$w$$的极大化问题。 $$\max_{\omega}L(P_{w},w)=-2e^{-w_{1}-w_{0}-1}-3e^{-w_{1}-1}-\frac{3}{10}w_{1}-w_{0}$$ 分别求$$L(P_{w},w)$$关于$$w_{0},w_{1}$$的偏导数并令其为0，得到： $$e^{-w_{1}-w_{0}-1}=\frac{3}{20},e^{-w_{0}-1}=\frac{7}{30}$$ 于是得到所要求的概率分布为： $$P(y_{1})=P(y_{2})=\frac{3}{20},P(y_{3})=P(y_{4})=P(y_{5})=\frac{7}{30}$$ 总结：最大熵模型，形式简单，但是训练的代价太大，比如最原始的最大熵训练模型GIS（通用迭代算法）和IIS（改进迭代算法），每次迭代时间都很长，而且每步需要迭代很多次，实现复杂了。 追加 ：此处记录下拉格朗日函数的相关性质： 拉格朗日中值定理： 如果函数f(x)满足：（1）在闭区间[a, b]上连续；（2）在开区间[a, b]内可导；那么在开区间(a, b)内至少有一点 使等式 成立。 拉格朗日差值法： 1、两点确定一条直线，这条直线就是线性插值 2、 ，这个$$P_{1}(x)$$函数就是线性插值函数 为了和后面公式进行对比，上面公式可以转化为下面表达式， 这两个都是叫做线性插值的基函数 . 得到的插值效果如下： 线性插值仅仅利用两个节点信息，精确度很低，故接下来讲二次差值(考察曲线问题) 3、拉格朗日二次插值 如果按照线性插值的形式，以每3个相邻点做插值，就得到了二次插值(3个点：xi,xi+1,xi+2)： 得到的曲线效果是： 二次插值在每段二次曲线内是光滑的，但在每条曲线的连接处其光滑性可能甚至比线性插值还差。二次插值只适合3个节点的情形，当节点数超过3个时，就需要分段插值了。 4、拉格朗日多项式插值 一个n次的拉格朗日插值函数可以绘制经过(n+1)个节点的曲线，但运算量非常大。而且在次数比较高时，容易产生剧烈的震荡（龙格现象）。所以要选择位置特殊的节点（比如切比雪夫多项式的零点）进行插值，或使用多个次数较低的拉格朗日函数分段插值。（关于拉格朗日多项式和龙格现象，详见维基百科链接） 使用4次拉格朗日多项式分段插值： 如果直接使用20次的拉格朗日插值，得到的图像如下： 等，更多的插值，[请参考这里] 数值分析（拟合、插值和逼近）之数据插值方法（线性插值、二次插值、Cubic插值、埃米尔特、拉格朗日多项式插值、牛顿插值、样条插值 参考地址1参考地址2参考地址3]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3 隐马尔科夫HMM]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-3-%E9%9A%90%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%ABHMM%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍隐马尔科夫HMM相关实际应用搞得入门例子，很简单，但是能说明隐马尔科夫HMM的原理相关。 文章同步于: 我的gitbook HMM（隐马尔可夫模型）隐马尔可夫模型是一种统计模型，用来描述一个含有隐含未知参数的马尔可夫过程。其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。 是在被建模的系统被认为是一个马尔可夫过程与未观测到的（隐藏的）的状态的统计马尔可夫模型。 本文简述的是离散情况下的隐马尔可夫模型. 一、贝叶斯公式定义：假设以硬币的例子，从5角和1元的一堆硬币中，随意取出一枚硬币，然后然我们猜这枚硬币是5角还是1元。假设允许我们称这枚硬币的重量x（单位：g），(但是不允许我们直接看硬币，一般1元是比5角重的)。现在应考察在一直这枚硬币的重量x的情况下硬币属于各类（5角还是一元)的概率，分别记$$P(\omega_{1}|x)$$,(知重量为x时，是5角的概率),$$P(\omega_{2}|x)$$, (知重量为x时，是一元的概率)，这种概率成为后验概率（我们需要求的）。这时的决策为：如果$$P(\omega_{1}|x)&gt;P(\omega_{2}|x)$$,则$$x \epsilon \omega_{1} $$; 反之，则$$x \epsilon \omega_{2} $$ 最终我们要的就是这个决策。 概率论中的贝叶斯公式： $$P(\omega_{i}|x)=\frac{p(x,\omega_{i})}{p(\omega_{i})}=\frac{p|\omega_{i}P(\omega_{i})}{p(x)} ,i=1,2$$ 分布 表示 $$x \epsilon \left { \omega_{1},\omega_{2} \right }$$ 类条件概率： $$p(x\mid \omega_{i})$$ 表示得到硬币结果是$$\omega_{i}$$条件下，得到x的概率密度 后验概率： $$P(\omega_{i}\mid x)$$ 在重量为x，的条件下，得到是哪种硬币（5/1）的概率 先验概率： $$P(\omega_{i})$$ 根据之前的经验，得到5角和1元各自取得的概率 硬币重量概率密度函数: $$p(x)$$ 硬币重量的概率密度函数 联合概率密度： $$p(x,\omega_{i})$$ 在重量不同条件下，每种情况对应的取得不同硬币结果的联合概率 $$P(Q_{i}|O)=\frac{P(O,Q_{i})}{P(O)}=\frac{P(O|Q_{i})P(Q)}{P(O)}$$ $$P(Q_{i}|O)=\frac{P(O,Q_{i})}{P(O)}=\frac{P(O|Q_{i})P(Q)}{P(O)}$$ $$P(Q_{i}|O)$$ ,后验概率，$$P(O,Q_{i})$$ ,表示O与Q的联合概率密度；P(O)表示两类所有的概率密度； P(Q_{i})是先验概率；$$P(O|Q_{i})$$是第i类状态随机序列的类条件概率密度 贝叶斯决策：在类条件概率密度和鲜艳概率已知（或可估计）的情况下，通过贝叶斯公式比较样本属于两类的后验概率，将类别决策为后验概率大的一类，这样做的目的是为了使总体错误率最小。 一条隐藏的马尔可夫链生成的 状态随机序列 (State sequence, 图中的白色节点) $$Q=(q_{1},q_{2},…..,q_{T})$$是不可观测的，并记所有可能状态的集合为$$S={S_{1},S_{2},…..,S_{N}}$$;由它们产生一个可观测的观测随机序列（observation sequence，图示的深色节点）$$O=(o_{1},o_{2},……,o_{T})$$, 并记所有可能观测的集合为$$V={v_{1},v_{2},……,v_{M}}$$。 序列的值可以看作是随时刻产生的，每个时刻对应着序列的一个值。所以HMM是个双重随机过程（doubly embedded stochastic process），一个是状态转移，另一个是由状态释放出观测值。在序列标注（Sequence labelling）任务中，模型就是需要对状态序列进行标注。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.3 隐马尔科夫HMM]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-2-%E7%9F%A9%E9%98%B5%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍矩阵相关基础相关实际应用搞得入门例子，很简单，但是能说明矩阵相关基础的原理相关。 文章同步于: 我的gitbook 矩阵相关基础知识]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.3 线性回归]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-3-%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍线性回归相关基础相关实际应用搞得入门例子，很简单，但是能说明线性回归相关基础的原理相关。 文章同步于: 我的gitbook LinearRegression算法 学习参考来源 一、最小二乘法的拟合原理 最小二乘法定义如上图所示，但是初看可能会有点懵，上面的表示是啥意思，好接下来总结下我的理解 最小二乘法（又称最小平方法）是一种数学优化技术，除了能拟合直线还能拟合曲线问题。 书中截取部分如果可以这样理解$$\alpha_{i}$$，如果是二次项的话$$y=\alpha_{1} x^{2}+\alpha_{2} x + \alpha_{3} $$，知道了吧，就是一个二项式子中的待解参数。 本文为了推导和笔记的简单化，直接以拟合直线 $$f(x;a,b): y=ax+b$$ 1.1 代数推导： [1]. 假设拟合直线 $$f(x;a,b): y=ax+b$$ [2]. 已经由n个样本$$(x_{n}, y_{n})$$ [3]. 误差$$e_{i}=y_{i}-(ax_{i}+b)$$ [4]. 当$$S = \sum_{i=1}^{n} e_{i}^{2}$$为最小值时，即得到的a,b参数就是最小二乘法得到的解. 如何求解这些参数（a，b） $$\frac{\partial S}{\partial b}=-2(\sum_{i=1}^{n}y_{i}-nb-a\sum_{i=1}^{n}x_{i})$$ $$\frac{\partial S}{\partial a}=-2(\sum_{i=1}^{n}x_{i}y_{i}-b\sum_{i=1}{n}x_{i}-a\sum_{i=1}^{n}x_{i}^{2})$$ 分别令上式中对a,b求偏导数的有点等于0,以此求取对a,b的最值.有：$$n\bar x=\sum_{i=1}^{n}x_i,n\bar y=\sum_{i=1}^{n}y_i$$ 得到： $$a=\frac {\sum_{i=1}^{n}({x_i-\bar x})(y_i-\bar y)} {\sum_{i=1}^{n}({x_i-\bar x})^2}$$ $$b=\bar y-a\bar x$$ $$a=\frac {n\sum_{}^{}{x_iy_i}-\sum_{}^{}{x_i}\sum_{}^{}{y_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ $$b=\frac {\sum_{}^{}{x_i}^2\sum_{}^{}{y_i}-\sum_{}^{}{x_i}\sum_{}^{}{x_iy_i}} {n\sum_{}^{}{x_i}^2-(\sum_{}^{}{x_i})^2}$$ 1.1.1 代数推导的代码实现123456789101112131415161718192021222324import numpy as npimport matplotlib.pyplot as pltdef calcAB(x,y): n = len(x) sumX,sumY,sumXY,sumXX =0,0,0,0 for i in range(0,n): sumX += x[i] sumY += y[i] sumXX += x[i]*x[i] sumXY += x[i]*y[i] a = (n*sumXY -sumX*sumY)/(n*sumXX -sumX*sumX) b = (sumXX*sumY - sumX*sumXY)/(n*sumXX-sumX*sumX) return a,b,xi = [1,2,3,4,5,6,7,8,9,10]yi = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]a,b=calcAB(xi,yi)print("y = %10.5fx + %10.5f" %(a,b))x = np.linspace(0,10)y = a * x + bplt.plot(x,y)plt.scatter(xi,yi)plt.show() 1.2 矩阵推导对于$$y=ax+b$$,转为向量的形式为$$W=\begin{bmatrix}w_0\w_1\end{bmatrix},X=\begin{bmatrix}1\x_1\end{bmatrix}$$ 于是：$$y=w_1x_1+w_0=W^TX$$ 损失函数为: $$L=\frac{1}{n}\sum_{i=1}^{n}(y_n-(W^TX)^2)=\frac{1}{n}(y-XW)^T(y-XW)$$ 最后可化为 $$\frac{1}{n}X^TW^TXW-\frac{2}{n}X^TW^Ty+\frac{1}{n}y^Ty$$ 令偏导为0 $$\frac{\partial L}{\partial W}=\frac{2}{n}X^TXW-\frac{2}{n}X^Ty=0$$ 另外： $$(X^TX)^{-1}X^TX=E,EW=W$$,则 $$(X^TX)^{-1}X^TXW=(X^TX)^{-1}X^Ty,W=(X^TX)^{-1}X^Ty$$ 1.2.1 代码实现：12345678910111213141516import numpy as npimport matplotlib.pyplot as pltx = [1,2,3,4,5,6,7,8,9,10]y = [10,11.5,12,13,14.5,15.5,16.8,17.3,18,18.7]A = np.vstack([x,np.ones(len(x))]).Ta,b = np.linalg.lstsq(A,y)[0]print("y = %10.5fx + %10.5f" %(a,b))x = np.array(x)y = np.array(y)plt.plot(x,y,'o',label='data',markersize=10)plt.plot(x,a*x+b,'r',label='line')plt.show() 拟合的效果（蓝线） 1.3 小结 二、线性回归线性回归的目的是找到一个与这些数据最为温和的线性函数，用来预测或者分类，主要解决线性问题。一般来说，线性回归问题都可以通过最小二乘法来求出方程。线性回归属于监督学习,因此方法和监督学习应该一样，先给一个训练集，根据这个训练集学习出一个线性函数，然后测试这个函数训练的好不好（拟合是否恰当）。Cost Function 越小的函数，说明训练数据拟合程度越好。 线性回归，通过数据集的线性组合来预测函数： $$f(x)=\omega_{1}x_{1}+\omega_{2}x_{2}+\omega_{3}x_{3}+…+\omega_{d}x_{d}+b$$ 一般向量形式写为： $$f(x)=\omega^{T}x+b$$ 其中的$$\omega=(\omega_{1};\omega_{2};\omega_{2};…\omega_{d})$$ $$x_{1},x_{2},…x_{k}$$是一组独立的预测变量 $$\omega_{1},\omega_{2},…\omega_{k}$$为模型从训练数据中学习得到的参数，或称赋予每个变量的权值。 b是一个学习到的参数，这个现行函数中的常量也称模型的偏置（Bias） 根据输入属性可分为一元，二元……多元线性回归。 多元数据集的定义如下： $$D=\left [ x_{i,j}, y_{i}\right ]$$，其中i,表示数据集第i位序列的值，而j则表示在第i位x的属性是j种属性，即数据集中，x(i,j)，i维行，j维纵坐标的矩阵。 即数据集j元的属性矩阵表示为：$$\begin{bmatrix}x_{1,1} &amp; x_{1,2} &amp; … &amp; x_{1,j-1} &amp; x_{1,j}\x_{2,1} &amp; x_{2,2} &amp; … &amp; x_{2,j-1} &amp; x_{2,j}\… &amp; … &amp; … &amp; … &amp; …\x_{i,1} &amp; x_{i,2} &amp; … &amp; x_{i,j-1} &amp; x_{i,j}\end{bmatrix}$$ 比如3元的表示一个西瓜好坏，【hue, root, echo】，加入预测函数的参数已经求得$$\omega=\left [ 0.2, 0.5, 0.3 \right ],b=1$$，则好瓜（good)函数$$f_{good}(x)=0.2 \cdot x_{hue}+0.5 \cdot x_{root}+0.3 \cdot x_{echo}+1$$ 2.1 一元线性回归 输入属性只有一个的情况，称一元线性回归 属性： 这里考虑一元的情况则数据集为： $$D=\left [ x_{i}, y_{i}\right ]_{i=1}^{m} $$,即上面矩阵表示的j元数据集中j=1，现在我们来尝试一元的线性回归。 [1] 假设我们预测函数形式：$$f(x_{i})=\omega x_{i}+b_{i}$$,使得$$f(x_{i})\approx y_{i}$$. 接下来我们引入上面的最小二乘法求参数$$\omega , b$$. [2] 假设最小均方误差函数为： $$e_{\omega^,b^}=arg_{(\omega,b)}min \sum_{i=1}^{m}(f(x_{i})-y_{i})^2 $$ [3] 对上式e的函数分别对$$\omega,b$$求偏导，对偏导结果赋值0，求$$\omega,b$$值。 [4] 偏导数 $$\frac{\partial E_{\omega,b}}{\partial \omega}=2(\omega\sum_{i=1}^{m}x_{i}^{2}-\sum_{i=1}^{m}(y_{i}-b)x_{i})$$ $$\frac{\partial E_{\omega,b}}{\partial b}=2(mb-\sum_{i=1}^{m}(y_{i} - \omega x_{i}))$$ [5] 上一步骤中的偏导数都设为零，以此来求得$$\omega , b$$. $$\omega = \frac{\sum_{i=1}^{m} y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{m}x_{i}^{2}-\frac{1}{m}(\sum_{i=1}^{m}x_{i})^2}$$ $$b=\frac{1}{m}\sum_{i=1}^{m}(y_{i}-\omega x_{i}),\bar{x}=\frac{1}{m}\sum_{i=1}^{m}x_{i}$$,$$\bar{x}$$为序列x的均值。 这里一元的线性回归，用最小二乘法求解的参数估计，称为线性回归模型的最小二乘法“参数估计”(parameter estimation). 2.2 多元线性回归类似一元，但是求解 估计的参数矩阵$$\omega, b$$，就需要全部看成矩阵的求解方法求出。见最小二乘法矩阵推导那一节，不再具体推推导了，在2.1节基础上明白线性回归，多元回归思想即可明白。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1.1 马尔科夫简单模型预测实战笔记]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-1-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E7%AE%80%E5%8D%95%E6%A8%A1%E5%9E%8B%E9%A2%84%E6%B5%8B%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍马尔科夫相关实际应用搞得入门例子，很简单，但是能说明马尔科夫的原理相关。 文章同步于: 我的gitbook 马尔科夫简单模型预测实战笔记一、基于马尔可夫链的公交停靠站乘客数预测1.1 题设 假设站点乘客数的状态具有马尔可夫性，当某一时刻有公交车停靠时， 会有一些乘客上车， 则下一时刻车辆到达时停靠站的乘客数与这一时刻剩余的乘客相关， 这一特征符合了马尔可夫链的马尔可夫性，同时在任意时刻的候车乘客只与上一时刻的乘客数相关， 而与候车时间无关。—-满足马尔科夫。 数据 以该停靠站点的候车乘客数为统计对象， 按照离散时间， 在状态转移中将以时间间隔为五分钟而对停靠站点的乘客数进行计数。以工作日某一天的上午8∶ 00 ～ 10∶ 00 的两小时为统计的时间段， 其中第一组数据为时刻 8∶05 时的乘客数， 可得到 24 组数据。如下图所示： 图1-1 8-10点的24组数据 由表 1 可知， 该站点的乘客数区间为［12， 27］，为保证预测的准确性， 根据建模步骤可将站点的乘客数分为 3 种状态， 即状态空间为( E1， E2， E3 ) ， 其中 E1 表示乘客数为 11 ～ 16， E2 表示乘客数为 17 ～22， E3 表示乘客数为 23 ～ 28， 因此有乘客数状态空间的频数分布， 如表 2 所示。 于是得到对应上表的如下状态分布表 表二 时间点 乘客人数 时间表 乘客人数 时间表 乘客人数 时间表 乘客人数 1 E1 7 E2 13 E1 9 E2 2 E1 8 E3 14 E2 20 E1 3 E2 9 E2 15 E2 21 E1 4 E2 10 E2 16 E3 22 E1 5 E2 11 E1 17 E3 22 E1 6 E2 12 E2 18 E2 24 E1 于是可以得到状态转移频次表如下表所示： 表三 单位(人) E1 E2 E3 E1 5 3 0 E2 3 7 2 E3 0 2 1 1.2 计算模型根据马尔可夫变量的特征， 结合变量状态转移概率矩阵， 对站点乘客数的预测步骤如下: 统计时需注意: 引起乘客数状态变化的转入包括下车后仍留在站点候车的乘客; 引起乘客数状态变化的转出则包括经过停靠车辆后上车的乘客， 则有表 1。 由表二可统计得到如下信息： E1 E2 E3 当前统计总数(人) 8 12 3 由此可得到表三对应的转移概率矩阵，如下 转移概率 E1 E2 E3 E1 5/8 3/8 0/8 E2 3/12 7/12 2/12 E3 0/3 2/3 1/3 即： 转移概率 E1 E2 E3 E1 0.625 0.375 0 E2 0.25 0.58 0.17 E3 0 0.67 0.33 设初始时刻的状态分布为10点的时刻。由于10点出行人数是14人，在E1(11~16)之间，故设出事时刻的概率分布为: N(0)=(1, 0, 0) 由N(1)=N(0).*P(1)=(0.625, 0.375, 0) 12345678910111213import numpy as npdef markov(): init_array = np.array([1, 0, 0]) transfer_matrix = np.array([[0.625, 0.375, 0], [0.25, 0.58, 0.17], [0, 0.67, 0.33]]) restmp = init_array for i in range(25): res = np.dot(restmp, transfer_matrix) print('N(',i+1,')', "\t", res ) restmp = res markov() N(0), 代表10：00的乘客数。N(1)代表10:05分的乘客数.N(2)代表10:10分的乘客数，以此类推。 取上面设定的状态范围（11~16）， （17-22）， （18~28），分别对上面的取值区间做中值得到13.5， 19.5， 25.5； 设 E1=13.5, E2=19.5, E3=25.5. 由10:05分的站点乘客数量状态分布，N(1)=[0.625, 0.375, 0],和E=[13.5, 19.5, 25.5]可求得10:05的期望值Ex $$E_{x}=\sum_{i=1}^{3} (N(1,i)*E(i)) = 0.625\times 13.5 + 0.375\times19.5 + 0\times25.5 = 15.75$$ 在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和，是最基本的数学特征之一。它反映随机变量平均取值的大小。 即，在10:05的时刻，车站人数最可能有15.75个人在等车。 同理在10:10分，N(2)=[0.484375, 0.451875, 0.06375], 则此时刻（10:05），车站最可能（该时刻的期望值）出现的候车人数经计算为： 16.7503125（人），具体计算过程如下： $$E_{x}=\sum_{i=1}^{3} (N(1,i)*E(i)) = 0.484375\times 13.5 + 0.451875\times19.5 + 0.06375\times25.5 = 16.7503125$$ 推荐下在线Latex公式编辑网站 10:15时刻，10:20时刻，10:25时刻，……计算方法一次类推，于是可得到整个时间段站台候车人数的预测表，如下表： 时刻 状态 转移率 站台乘客数预测值 站台人数实际值 E1 0.625 — — 10:05 E2 0.375 15.75 14 E3 0 — — — — — — — E1 0.484375 — — 10:10 E2 0.50358792 16.7503125 16 E3 0.09785625 — — — — — — — E1 0.38142461 — — 10:15 E2 0.50358792 17.90137716 17 E3 0.11498747 — — — — — — — E1 0.36428736 — — 10:20 E2 0.51215683 18.0556107 18 E3 0.12355581 — — — — — — — E1 0.35571881 — — 10:25 E2 0.51644111 18.13272762 18 E3 0.12784008 — — — — — — — E1 0.35143453 — — 10:30 E2 0.51858325 18.17128614 18 E3 0.12998222 — — 以上的基于马尔科夫的模型预测和实际值的趋势图如下图所示： 图像在线生成：推荐下在线绘图做表的网站 预测结果表明在马尔可夫链理论下的预测会受到时间长短的影响， 在短时间内的统计， 预测结果与实际值间的误差较为明显， 当统计量足够多时， 预测的趋势会更加符合实际情况。 C-K方程( Chapman- Kolmogorov方程)-马尔可夫链定义如下: 参考文献：[1]刘哲华.基于马尔可夫链的公交停靠站乘客数预测[J].黑龙江交通科技,2018,41(11):155-157. 二、最佳经营策略应用]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.1 马尔科夫链]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-2-1-%E9%A9%AC%E5%B0%94%E7%A7%91%E5%A4%AB%E9%93%BE%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本篇文章笔记总结来自网络和书本，引用部分都有来源，内容主要介绍马尔科夫相关的性质和几个实例进行论述。 文章同步于: 我的gitbook 马尔科夫链摘要：状态空间中经过从一个状态到另一个状态的转换的随机过程，需要具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作马尔可夫性质。 一、常见的马尔可夫过程：(1) 独立随机过程为马尔可夫过程。 (2) 独立增量过程为马尔可夫过程：没{X(t)，t∈[0，+∞)}为一独立增量过程，且有P(X(0)=x0)=1，x0为常数，则X(t)为马尔可夫过程。 (3) 泊松过程为马尔可夫过程。 (4) 维纳过程为马尔可夫过程。 (5) 质点随机游动过程为马尔可夫过程。 二、模型的创立条件 无后效性—只与前一时刻状态相关和其他历史时刻无关。 图2-1 马尔科夫表示式 系统平稳性—平稳分布（马尔可夫链的）具有某种不变（或者说平稳）性质的概率分布。 图2-2 马尔科夫平稳分布表示式 2.1 无后效性状态空间中经过从一个状态到另一个状态的转换的随机过程。该过程要求具备“无记忆”的性质：下一状态的概率分布只能由当前状态决定，在时间序列中它前面的事件均与之无关。这种特定类型的“无记忆性”称作马尔可夫性质。马尔科夫链作为实际过程的统计模型具有许多应用。 在马尔可夫链的每一步，系统根据概率分布，可以从一个状态变到另一个状态，也可以保持当前状态。状态的改变叫做转移，与不同的状态改变相关的概率叫做转移概率。随机漫步就是马尔可夫链的例子。随机漫步中每一步的状态是在图形中的点，每一步可以移动到任何一个相邻的点，在这里移动到每一个点的概率都是相同的（无论之前漫步路径是如何的）。 作者：bitcarmanlee来源：CSDN原文：https://blog.csdn.net/bitcarmanlee/article/details/82819860版权声明：本文为博主原创文章，转载请附上博文链接！ 2.2 平稳分布概念 平稳分布是一种概率分布。平稳分布（马尔可夫链的）具有某种不变（或者说平稳）性质的概率分布。 图2-3 平稳分布，百度百科解释 三、马尔科夫相关的例子直接看理论是有点头痛的，但是接下来直接上例子，学习致用，在应用中学习。 3.1 马尔科夫股市模型实例假设股市三种状态：牛市（Bull market）, 熊市（Bear market）和横盘（Stagnant market），每一个状态都以一定的概率转化到下一个状态。 3.1 题设 图3-1 股市概率转移状态图 比如，牛市以0.025的概率转化到横盘的状态。这个状态概率转化图可以以矩阵的形式表示。如果我们定义矩阵阵P某一位置P(i, j)的值为P(j|i)， 即从状态i变为状态j的概率 。另外定义牛市、熊市、横盘的状态分别为0、1、2，这样我们得到了马尔科夫链模型的状态转移矩阵为： 图3-2 马尔科夫状态转移概率矩阵 当这个状态转移矩阵P确定以后，整个股市模型就已经确定！ 3.1.1 用计算结果说明马尔科夫的性质（无后效性，和系统平稳性） 步骤一、假设初始状态：t0​=[0.1,0.2,0.7]，然后算之后的状态。 步骤二、计算方法是用这个初始的状态分布概率向量(t0)点乘我们的马尔科夫状态转移概率矩阵(P)。 如图2-2 所说的，当P^n –&gt; 会趋向一个稳定的转移概率矩阵。 Python 代码验证： 1234567891011import numpy as npdef markov(): init_array = np.array([0.1, 0.2, 0.7]) transfer_matrix = np.array([[0.9, 0.075, 0.025], [0.15, 0.8, 0.05], [0.25, 0.25, 0.5]]) restmp = init_array for i in range(25): res = np.dot(restmp, transfer_matrix) print i, "\t", res restmp = res markov() 执行以上代码后，输出结果，如图所示 图3-3 马尔科夫股市代码输出 从第18次开始，状态就开始收敛至[0.624,0.312,0.0625]。最终数字上略有不同，只是计算机浮点数运算造成的罢了。 如果我们换一个初始状态t0​，比如[0.2,0.3.0.5]，继续运行上面的代码，只是将init_array变一下，最后结果为： 到第18次的时候，又收敛到了[0.624,0.312,0.0625]!这个转移矩阵就厉害了。不管我们的初始状态是什么样子的，只要状态转移矩阵不发生变化，当n→∞时，最终状态始终会收敛到一个固定值。 3.1.2 后续接着代码验证 图2-2 马尔科夫平稳分布表示式（3点）我们也看看这个状态转移矩阵P的25(本是n-&gt;∞幂次方) 幂次方有什么有意思的地方？ 12345678910def matrixpower(): transfer_matrix = np.array([[0.9, 0.075, 0.025], [0.15, 0.8, 0.05], [0.25, 0.25, 0.5]]) restmp = transfer_matrix for i in range(25): res = np.dot(restmp, transfer_matrix) print i, "\t", res restmp = res matrixpower() 执行以上代码 发现了，从第20次开始，结果开始收敛，并且每一行都为[0.625,0.312,0.0625]! 再次验证了图2.2的定理0.4.2的 3.2 马尔科夫的人类上中下阶层分布模型假设，社会学家把人按其经济状况分为3类：下层，中层，上层，我们用1,2,3表示这三个阶层。社会学家发现决定一个人的收入阶层最重要的因素就是其父母的收入阶层。如果一个人的收入属于下层类别，则它的孩子属于下层收入的概率为0.65，属于中层收入的概率为0.28，属于上层收入的概率为0.07。从父代到子代，收入阶层转移概率如下 我们用P表示这个转移矩阵，则 假设第1代人的阶层比例为 则前10代人的阶层分布如下 第二代人是第一代任PI0，点乘以P（转移概率），第三代人是第二代人点乘以P 我们可以看到，在相同的转移矩阵作用下，状态变化最终会趋于平稳。对于第n代人的阶层分布，我们有 从表达式上我们可以看到，π是一维向量，P是两维矩阵，P进行足够多次自乘后，值趋于稳定。 3.2.1 马尔科夫的人类农村转城市人口分布模型假设城市化进程中，农村人转移为城市人的概率为0.5，城市人转移为农村人的概率为0.1。 人口 农村人 城市人 农村人 0.5 0.5 城市人 0.1 0.9 假设一开始有100个农村人，0个城市人，每代转移人数矩阵如下 代数 农村人 城市人 农村人转移为城市人 城市人转移为农村人 1 100 0 50 0 2 50 50 25 5 3 30 70 15 7 4 22 78 11 8 5 19 81 10 8 6 17 83 8 8 7 17 83 8 8 可以看到，城市化进程中马尔科夫平稳状态就是农村人转移为城市人的速度等于城市人转移为农村人的速度。对于上述转移矩阵P，平稳分布为农村人17%，城市人83%。如果我们可以得到当前中国城市化转移矩阵P，我们就可以算出中国最终城市化率大概为多少（这里不考虑P的变化）。同时如果我们知道了中国城市化人口比例，我们就能知道城市化进程还可以持续多少代人。 3.3 车站候车人数预测模型具体的实例过程请移步 [2.1.1 马尔科夫简单模型预测实战笔记] 章节部分 四、总结4.1 马尔科夫的平稳随机性 非周期马氏链：马氏链转移要收敛，就一定不能是周期性的。不做特别处理，我们处理的问题基本上都是非周期性的 存在概率转移矩阵P，任意两个状态是连通的，如上，例题中的每个不同的阶层人的角色通过某种方式，他们之间是可以相互转化，前后转化的两种状态是联通的可以转化的，底层人士可以转化成中层等。 不论初始状态是什么，经过足够多次概率转移后，会存在一个稳定的状态π。概率转移矩阵自乘足够多次后，每行值相等。即 显然，由于马氏链稳定后，所有状态转移到状态j的概率之和稳定。 则π为马氏链稳定状态，并且π是方程π=πP的唯一非负解。结合上面结论，很明显。]]></content>
      <categories>
        <category>notes</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计基础笔记]]></title>
    <url>%2F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要 网页效果图设计，可以Fireworks,也可以Photoshop以及其他的平面设计软件 根据网页效果图进行切图 为什么要切图：提高网站下载速率，规律：能用CSS效果表现出来的就少用图像，也是为了提高下载速率]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单的方法，获取在线付费设计log的方法]]></title>
    <url>%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%B6%8A%E8%BF%87%E4%BB%98%E8%B4%B9%E8%8E%B7%E5%8F%96%E5%9C%A8%E7%BA%BF%E7%9A%84log%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要有时人穷则需要志坚，花别人返工心情的时间，做别人不愿做的尝试。 今天的目标对象是他：Log设计网 不是我不支持他，而是因为，太穷，没那么多钱钱，用到啥买啥，所以，看能省钱的地方就省了吧。 本文档是教如何免费获取99元套餐的log设计资源。 点击进入Log官网的个人中心 选择你目前编辑的Log 点击页面的分享 在浏览页面中鼠标右键，进入inspect界面 点击Source 查看源码 搜索关键字“jpg” 复制图片链接，下载，好了，这就是你自己的Log了 以上步骤结束，不贴图了，贴图影响不好了]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中忽略提交项]]></title>
    <url>%2Fgitignre-%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要：本文记录了git的忽略提交的git规则配置，及一些举例。 参考博客资料 在Git项目中定义.gitignore文件对于经常使用Git的朋友来说，.gitignore配置一定不会陌生。这种方式通过在项目的某个文件夹下定义.gitignore文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。.gitignore 文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。在.gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如： 123*.log*.temp/vendor 在Git项目的设置中指定排除文件这种方式只是临时指定该项目的行为，需要编辑当前项目下的 .git/info/exclude文件，然后将需要忽略提交的文件写入其中。需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。 定义Git全局的 .gitignore 文件除了可以在项目中定义 .gitignore 文件外，还可以设置全局的git .gitignore文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置Git： 1# git config --global core.excludesfile ~/.gitignore 首先要强调一点，这个文件的完整文件名就是”.gitignore”，注意最前面有个“.”。一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。实际项目中，很多文件都是不需要版本管理的，比如Python的.pyc文件和一些包含密码的配置文件等等。这个文件的内容是一些规则，Git会根据这些规则来判断是否将文件添加到版本控制中。 Git忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件的使用方法 首先，在你的工作区新建一个名称为.gitignore的文件。 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。 有时对于git项目下的某些文件，我们不需要纳入版本控制，比如日志文件或者IDE的配置文件，此时可以在项目的根目录下建立一个隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件），然后在.gitignore中写入需要忽略的文件。 1234[root@kevin ~]# cat .gitignore*.xml*.log*.apk .gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。 .gitignore配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。 .gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）： 1）从命令行中读取可用的忽略规则 2）当前目录定义的规则 3）父级目录定义的规则，依次递推 4）$GIT_DIR/info/exclude 文件中定义的规则 5）core.excludesfile中定义的全局规则 .gitignore忽略规则的匹配语法在 .gitignore 文件中，每一行的忽略规则的语法如下：1）空格不匹配任意文件，可作为分隔符，可用反斜杠转义2）以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。3）可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。4）以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。5）以星号”*”通配多个字符，即匹配多个任意字符；使用两个星号”“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。6）以问号”?”通配单个字符，即匹配一个任意字符；7）以方括号”[]”包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。8）以叹号”!”表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。 需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； .gitignore忽略规则简单说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 表示忽略根目录下的bin文件/*.c: 表示忽略cat.c，不忽略 build/cat.cdebug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件/mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 温馨提示： 如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一单push，处理起来会非常麻烦。 .gitignore忽略规则常用示例1）示例 比如你的项目是java项目，.java文件编译后会生成.class文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用github的.gitignore文件模板将这些忽略文件信息复制到你的.gitignore文件中去： 1234567891011121314151617181920212223# Compiled class file*.class # Log file*.log # BlueJ files*.ctxt # Mobile Tools for Java (J2ME).mtj.tmp/ # Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid* 可以看到github为我们提供了最流行的.gitignore文件配置。保存.ignore文件后我们查看下git status，检查下是否还有我们不需要的文件会被添加到git中去：123456789101112131415$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.java Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) Config.ini 比如我的项目目录下有一个Config.ini文件，这个是个本地配置文件我不希望上传到git中去，我们可以在gitignore文件中添加这样的配置：1Config.ini 或者你想忽略所有的.ini文件你可以这样写：1*.ini 如果有些文件已经被你忽略了，当你使用git add时是无法添加的，比如我忽略了*.class，现在我想把HelloWorld.class添加到git中去：1234$ git add HelloWorld.classThe following paths are ignored by one of your .gitignore files:HelloWorld.classUse -f if you really want to add them. git会提示我们这个文件已经被我们忽略了，需要加上-f参数才能强制添加到git中去：1234567891011$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.class new file: HelloWorld.java 这样就能强制添加到缓存中去了。如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用rm命令将其从中移除：12$ git rm HelloWorld.class --cachedrm 'HelloWorld.class' 如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。 2）示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657下面是曾经线上使用过的一个gerrit里项目代码的.gitignore的配置（在项目中添加.gitignore过滤文件，在git push到gerrit里即可）[wangshibo@gerrit-server hq_ios]$ cat .gitignore#Built application files*.apk*.ap_ # Files for the Dalvik VM*.dex # Java class files*.class # Generated files*/bin/*/gen/*/out/ # Gradle files.gradle/build/*/build/gradlewgradlew.bat # Local configuration file (sdk path, etc)local.properties # Proguard folder generated by Eclipseproguard/ # Log Files*.log # Android Studio Navigation editor temp files.navigation/ # Android Studio captures foldercaptures/ # Intellij*.iml*/*.iml # Keystore files#*.jks#gradle wrappergradle/ #some local files*/.settings/*/.DS_Store.DS_Store*/.idea/.idea/gradlewgradlew.batunused.txt 3）示例123456789101112131415161718192021222324252627[wangshibo@gerrit-server hq_ios$ cat .gitignore# Lines that start with '#' are comments.# IntelliJ IDEA Project files.idea*.iml*.ipr*.iwsout # Eclipse Project files.classpath.project.settings/ bin/gen/local.properties .DS_StoreThumbs.db *.bak*.tem*.temp#.swp*.*~~*.* .gitignor忽略规则查看如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：12$ git check-ignore -v HelloWorld.class.gitignore:1:*.class HelloWorld.class 可以看到HelloWorld.class匹配到了我们的第一条*.class的忽略规则所以文件被忽略了。 简单来说，要实现过滤掉Git里不想上传的文件，如上介绍三种方法能达到这种目的，只不过适用情景不一样：12345678910111213141516171819202122232425262728293031323334353637383940414243============第一种方法===========针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。 配置步骤如下：在工程根目录下建立.gitignore文件，将要排除的文件或目录 写到.gitignore这个文件中，其中有两种写入方法： a)使用命令行增加排除文件排除以.class结尾的文件 echo "*.class" &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore的文件。排除bin目录下的文件 echo "bin/" &gt;.gitignore b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个，例如：*.class*.apkbin/gen/.settings/proguard/ ===========第二种方法===========全局设置排除文件，这会在全局起作用，只要是Git管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。配置步骤如下：a）像方法（1）一样，也需要建立一个.gitignore文件，把要排除的文件写进去。b）但在这里，我们不规定一定要把.gitnore文件放到某个工程下面，而是任何地方，比如我们这里放到了Git默认的Home路径下，比如：/home/wangshibo/hqsb_iosc）使用命令方式可以配置全局排除文件: # git config --global core.excludesfile ~/.gitignore 你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore。 说明Git把文件过滤规则应用到了Global的规则中。 ===========第三种方法===========单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去：*.class*.apkbin/gen/.settings/proguard/ 这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法一和方法二比较起来没有一点优势。 Git忽略规则(.gitignore配置）不生效原因和解决12345678910111213141516171819第一种方法:.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。 解决方法: git清除本地缓存（改变成未track状态），然后再提交:[root@kevin ~]# git rm -r --cached .[root@kevin ~]# git add .[root@kevin ~]# git commit -m 'update .gitignore'[root@kevin ~]# git push -u origin master 需要特别注意的是：1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件， 对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 第二种方法:（推荐）在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。[root@kevin ~]# git update-index --assume-unchanged PATH //在PATH处输入要忽略的文件 在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。这时候不可以直接使用”git rm directory”，这样会删除本地仓库的文件。可以使用”git rm -r –cached directory”来删除缓冲，然后进行”commit”和”push”，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用”git add -A”来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。 额外说明：git库所在的文件夹中的文件大致有4种状态 123456789101112131415161718Untracked:未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify:文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified:文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态,使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged:暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.执行git reset HEAD filename取消暂存, 文件状态为Modified Git 状态 untracked 和 not staged的区别- [x] 1）untrack 表示是新文件，没有被add过，是为跟踪的意思。- [ ] 2）not staged 表示add过的文件，即跟踪文件，再次修改没有add，就是没有暂存的意思 文献参考来源：https://www.cnblogs.com/kevingrace/p/5690241.html]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得收藏的网站]]></title>
    <url>%2F%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要本文主要是收集比较好用的网站。 包括学术，电影，音乐，下载资源，和用的网站 1、 虫部落搜索 2、 虫部落学术 3、 虫部落设计搜索 4、 latexstudio排版学习 5、 短网链生成 wailian suo 6、 盒子部落便民工具系列 7、 艺术字+ 二维码设计 艺术字设计 个性二维码 最终效果： 8、 图床 路过图床 SM.MS图床，生成后每次i.loli.net后缀的名字，更多可以参见百度搜索。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32串口通信配置（USART1+USART2+USART3+UART4）]]></title>
    <url>%2FSTM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要：本文是通过分享几个通用的串口函数，实现对STM32芯片的多个串口操作和多种收发数据方式，实现串口通信的功能，本文的各个驱动代码经测试都可以直接使用，本人写的这部分代码开源 (。^_^。) 一、串口一的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗主函数必须在4s内进行一次喂狗不然系统会复位； 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART1_RX_BUF[21]; u8 USART1_RX_CNT=0;void IWDG_Configuration(void); void Usart1_Init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE);//使能USART1,GPIOA,C时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART1, ENABLE); //使能串口1 &#125;/*** USART1发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART1_Send_Data(u8 *buf,u16 len)&#123; u16 t; GPIO_SetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(USART1,buf[t]); &#125; while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); GPIO_ResetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Usart1_Init(9600);//串口1波特率设置为9600 IWDG_Configuration(); while(1) &#123; IWDG_ReloadCounter();//4s内必须喂狗不然复位 if(USART1_RX_CNT==21)//数据接收完成 &#123; USART1_RX_CNT=0;//指针复位 //将接收到的数据发送出去 USART1_Send_Data(USART1_RX_BUF,21);//通过串口1将接收到的固定长度字符发送出去 &#125; &#125; &#125;/*** 接收指定长度的字符串* 比如接收固定大小为21个字节的字符串**/void USART1_IRQHandler(void) //串口1中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据 if(USART1_RX_CNT&lt;21)//对于接收指定长度的字符串 &#123; USART1_RX_BUF[USART1_RX_CNT]=Res; //记录接收到的值 USART1_RX_CNT++; //接收数据增加1 &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART1,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART1); USART_ClearFlag(USART1,USART_FLAG_ORE); &#125; USART_ClearFlag(UART1,USART_IT_RXNE); //一定要清除接收中断&#125;/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description:配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗 主函数必须在4s内进行一次喂狗不然系统会复位revise Description:===============================================================================*/void IWDG_Configuration(void) &#123; /* 写入0x5555,用于允许狗狗寄存器写入功能 */ IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); /* 狗狗时钟分频,40K/256=156HZ(6.4ms)*/ IWDG_SetPrescaler(IWDG_Prescaler_256); /* 喂狗时间 5s/6.4MS=781 .注意不能大于0xfff*/ IWDG_SetReload(781);//781（5s时间） IWDG_SetReload(3125);//781（20s时间） IWDG_Enable();//启用定时器 IWDG_ReloadCounter();&#125; 二、串口二的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART2_RX_BUF[250]; u8 USART2_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记 void Usart2_Init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; //|RCC_APB2Periph_AFIO RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//使能GPIOA时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能USART2时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,ENABLE);//复位串口2 RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,DISABLE);//停止复位 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //使能串口2中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级2级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级2级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 USART_InitStructure.USART_BaudRate = bound;//波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//8位数据长度 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;///奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART2, &amp;USART_InitStructure); ; //初始化串口 USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启中断 USART_Cmd(USART2, ENABLE); //使能串口 &#125;/*** USART2发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART2_Send_Data(u8 *buf,u16 len)&#123; u16 t; for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); USART_SendData(USART2,buf[t]); &#125; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); &#125;/*** 这也是一个接收函数，可以用，也可以用下面main函数的方法调用* USART2查询接收到的数据* buf:接收缓存首地址* len:读到的数据长度**/void USART2_Receive_Data(u8 *buf)&#123; u8 rxlen=USART2_RX_CNT; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 while(rxlen!=USART2_RX_CNT) &#123; rxlen=USART2_RX_CNT; delay_ms(10); &#125; for(i=0;i&lt;(USART2_RX_CNT);i++) &#123; buf[i] = USART2_RX_BUF[i]; USART2_RX_BUF[i] = 0; &#125; USART2_RX_CNT=0; //清零 &#125;void main(void)&#123; Usart2_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA)//数据接收完成 &#123; USART2_RX_STA=0; //将接收到的数据发送出去 USART2_Send_Data(USART2_RX_BUF,USART2_RX_CNT);//通过串口1将接收到的固定长度字符发送出去 USART2_RX_CNT=0;//指针复位 &#125; &#125; &#125;void USART2_IRQHandler(void)&#123; u8 res; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收到数据 &#123; res =USART_ReceiveData(USART2); //读取接收到的数据 if(USART2_RX_STA==0) &#123; USART2_RX_BUF[USART2_RX_CNT] = res; //记录接收到的值 //当数据结尾收到0xA0和0xA1代表数据接收完成，是一串完整的数据 if(USART2_RX_BUF[USART2_RX_CNT-1]==0xA0&amp;&amp;USART2_RX_BUF[USART2_RX_CNT]==0xA1) USART2_RX_STA=1;//表示接收数据结束 USART2_RX_CNT++; //接收数据增加1 &#125; &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART2); USART_ClearFlag(USART2,USART_FLAG_ORE); &#125; USART_ClearFlag(UART2,USART_IT_RXNE); //一定要清除接收中断 &#125; 三、串口三的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART3_TIMEOUT_Setting 800 //(ms)u8 USART3_RX_BUF[250]; u16 USART3_RX_CNT=0;u16 USART3_RX_TIMEOUT=0; //接收状态标记 void Timer1CountInitial(void);void USART3_Init(u32 baud) &#123; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量，用来初始化GPIO //使能串口的RCC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); //使能UART3所在GPIOB的时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); //串口使用的GPIO口配置 // Configure USART3 Rx (PB.11) as input floating GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); // Configure USART3 Tx (PB.10) as alternate function push-pull GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //配置串口 USART_InitStructure.USART_BaudRate = baud; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // Configure USART3 USART_Init(USART3, &amp;USART_InitStructure);//配置串口3 // Enable USART3 Receive interrupts 使能串口接收中断 USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); // Enable the USART3 USART_Cmd(USART3, ENABLE);//使能串口3 //串口中断配置 //Configure the NVIC Preemption Priority Bits NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // Enable the USART3 Interrupt NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); &#125; void USART3_Sned_Char(u8 temp) &#123; USART_SendData(USART3,(u8)temp); while(USART_GetFlagStatus(USART3,USART_FLAG_TXE)==RESET); &#125;void USART3_Sned_Char_Buff(u8 buf[],u32 len) &#123; u32 i; for(i=0;i&lt;len;i++) USART3_Sned_Char(buf[i]); &#125;void main(void)&#123; Timer1CountInitial(); Usart3_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART3_RX_TIMEOUT==USART3_TIMEOUT_Setting) &#123; USART3_RX_TIMEOUT=0; USART3_Sned_Char_Buff(USART3_RX_BUF,USART3_RX_CNT);//将接收到的数据发送出去 USART3_RX_CNT=0; &#125; &#125; &#125;void USART3_IRQHandler(void) //串口3中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) &#123; USART3_RX_TIMEOUT=0; USART3_RX_BUF[USART3_RX_CNT++] = USART_ReceiveData(USART3); //读取接收到的数据 &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART3,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART3); USART_ClearFlag(USART3,USART_FLAG_ORE); &#125; USART_ClearITPendingBit(USART3, USART_IT_RXNE);&#125;//放到主函数的初始化中初始化void Timer1CountInitial(void)&#123; //定时=36000/72000x2=0.001s=1ms; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; /////////////////////////////////////////////////////////////// RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） TIM_TimeBaseStructure.TIM_Prescaler = 7200-1;//时钟预分频 TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频1 TIM_TimeBaseStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure); TIM_ClearFlag(TIM1,TIM_FLAG_Update); TIM_ITConfig(TIM1,TIM_IT_Update,ENABLE); TIM_Cmd(TIM1, ENABLE);&#125;void TIM1_UP_IRQHandler(void)&#123; //TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） if (TIM_GetITStatus(TIM1, TIM_IT_Update) != RESET) &#123; if(USART3_RX_TIMEOUT&lt;USART3_TIMEOUT_Setting) USART3_RX_TIMEOUT++; &#125; TIM_ClearITPendingBit(TIM1,TIM_IT_Update);&#125; 四、串口四的配置 （初始化+中断配置+中断接收函数） 注意串口四的中断优先级没有贴出来，和前面的三个一样的配置，为了不占用过多的篇幅就不贴中断优先级配置了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART4_TIMEOUT_Setting 800 //(ms)u8 USART4_RX_BUF[250]; u16 USART4_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记void Systick_delay_init(u8 SYSCLK);u8 virtual_delay(u32 num,u8 unit);//通用异步收发器UART4void UART4_Init(u32 bound)&#123; USART_InitTypeDef USART_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //used for USART3 full remap //GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);//for UART4 //Configure RS485_TX_EN PIN GPIO_InitStructure.GPIO_Pin = RS485_TX_EN_PIN; //PC9端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(RS485_TX_EN_PORT, &amp;GPIO_InitStructure); RS485_TX_EN=0; //设置485默认为接收模式 /* Configure USART Tx as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* Configure USART Rx as input floating */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(UART4, &amp;USART_InitStructure); //USART_Init(USART3, &amp;USART_InitStructure); /* Enable the USART */ USART_Cmd(UART4, ENABLE); USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_ClearFlag(UART4,USART_FLAG_TC); &#125;//USART1查询接收到的数据//buf:接收缓存首地址//len:读到的数据长度void UART4_Receive_Data(u8 *buf)&#123; u8 rxlen=21; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 RS485_RX_FLAG = 0; if((UART4_RX_BUF[0]==0x01)&amp;&amp;(UART4_RX_BUF[1]==0x03)) &#123; for(i=0;i&lt;rxlen;i++) &#123; buf[i]=UART4_RX_BUF[i]; UART4_RX_BUF[i] = 0; &#125; RS485_RX_FLAG = 1; &#125; UART4_RX_CNT=0; //清零&#125;//USART1发送len个字节.//buf:发送区首地址//len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)void UART4_Send_Data(u8 *buf,u16 len)&#123; u16 t; RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(UART4,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(UART4,buf[t]); &#125; while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET); RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Systick_delay_init(72); Usart4_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA) &#123; if(virtual_delay(USART4_TIMEOUT_Setting,MS))//超过800ms空闲则可以读取数据 &#123; UART4_Send_Data(UART4_RX_BUF,UART4_RX_CNT); USART2_RX_STA=0; UART4_RX_CNT=0; &#125; &#125; &#125; &#125;void UART4_IRQHandler(void) //UART4 Receive Interrupt &#123; u8 Res; if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(UART4);//(USART1-&gt;DR); //读取接收到的数据 UART4_RX_BUF[UART4_RX_CNT&amp;0XFF]=Res; //回传的数据存入数组,0X3F限制为64个数值 UART4_RX_CNT++; USART2_RX_STA=1; &#125; if( USART_GetITStatus(UART4, USART_IT_TC) == SET ) &#123; USART_ClearFlag(UART4, USART_FLAG_TC); &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(UART4,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(UART4); USART_ClearFlag(UART4,USART_FLAG_ORE); &#125;// USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);//临时关闭接收中断 USART_ClearFlag(UART4,USART_IT_RXNE); //一定要清除接收中断 &#125; //初始化延迟函数//SYSTICK的时钟固定为HCLK时钟的1/8//SYSCLK:系统时钟void Systick_delay_init(u8 SYSCLK)&#123; SysTick-&gt;CTRL&amp;=0xfffffffb;//bit2清空,选择外部时钟 HCLK/8// SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //选择外部时钟 HCLK/8 fac_us=SYSCLK/8; fac_ms=(u16)fac_us*1000;&#125;/*===============================================================================Author:peter panDate: Description: 查询式分时或叫做轮询式（近似延时）。本函数是用于执行高效率场合的查询延时，但是一个for or while 循环中只能用一次。revise Description: @ num : //分时查询的周期计数值 @ unit : //分时查询的周期单位 @@ParaValue ： MS //周期单位为MS毫秒级 US //周期单位为US微秒级@ virtual_delay_status : //静态变量 @@ParaValue ： SET //SYSTICK正在占用中，请勿用 RESET //SYSTICK空闲，可以使用@ReValue : with zero mean Time non-arrive ,one representative Time arrived ,you can do task;##example if(virtual_delay(1000,MS)) LedFlash(); //1000ms LED闪烁一下===============================================================================*/u8 virtual_delay(u32 num,u8 unit)&#123; u32 temp; if(virtual_delay_status==RESET) // SYSTICK空闲，可以使用 &#123; if(unit==MS) &#123; SysTick-&gt;LOAD=(u32)num*Delay_SYSCLK*125;//时间加载(SysTick-&gt;LOAD为24bit) SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125;else if(unit==US) &#123; SysTick-&gt;LOAD=num*Delay_SYSCLK/8; //时间加载 SysTick-&gt;VAL=0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125; virtual_delay_status=SET; return 0; &#125; else &#123; //virtual_delay_status==SET SYSTICK被占用 temp=SysTick-&gt;CTRL; if(!(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16))))//等待时间到达 &#123; SysTick-&gt;CTRL=0x00; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 virtual_delay_status=RESET; return 1; &#125;else return 0; &#125;&#125; 附上本人这篇博客地址]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32复位及通过函数判断是何种条件出发的复位]]></title>
    <url>%2FSTM32%E5%A4%8D%E4%BD%8D%E5%8F%8A%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E6%98%AF%E4%BD%95%E7%A7%8D%E6%9D%A1%E4%BB%B6%E5%87%BA%E5%8F%91%E7%9A%84%E5%A4%8D%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[摘要STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。本文将通过实际的代码来解释各种情况下，软、硬件导致芯片复位的判别和怎样采取措施。 一、系统复位系统复位将复位所有寄存器至它们的复位状态。 当发生以下任一事件时，产生一个系统复位： NRST引脚上的低电平(外部复位) 2. 窗口看门狗计数终止(WWDG复位) 独立看门狗计数终止(IWDG复位) 软件复位(SW复位) 低功耗管理复位 可通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源。软件复位通过将Cortex™-M3中断应用和复位控制寄存器中的SYSRESETREQ位置’1’，可实现软件复位。请参考Cortex™-M3技术参考手册获得进一步信息。 1.1 低功耗管理复位在以下两种情况下可产生低功耗管理复位： 在进入待机模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STDBY位置’1’将使能该复位。这时，即使执行了进入待机模式的过程，系统将被复位而不是进入待机模式。 在进入停止模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STOP位置’1’将使能该复位。这时，即使执行了进入停机模式的过程，系统将被复位而不是进入停机模式。关于用户选择字节的进一步信息，请参考STM32F10xxx闪存编程手册。 电源复位电源复位当以下事件中之一发生时，产生电源复位： 上电/掉电复位(POR/PDR复位) 从待机模式中返回 图4) 电源复位将复位除了备份区域外的所有寄存器。(见图中复位源将最终作用于RESET引脚，并在复位过程中保持低电平。复位入口矢量被固定在地址0x0000_0004。 芯片内部的复位信号会在NRST引脚上输出，脉冲发生器保证每一个(外部或内部)复位源都能有至少20μs的脉冲延时；当NRST引脚被拉低产生外部复位时，它将产生复位脉冲。 三、备份域复位 备份区域拥有两个专门的复位，它们只影响备份区域(见图4)。 当以下事件中之一发生时，产生备份区域复位。 软件复位，备份区域复位可由设置备份域控制寄存器 (RCC_BDCR)(见6.3.9节)中的BDRST位产生。 在VDD和VBAT两者掉电的前提下，VDD或VBAT上电将引发备份区域复位。 四、复位的标志位 五、复位标志位检索/判断什么原因导致的复位标志位判断的代码由官方库中给定代码如下： FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)；//FlagStatus 分为SET和RESET两种； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @brief Checks whether the specified RCC flag is set or not. * @param RCC_FLAG: specifies the flag to check. * * For @b STM32_Connectivity_line_devices, this parameter can be one of the * following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_PLL2RDY: PLL2 clock ready * @arg RCC_FLAG_PLL3RDY: PLL3 clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * For @b other_STM32_devices, this parameter can be one of the following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * @retval The new state of RCC_FLAG (SET or RESET). */FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)&#123; uint32_t tmp = 0; uint32_t statusreg = 0; FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_RCC_FLAG(RCC_FLAG)); /* Get the RCC register index */ tmp = RCC_FLAG &gt;&gt; 5; if (tmp == 1) /* The flag to check is in CR register */ &#123; statusreg = RCC-&gt;CR; &#125; else if (tmp == 2) /* The flag to check is in BDCR register */ &#123; statusreg = RCC-&gt;BDCR; &#125; else /* The flag to check is in CSR register */ &#123; statusreg = RCC-&gt;CSR; &#125; /* Get the flag position */ tmp = RCC_FLAG &amp; FLAG_Mask; if ((statusreg &amp; ((uint32_t)1 &lt;&lt; tmp)) != (uint32_t)RESET) &#123; bitstatus = SET; &#125; else &#123; bitstatus = RESET; &#125; /* Return the flag status */ return bitstatus;&#125; 当然判断完后，我们需要将复位类型的标志置位以防后期出现重复多次判断 void RCC_ClearFlag(void)；//清除复位执行函数 代码原型如下: 12345678910111213141516171819202122232425262728293031/** * @brief Clears the RCC reset flags. * @note The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST, * RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST * @param None * @retval None */void RCC_ClearFlag(void)&#123; /* Set RMVF bit to clear the reset flags */ RCC-&gt;CSR |= CSR_RMVF_Set;&#125;``` * 在使用时，只需要执行如下语句即可：```Cif(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET) &#123; //这是上电复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET) &#123; //这是外部RST管脚复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_SFTRST)!= RESET) &#123; //这是外部RST管脚复位 &#125; RCC_ClearFlag();//清除RCC中复位标志 六、STM32软件复位方法在Cortex-M3权威指南中有这么一句话这里有一个要注意的问题：从SYSRESETREQ 被置为有效，到复位发生器执行复位命令，往往会有一个延时。在此延时期间，处理器仍然可以响应中断请求。但我们的本意往往是要让此次执行到此为止，不要再做任何其它事情了。所以，最好在发出复位请求前，先把FAULTMASK 置位。所以最好在将FAULTMASK 置位才万无一失。 12345void mcuRestart(void)&#123; __set_FAULTMASK(1); //关闭所有中断 NVIC_SystemReset(); //复位｝]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之tkinter入坑Pack]]></title>
    <url>%2Fpython%E4%B9%8Btkinter%E5%85%A5%E5%9D%91Pack%2F</url>
    <content type="text"><![CDATA[摘要：python 中写GUI界面还是有很多方法的，下面我就说说这个tkinter吧，感觉刚上手不久，感觉不好用的样子，可能是我自己的原因导致的用不顺手。这篇主要写tkinter的pack（）方法。 tkinter 的pack()可以设置的属性 我从官网帮助手册中看到的是这样 pack_configure(self, cnf={}, **kw)Pack a widget in the parent widget. Use as options: 12345678910111213after=widget - pack it after you have packed widgetanchor=NSEW (or subset) - position widget according to given directionbefore=widget - pack it before you will pack widgetexpand=bool - expand widget if parent size growsfill=NONE or X or Y or BOTH - fill widget if widget growsin=master - use master to contain this widgetin_=master - see 'in' option descriptionipadx=amount - add internal padding in x directionipady=amount - add internal padding in y directionpadx=amount - add padding in x directionpady=amount - add padding in y directionside=TOP or BOTTOM or LEFT or RIGHT - where to add this widget. 上面的部分中文意思是说 12anchor=NSEW,表示设置我们要加的当前部件的位置side=TOP or BOTTOM or LEFT or RIGHT 表示在父类容器的什么地方家我们的部件 上面的界面代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8import tkinter# 导入TK的符号常亮from tkinter.constants import *def sendStr(): print('Data Send Ok!')# 实例化TK类，主窗口必须为.TK(),而其他子窗口为.Toplevel()top = tkinter.Tk()# 设置窗口的尺寸大小top.wm_geometry('320x480+1000+100')# 不允许 改变 窗口的宽和高top.wm_resizable(False,False)# 设置窗口标题top.title('TCP Server')# 设置label标签L1 = tkinter.Label(top, text='TCP Sever;\n20108/09/15', width=15, justify=LEFT, relief=RIDGE, background='#6699ff', )\ .pack_configure(anchor=S, side=TOP, ipady=2, pady=2, fill=NONE)# 设置容器frame1 = tkinter.Frame(top,height=80,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame1.pack(fill=NONE,ipady=2,expand=False)# 添加接收区文字标签L2 = tkinter.Label(frame1,text='接\n收\n区',width=2, justify=LEFT, font=("宋体", 12, "bold"),)\ .pack(padx=2,pady=40,side=LEFT,anchor=N)# 添加接收区的文本框txt1 = tkinter.Text(frame1,width = 40, height = 10).pack(padx=2,pady=10,side=RIGHT,anchor=N)frame2 = tkinter.Frame(top, relief=RIDGE,bg='#3366ff')frame2.pack(fill=X, padx=2,pady=10,side=TOP)# 加一个复选框，一个按键chk_text = 'Hex Display'int_if_choise = tkinter.IntVar()chk1 = tkinter.Checkbutton(frame2,text=chk_text,font=('黑体',12),variable=int_if_choise,onvalue='OK',offvalue='NO')chk1.pack(fill=NONE,side=LEFT,padx=2,pady=10)print('shuchu:',int_if_choise)# 设置容器frame3 = tkinter.Frame(top,height=120,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame3.pack(fill=X,ipady=2,expand=False)# 设置字符串变量ServerReceiveVar = tkinter.StringVar(top,'')L3 = tkinter.Label(frame3, text='Cache&amp;Input:',font=('黑体',12))L3.pack(fill=NONE, expand=NO, side=TOP, anchor=W, padx=2,pady=10)txt2 = tkinter.Text(frame3, height = 2, width = 30).pack(padx=2, pady=2, ipady=4, side=LEFT, anchor=N)button1 = tkinter.Button(frame3,text='Send Str', command=sendStr).pack(side=TOP, anchor=W, padx=2, pady=4)# IP 列表button2 = tkinter.Button(frame3,text="Exit",command=top.destroy).pack(side=TOP, anchor=N, padx=2, pady=10)top.mainloop() 123456789101112from Tkinter import *root = Tk()w = Label(root, text="red", bg="red", fg="white")w.pack(padx=5, pady=10, side=LEFT)w = Label(root, text="green", bg="green", fg="black")w.pack(padx=5, pady=20, side=LEFT)w = Label(root, text="blue", bg="blue", fg="white")w.pack(padx=5, pady=20, side=LEFT)mainloop()]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ MFC 界面实现套接字（socket) 通信]]></title>
    <url>%2FMFC-Socket-%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[摘要 Socket 套接字的概念 Socket 函数功能 MFC 介绍 TCP 变成步骤 TCP 上位机实现 Socket 套接字的概念引用百度百科的一句话：网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 一段形象的比喻： 建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 Socket的英文原义是“孔”或“插座”。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 SuperSocke,可扩展的 Socket 服务器框架 socket.io github 网页或者官网 Socket 函数功能具体函数如下： socket()函数 bind()函数 connect()函数 listen()函数 accept()函数 send()和recv()函数 sendto()和recvfrom()函数 close()和shutdown()函数 getpeername()函数 gethostname()函数 socket() 函数1int socket(int domine,int type,int protocol); 参数(int domin)： 函数参数，即协议域，又称为协议族。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。通常情况下我们使用AF_INET。 AF_INET的定义是：#define AF_INET 2，所以这里的参数都是int型的 参数(int type)： :是套接口类型，主要SOCK_STREAM(建立TCP连接)、SOCK_DGRAM（建立UDP）、SOCK_RAW；SOCK_STREAM(建立TCP连接)：提供面向连接的可靠的数据传输服务。数据被看作是字节流，无长度限制。例如FTP协议就采用这种。SOCK_DGRAM（建立UDP）：提供无连接的数据传输服务，不保证可靠性。 SOCK_RAW：该接口允许对较低层次协议，如IP，ICMP直接访问。 参数(int protocole)： 指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。通常情况系设为0。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 函数返回值(int): 成功：返回套接字描述符（套接字的索引） 失败：返回-1 bind() 函数一旦你有一个套接字，你可能要将套接字和机器上的一定的端口关联 起来。(如果你想用listen()来侦听一定端口的数据，这是必要一步–MUD 告 诉你说用命令 “telnet x.y.z 6969”。)如果你只想用 connect()，那么这个步 骤没有必要。但是无论如何，请继续读下去。 1int bind(int sockfd, struct sockaddr *my_addr, int addrlen); 参数(int sockfd)： sockfd 是调用 socket 返回的文件描述符。 参数(struct sockaddr *my_addr)： my_addr 是指向数据结构 struct sockaddr 的指针，它保存你的地址(即端口和 IP 地址) 信息。 参数(int addrlen)： addrlen 设置为 sizeof(struct sockaddr)。 connect()函数现在我们假设你是个 telnet 程序。你的用户命令你得到套接字的文件 描述符。你听从命令调用了socket()。下一步，你的用户告诉你通过端口 23(标准 telnet 端口)连接到”132.241.5.10”。你该怎么做呢? 幸运的是，你正在阅读 connect()–如何连接到远程主机这一章。你可 不想让你的用户失望。 1int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 参数(int sockfd)： sockfd 是系统调用 socket() 返回的套接字文件描述符。 参数(struct sockaddr *serv_addr)： serv_addr 是 保存着目的地端口和 IP 地址的数据结构 struct sockaddr。 参数(int addrlen)： addrlen 设置 为 sizeof(struct sockaddr)。 listen()函数是换换内容得时候了。假如你不希望与远程的一个地址相连，或者说， 仅仅是将它踢开，那你就需要等待接入请求并且用各种方法处理它们。处 理过程分两步：首先，你听–listen()，然后，你接受–accept() (请看下面的 内容)。 1int listen(int sockfd, int backlog); 参数(int sockfd)： sockfd 是调用 socket() 返回的套接字文件描述符。 参数(int backlog)： backlog 是在进入 队列中允许的连接数目。 accept()函数send()和recv()函数sendto()和recvfrom()函数close()和shutdown()函数getpeername()函数gethostname()函数本节参考了博文 MFC 介绍TCP 上位机实现]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Socket</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr+freenom实现主机域名的绑定]]></title>
    <url>%2Fvultr-freenom%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[vultr+freenom实现主机域名的绑定 摘要本文将通过实例进行演示，给大家介绍如何用免费的域名，绑定我们的云主机，只需要登录Freenom注册个账号就可以免费申请免备案域名了，心动请先不要忙行动，点击阅读更多，先看看本文的免费域名申请绑定主机的方法吧。 1、注册freenom域名 进入 freenom 网站,在界面的菜单中选择“Servers”–&gt;”Register a New Domains”，如下图所示: 可能在此之前需要先注册一个账号，具体网站的账号怎么注册，自己摸索下，并不复杂，这里我们只讲怎么注册域名并解析到你的主机。 接下来在“My Domains”页面上的输入框中输入你想注册的免费域名，并搜索下是否已经被注册了，输入框在如下图中的红框所示，例如我输入：smriti 搜索结果显示，好几个是免费的，我们只需要选择一个就行，如下截图所示： 随便选择一个，“Get it now” 即可比如我选择TK域名，然后进入我的购物车，选择免费12个月，如下图： 接下来在USE DNS处选择自己需要解析到的主机IP地址上，也就是把你的云服务器的主机地址填到下图的红框中，Hostname不要动，保持默认（ 一个是yourdot.tk,另一个是www.yourdot.tk ），如下图： 接下来点击“COntinue”即可。 注意如果你现在没有主机IP，你可以先不填，后期再填写，后期填写只需要进入“My Domains” 选择你注册的域名，点击右边的“Manage Domain”，然后选择第四个菜单，”Manage Freenom DNS”,然后添加域名解析到主机，如下图所示： 接下来就是等待，因为域名解析，不会一下子就解析成功的所以你需要等5-30分钟不等，如果一个小时后还是解析不成功，可能就是你的主机IP填写错误 重要的事情再说一遍，就是以上域名解析填写完成后，还需要进行等待，一般5-30分钟。5分钟内访问该网站可能提示解析错误，所以要等待啊。 有的需要主机上面也要填写DNS绑定域名,比如阿里云主机,但是我这是国外的主机和国外的免费域名，好像不要要云主机上面操作，直接在域名服务商网页上绑定主机IP就成功访问了。 2、主机注册 推荐好用的还便宜的云主机：vultr 、 和 搬瓦工 加入你已经购买了云虚拟主机，点击进入主机管理，如下图所示： 添加主机域名绑定 最后一步，主机中绑定域名，如下图：]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-index%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要 基于这章节的想法和具体需要完成的任务如下： 首先是基于深度学习的歌曲分类 基于深度学习的目标检测 基于深度学习的手写字计算速度改进 基于深度学习的人脸识别等例子实现界面设计 优秀学者/资源学者、教授 徐志强副教授(Associate Professor Richard Xu),其 github主页 an AI Professor in Machine Learning at UTS.]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要欢迎来到我的博文主页，你可以进一步了解我，通过聚水渊主页 Hexo !和我的github 写作目的 为了更好的学习 每天总结 看到自己每天的进步 遇见最优秀的自己，下面是我的其他博客地址 我的博客园 我的CSDN 新浪博客 网易博客 说说我之前的英文名和现在的英文名之前我的firstname 是pertor 现在是porter，不是一个人 ？不，是一个人的，因为pertor是西班牙的名字，porter是英文名字。都是一个人。 我的网易云最后我贴下我的网易笔记]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 中安装sublime_text3]]></title>
    <url>%2Fubuntu-%E4%B8%AD%E5%AE%89%E8%A3%85sublime-text3%2F</url>
    <content type="text"><![CDATA[摘要Porter PanEnter “Alt+m” will show Markdown Preview 安装 输入注册码 汉化 安装插件 中文输入bug修复 1.1 安装&emsp;&emsp;建议和我一样初学的直接安装，不要直接下载官方的离线包解压了，不然还得自己配置什么dash中显示，什么的环境配置乱七八糟的 123451、 wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -2、 sudo apt-get install apt-transport-https3、 echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list4、 sudo apt-get update5、 sudo apt-get install sublime-text 1.2 输入注册码&emsp;&emsp;在输入注册码之前先更改hosts，ubuntu中hosts位于： vim /etc/hosts或者gedit /etc/hosts,然后加入如下两行 121、 127.0.0.1 www.sublimetext.com2、 127.0.0.1 license.sublimehq.com &emsp;&emsp;然后保存，此时dash中输入sublime，找到我们安装的软件，打开后在界面菜单中选择help–&gt;enter license，然后输入如下注册码12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 点击确定，然后就可以 enjoy it! 在这还没结束，下面开始汉化 1.3 汉化 &emsp;&emsp;打开软件，直接按下“shift+ctrl+p”在弹出的框内输入ip,然后点击”package control：install pakage”,出来后输入”Chinese​Localizations”来安装Chinese​Localizations插件，然后重启，至此汉化结束。 1.4 安装markdown插件 &emsp;&emsp;在软件界面输入“shift+ctrl+p”,然后输入“ip”，然后选择，packageinstall ，然后输入“Markdown Editing“ + ”MarkdownLivePreview”,分别安装上，然后新建md文件，在编辑界面输入“alt+m”,则进入markdown preview实时显示模式。 1.5 解决Markdown不能输入汉字的问题打开终端： 在终端中输入以下代码12git clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix &amp;&amp; ./sublime-imfix 或者直接进入github的这个仓库：直接下载这个zip包，然后解压，然后在终端中cd到这个解压后的文件夹路径中，最后是在终端中输入1./sublime-imfix 此时重启sublimetext3 然后就可以进行汉字的输入了。 参考：https://blog.csdn.net/qq_41590417/article/details/80461075 https://blog.csdn.net/woaidouya123/article/details/81476551 https://www.cnblogs.com/james-lee/p/6847906.html]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>sublime-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 每次写好后deploy博客]]></title>
    <url>%2FHexo-%E6%AF%8F%E6%AC%A1%E5%86%99%E5%A5%BD%E5%90%8Edeploy%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要：github page 结合Hexo-Yelee或者Next主题,搭建个人博客主页，是很不错的一个选择，个人使用情况，感觉Yelee界面布局啥的还是很不错的。 这篇文章中我将介绍每次我们写好的md博文怎么部署到github page 上去。 本文主要使用的命令行如下： 1、直接部署到网站 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 也可以本地部署，查看浏览效果 2、部署到本地，查看浏览效果 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 我们每次写好的博文如何正确推送至github每次我们写好了博文后，需要上传至我们的github空间中,只需要每次将我们写好的博文放到文件路径：1D:\Github\smritipertor.github.io\source\_posts 如果之前没有安装过 hexo-deployer-git 的话，先执行： 1npm install hexo-deployer-git --save 然后执行如下命令操作： 首先在你之前建好的博文路径：比如我的是 12345hexo generatehexo s //(或者:hexo server)hexo deploy //(或者:hexo d) 说明 一般我们在站点根目录中的“_config.yml”中的文件中设定我们hexo d，的部署文件到那个ID和分支中，设置内容如下： 1234deploy: type: git repository: https://github.com/smritipertor/smritipertor.github.io.git branch: master 以上内容表示，不管我们当前工作在那个分区，只要站点根目录中的“_config.yml”中branch 分区设置好，直接 1hexo d 就可以发布了。 如果你执行：1hexo generate -d 常见错误及解决办法第一种，部署出错出现错误提示，如下：1fatal: in unpopulated submodule '.deploy_git' FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: fatal: in unpopulated submodule '.deploy_git' at ChildProcess.&lt;anonymous&gt; (D:\GitWebsite\smritipertor.github.io\node_modules\hexo-util\lib\spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at ChildProcess.cp.emit (D:\GitWebsite\smritipertor.github.io\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:962:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:251:5) 则你可以直接执行以下命令即可： 12rm -rf .deploy_githexo generate -d 即，删除地电脑本地的.deploy_git文件夹（可能是你上个版本是另一台电脑），然后再生成、部署即可。 至此你的网站上就有了网站数据]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Chrome67版本以后不能离线安装插件的情况]]></title>
    <url>%2F%E8%A7%A3%E5%86%B3Chrome67%E7%89%88%E6%9C%AC%E4%BB%A5%E5%90%8E%E4%B8%8D%E8%83%BD%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要通过本文安装方法可以快速，解决Chrome67版本以后不能离线安装插件的情况。 一般情况下，我们如果使用的Chrome版本为67以后的版本，安装离线插件会出现如下图信息 但是这样我们就真的没法安装离线插件了吗？特别是对想安装翻墙的插件 Proxy SwitchyOmega 的同学来说是一件噩梦。这篇文章讲会告诉读者，这个问题是可以解决的 解决方法如下： 首代开终端输入以下代码 /opt/google/chrome/google-chrome –enable-easy-off-store-extension-install 将会打开google Chrome 浏览器，然后进入浏览器的扩展插件工具界面，如下图所示： 此时请再次将离线下载的插件拖进去，看看是不是能够安装了。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[index]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-index%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要Welcome to My site IODT! This is your very first visit. Check home page of book for more info. If you get any problems when reading, you can find the answer in google or you can ask me on :by @zf_pertor. 文章同步于: 我的gitbook 一、 本章主要是Linux下学习环境的相关配置， 包括学习的开发工具， 也包括系统本埠支持的软件替换或者修复的解决方案。本章组织应包括如下内容： Ubuntu18下有道词典的配置 Ubuntu18 安装Gitbook 二、 优秀工具，资源2.1 LaTex 在线帮助教程]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 推送新的文章到github其他分支上]]></title>
    <url>%2Fgit-%E6%8E%A8%E9%80%81%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0%E5%88%B0github%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要每次编辑博文并通过命令部署网站到github page上时，我们想每天都能将改动后的博文备份到github的一个分支上，实现本地数据同步到云仓库中。 实现本地博客云同步到github page其他分支上 实现本地博客部署到github page上的master分支上 网站部署（建议隔段时间再部署到网站上，短时间内直接部署本地，本地浏览下就好部署到网上 直接部署到github page的master上 123451 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git pull origin proworking #从我的工作分支更新最新的博文和站点配置文件3 git checkout master #将我们的本地切换到master分支4 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中5 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署到本地 本地部署，本地浏览效果 12341 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git checkout master #将我们的本地切换到master分支3 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中4 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 实现从github上获取我仓库中的Proworking分支数据，病拉取到我的本地 将本地的博文再重新push到我的云仓库（proworking) 123git add .git commit -m "添加了：file1.md\file2.md"git push origin HEAD:proworking #一定要添加HEAD 不然会 其他注意事项 下面贴上我遇到的问题 [1] 若果你直接输入命令：1$ git push proworking 可能会出现如下的不正常信息： 12345678Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push proworkingfatal: 'proworking' does not appear to be a git repositoryfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 正确的解决办法是，命令中输入如下代码（加HEAD) 12Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push origin HEAD:proworking 此时会输出正确的提示，具体提示信息如下： 123456789Enumerating objects: 1498, done.Counting objects: 100% (1480/1480), done.Delta compression using up to 4 threadsCompressing objects: 100% (1219/1219), done.Writing objects: 100% (1461/1461), 1.17 MiB | 390.00 KiB/s, done.Total 1461 (delta 187), reused 1300 (delta 139)remote: Resolving deltas: 100% (187/187), completed with 10 local objects.To https://github.com/smritipertor/smritipertor.github.io.git 06b21dd..1ff56b7 HEAD -&gt; proworking]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18 正确 安装ShadowSocket]]></title>
    <url>%2Fubuntu18-%E6%AD%A3%E7%A1%AE-%E5%AE%89%E8%A3%85ShadowSocket%2F</url>
    <content type="text"><![CDATA[ubuntu18 正确安装shadowsocket 摘要为达到能够自由访问全球学习资料，我可谓是绞尽脑汁莫寻方法，目前能做到的除了付费包月的vpn代理机构的，就只能是自己动手自己干的了，但是自己搞旺旺会出很多问题，本文结合晴子实践的经验，将所遇到的问题都一一列下并解决。 1、正常的安装步骤（ubuntu16版本）1234* Ctrl+Alt+T打开终端，输入以下命令安装好GUI界面shadowsocks-qt5* sudo add-apt-repository ppa:hzwhuang/ss-qt5* sudo apt-get update* sudo apt-get install shadowsocks-qt5 但是Ubuntu18.04在安装shadowsocks-qt5时就会出现错误 1仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有 Release 文件 原因： ppa:hzwhuang/ss-qt5 并没有18.04版本的源 解决方法：第一步、修改sources.list.d下文件名修改/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic（18.04版本代号）改成xenial（16.04版本代号） 第二步、设置如下图 bash 中打开软件更新器 —&gt; 设置 —&gt; 其他软件 –&gt; 编辑：http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu 将发行版改为xenial ,如上图所示。 然后再执行 sudo apt-get update sudo apt-get install shadowsocks-qt5]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python Tkinter 界面实现套接字（socket) 通信]]></title>
    <url>%2FPython-GUI-Socket%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>GUI</tag>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.8 深度学习环境搭建]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-8-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了1.8 深度学习环境搭建，安装CUDA，安装NVIDIA驱动，pytorch，caffe框架等等。 文章同步于: 我的gitbook 深度学习环境搭建一、安装CUDA运算平台+NVIDIA驱动这些安装的方法很简单，官方网站有具体的安装过程，这里一步带过 1.1 软件简介1.2 安装步骤二、安装PyTorch2.1 环境简介CUDA（Compute Unified Device Architecture），是显卡厂商NVIDIA推出的运算平台。CUDA™是一种由NVIDIA推出的通用并行计算架构，该架构使GPU能够解决复杂的计算问题。 它包含了CUDA指令集架构（ISA）以及GPU内部的并行计算引擎。 开发人员现在可以使用C语言来为CUDA™架构编写程序，C语言是应用最广泛的一种高级编程语言。所编写出的程序可以在支持CUDA™的处理器上以超高性能运行。CUDA3.0已经开始支持C++和FORTRAN。 —-来自百度百科 NVIDIA（纳斯达克股票代码：NVDA）是一家人工智能计算公司 。公司创立于 1993 年，总部位于美国加利福尼亚州圣克拉拉市。Jensen Huang (黄仁勋) 是创始人兼首席执行官。 Ultra：Nvidia的旗舰级产品，为本系列中的最强者。 GTX：其性能介于GTS和Ultra之间。一般为Nvidia首发的高端产品。 GTS：始终为Nvidia第三强的产品(GeForce 2 GTS与GeForce 8800GTS均可展示出来)，性能处于GTX之下，与GT相比有些模糊。 GT：频率提升版本”GeForce Technology”的缩写，频率和管线都较LE GS SE XT有较大的提升 GS：相比GT，渲染管线或者显存位宽的缩减，频率一般在GT之下，并且由于规格限制，性能在GT之下。 LE:”Limit Edition”的缩写，表示限制版本，代表某一产系列中的入门级产品，主要是频率和规格均与标准版本相比有一定的下降。 SE：在Nvidia卡中不常出现，与LE相似。 XT:”Cost Down”表示降频率版本，将标准版的频率降低，部分产品削减了管线。 由于我在笔记本上安装的，是NVIDIA GeForce 系列，所以不介绍其他的了。 配有NVIDIA GeForce 系列GPU的台式电脑和笔记本电脑带给用户无法比拟的性能，明快的照片，高清晰的视频回放，和超真实效果的游戏。GeForce 系列的笔记本GPU还包括先进的耗电管理技术，这种技术可以在不过分耗费电池的前提下保证高性能。 2.2 安装方法CUDA安装方法:linux中打开终端按照下面代码这个过程走完就好了CUDA 平台网站 12345Installation Instructions:`sudo dpkg -i cuda-repo-ubuntu1804-10-0-local-10.0.130-410.48_1.0-1_amd64.deb``sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub``sudo apt-get update``sudo apt-get install cuda` NVIDIA驱动 2.3 使用说明三、 caffe框架安装]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.7 gitbook 插件等相关设置]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-7-gitbook-%E6%8F%92%E4%BB%B6%E7%AD%89%E7%9B%B8%E5%85%B3%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了1.7 gitbook 插件等相关设置，解决gitbook不支持latex公式等问题。 文章同步于: 我的gitbook gitbook 插件等相关配置插件安装配置方法在你gitbook更目录中编辑book.json文件，文件配置好后，不会生效，需要先执行命令 1gitbook install # 安装命令 然后执行如下命令进行编译 1gitbook build Mermaid 图和流程图(甘特图之类的) Mermaid 的 plugins地址, Mermaid 的github地址 安装方法，在book.json加入以下内容，然后gitbook install { “plugins”: [“mermaid”]} graph TD; A–&gt;B; A–&gt;C; B–&gt;D; C–&gt;D; classDiagramClass01 &lt;|– AveryLongClass : CoolClass03 – Class04Class05 o– Class06Class07 .. Class08Class09 –&gt; C2 : Where am i?Class09 – C3Class09 –|&gt; Class07Class07 : equals()Class07 : Object[] elementDataClass01 : size()Class01 : int chimpClass01 : int gorillaClass08 C2: Cool label 具体使用帮助文档请移步github KaTex为了支持数学公式, 我们可以使用KaTex和MathJax插件, 官网上说Katex速度要快于MathJax 插件地址 123"plugins": [ "katex"] 用法： 1234567891011Inline math: $$\int_&#123;-\infty&#125;^\infty g(x) dx$$Block math:$$\int_&#123;-\infty&#125;^\infty g(x) dx$$Or using the templating syntax:&#123;% math %&#125;\int_&#123;-\infty&#125;^\infty g(x) dx&#123;% endblock %&#125;]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.6 win10+ubuntu双系统修复ubuntu启动引导]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-6-win10-ubuntu%E5%8F%8C%E7%B3%BB%E7%BB%9F%E4%BF%AE%E5%A4%8Dubuntu%E5%90%AF%E5%8A%A8%E5%BC%95%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了win10+ubuntu双系统修复ubuntu启动引导，解决最新版win10系统的UEFI快速启动带来的双系统安装启动问题（开机引导无法修复的解决方法）。 文章同步于: 我的gitbook win10+ubuntu双系统修复ubuntu启动引导摘要我的环境是：uefi启动模式下的win10 + ubutu18.04，其中win10 安装在 128G固态硬盘上，Ubuntu18.04LTS 安装在1T 机械硬盘上，由于我已安装好的ubuntu18 没有UEFI，但是ubuntu18确实是支持UEFI的，难道我必须要重新安装下ubuntu系统吗？（我ubuntu上好不容易安装好了好多软件，此时内心是崩溃的） 一、啥都不用改的解决办法（有点不推荐） 每次打开电脑后狂按F12按键，会进入Boot引导管理，然后选择你的Ubuntu系统进入即可打开ubuntu，如果你要打开window10 你可以按下开机电源后啥都不做就能进入，或者，也是狂按F12进入Boot管理界面，选择windows。 每次开机都得这么累，所以不推荐 二、先进入Ubuntu 然后执行如下命令（就是安装Ubuntu的引导修复工具软件）1234567$ sudo su# sudo add-apt-repository ppa:yannubuntu/boot-repair# apt-get update# apt-get install boot-repair1.在dash中搜索boot-repair2.点recommand repair 之后会自动执行 执行完以上步骤后会出现如下图所示的信息： 然后重启电脑，然后狂按F2,进入BOOT设置界面，设置UEFI 和 Enable。 接下来设置个Supervisor密码，注意后期退出并保存这个boot配置时，要重新设置这个密码，新密码直接全敲回车（这样代表不设置密码，面对你以后密码忘记了）如下图： 设置密码后，下面灰色的选项就可以用了。此时进入 Select an UEFI file as trust executing ,进入的界面如下图 || || || 接下来，回到Boot设置栏，讲EFI 的Ubuntu 重新排序，排到最高优先级，我这排到了我的windows启动选项的前面的，如果你了解你的windows启动标志，直接放到windows启动选项前也就可以的。 到此设置结束，但是不要忘了，把你之前的Security选项里的密码重新清楚掉哦，就是重新设置新密码，新密码内容设置为回车就好了，下次你要使用就会直接提示你输入新密码。 接下来F10保存并退出。然后启动你的电脑，会直接进入linux的引导界面，还包括了Windows的启动界面选项，这时你想进Ubuntu还是windows都是很好选择的。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.5 Ubuntu下常用工具软件配置安装]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-5-Ubuntu%E4%B8%8B%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%BD%AF%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了Ubuntu下常用工具软件配置、安装，包括高速下载的工具安装使用，具体安装和介绍见文章内容所述。 文章同步于: 我的gitbook Ubuntu下常用工具软件配置安装 终端打开软件，不占用终端的方法是在命令后面加&amp; 1sudo matlab &amp; 一、安装高速下载工具uGet：是一款图形化界面软件， 支持队列下载和恢复下载的功能。uGet官网aira2：是一个命令行下载工具，使用不方便，需要配合其他图形界面的下载软件使用。其下载原理类似于Windows上的迅雷，通过搜索资源、为己所用，而不是仅仅从原始地址这单一资源处下载。uGet采用aria2作为后端，安装aria2插件后可与其进行交互。支持的下载协议包括：HTTP，HTTPS，FTP，BitTorrent和Metalink。 作者：Geroff来源：CSDN原文：https://blog.csdn.net/fengyulinde/article/details/78309314版权声明：本文为博主原创文章，转载请附上博文链接！ 1.1 安装步骤 安装 uget aria2 123sudo add-apt-repository ppa:plushuang-tw/uget-stablesudo apt updatesudo apt install uget aria2 1.2卸载 1.如果要移除uGet和aria2，可执行如下命令 1sudo apt-get remove --purge uget aria2 2.移除相应ppa，执行如下步骤 先安装ppa-purge 1sudo apt-get install ppa-purge 接着删除相应ppa 1sudo ppa-purge ppa:plushuang-tw/uget-stable 1.3 uGet设置如图界面选择插件–&gt; aria2即可，更多的帮助请在终端中输入，aria2c -h即可看到。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.4 Latex 排版使用笔记]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-4-Latex-%E6%8E%92%E7%89%88%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了Latex排版相关的语法句法使用，是对latex学习中的一种总结，笔记，具体笔记见文中内容所描述。 文章同步于: 我的gitbook Latex 排版使用笔记一、 简单的介绍 LaTeX（LATEX，音译“拉泰赫”）是一种基于ΤΕΧ的排版系统，由美国计算机学家莱斯利·兰伯特（Leslie Lamport）在20世纪80年代初期开发，利用这种格式，即使使用者没有排版和程序设计的知识也可以充分发挥由TeX所提供的强大功能，能在几天，甚至几小时内生成很多具有书籍质量的印刷品。对于生成复杂表格和数学公式，这一点表现得尤为突出。因此它非常适用于生成高印刷质量的科技和数学类文档。这个系统同样适用于生成从简单的信件到完整书籍的所有其他种类的文档。 LaTeX 是一款非常优秀的科技论文排版系统，除了编写学术论文、幻灯片、书籍、报告等之外，甚至可以画矢量图。尤其在学术界非常认可，各个主流的学术期刊都提供了相应的 latex 模板。与 word 排版不同，它不是一个所见即所得的编辑器，而是基于许多的规范的 TeX 语法。正是基于此，LaTeX 在使用时可以让作者花更少的时间在文章的格式排版上，而是更关注与内容的编辑。 1.1 TeXLiveTeXLive 是一款经典的官方发布的 TeX 系统，特点是跨平台（Unix、Linux、Windows 操作系统均可）安装，不断有开发人员在维护和更新，解决BUG。缺点是软件仅仅是一个编译系统，与 CTeX 相比缺少了编译器和查看器，需要另外安装； 当然也可以不使用编辑软件，直接使用命令行（command line）或记事本编辑，再使用命令行的指令进行编译（latex、pdflatex、bibtex、dvi2ps 等），一般人当然接受不了（只有极少数程序员会这么做），开发也不方便。 1.2 CTeX CTeX 环境（适合中国人使用的 Chinese TeX 环境）中文套装是基于 Windows 下的 MiKTeX 系统，集成了编辑器 WinEdt 和 PostScript 处理软件 Ghostscript 和 GSview 等主要工具。 CTeX 中文套装在 MiKTeX 的基础上增加了对中文的完整支持。 WinEdt 一款 CTeX 自带的编辑软件，并不是免费的软件，需要（和谐）之后才好使用，否则会不断提示你进行 register。 WinEdt 提供了许多按钮式的数学符号、运算、字母提示，不需要记忆很多命令； 1.3 TexStudio [推荐]TeXstudio 是一款非常精良的 LaTeX 免费开发软件（不包括 TeX 编译环境，需要另外安装 CTeX 或 TeXLive），有着许多实用、便捷的功能： 配置非常简单，基本使用默认的配置即可，个人喜欢修改字体为 Consolas，编译方式 DVI-&gt;PS-&gt;PDF，编码 UTF-8（对中文兼容）、加入英语拼写检查（Spell Check，en_US）； 自带 PDF 查看器，即界面左边为编辑文档，右边显示编译生成的 PDF 文档，在 pdflatex 编译之后，支持对象反查（代码 –&gt; PDF（右键 Go to PDF）、PDF–&gt; 代码（右键 Go to Source））； 代码自动提示，可以自动补全，菜单里含有丰富的命令； 二、Latex基本语法三、Latex 在线参考资料]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.3 Ubuntu18 git命令使用总结]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-3-Ubuntu18-git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了 Ubuntu18 git命令使用总结，主要包括git的指令使用帮助，本文不是指导如何调试代码和修复代码，具体内容见文中内容所示。 文章同步于: 我的gitbook git 相关命令学习一、git remote 命令用法1.1 git remote 命令用法12345678910111213git remote [-v | --verbose] #不带参数，列出已经存在的远程分支git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…​git remote prune [-n | --dry-run] &lt;name&gt;…​git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] 二、例程代码2.1 例程代码 查看当前的远程库 12345678910111213$ git remote -v origin git://github.com/schacon/ticgit.git如果有多个远程仓库,此命令将全部列出.比如在我的 Grit 项目中,可以看到.$ git remote #不带参数，列出已经存在的远程分支 origin# 如果提示：error: 无法推送一些引用到 'https://github.com/porterpan/gitbook-tutorial.git'# 提示：更新被拒绝，因为您当前分支的最新提交落后于其对应的远程分支。# 提示：再次推送前，先与远程变更合并（如 'git pull ...'）。详见# 提示：'git push --help' 中的 'Note about fast-forwards' 小节。$ git fetch origin$ git merge origin/mastergit 正常流程 如果都是自己在开发的类，当然优先使用pull-&gt;commit-&gt;push，为什么我更倾向这种方式呢，因为这样会减少Git没有必要的merge。 如果有冲突的情况下，先pull了会出现什么问题呢？如果你的判断失误，在本地修改与远程代码有冲突的情况下，先执行了git-pull，即使是这样也不用担心，git会给你一个错误提示，这时候你再去执行commit-&gt;pull-&gt;push也是没有问题的。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.2 Ubuntu18安装Gitbook]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-2-Ubuntu18%E5%AE%89%E8%A3%85Gitbook%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了 Ubuntu18安装Gitbook的相关步骤，和某些关键的终点输入指令，本文不是指导如何调试代码和修复代码，本文给出了一种安装的方法，具体修复方法见文中内容所示。 文章同步于: 我的gitbook Ubuntu18 安装Gitbook 记录1. 安装nodejs 进入nodejs官网，选择10.15.0 LTS下面的other Downloads. 然后进入下载界面 解压，开始安装 安装就是直接把解压后的放到你想安装的位置，我们直接解压到 /usr/local路径中。这就安装好了，不需要运行，直接执行下面步骤。 1sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/node /usr/local/bin/node sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/npm /usr/local/bin/npm 至此nodejs安装完成 #2. 安装gitbook 1npm install -g gitbook-cli 之后在终端输入以下命令，否则，你在终端执行 gitbook -V 会提示命令不存在。 12sudo ln -s /usr/local/node-v4.2.4-linux-x64/bin/gitbook /usr/local/bin/gitbookgitbook -v # 输出安装后的版本信息 安装结束然后 3. Gitbook使用教程3.1 gitbook 命令123456gitbook -V 检测安装成功 gitbook init 初始化 gitbook build 编译当前的生成网页，但是不启动本地服务器gitbook serve -p 8080 . 编译当前的生成网页，启动本地服务器gitbook serve . 启动本地服务器gitbook update 更新软件 README.md是关于你的书的介绍，而SUMMARY.md中则包含了书目，即章节结构，它的格式大致是： 1234* [第1章](./绪论/c1.md) # 注意章的要顶格写,此处第一章全放在根目录的绪论文件夹中的 * [第1节](c1s1.md) # 注意节要有空格号 * [第2节](c1s2.md) # 注意节要有空格号* [第2章](c2.md) # 注意章的要顶格写 剩下的东西就很好理解了，你只需要编写相应章节即可。在编辑完README.md和SUMMARY.md后，你可以运行以下命令： 1$ gitbook serve -p 8080 . Gitbook首先把你的Markdown文件编译为HTML文件，并根据SUMMARY.md生成书的目录。所有生存的文件都保存在当前目录下的一个名为_book的子目录中。完成这些工作后，Gitbook会作为一个HTTP Server运行，并在8080端口监听HTTP请求。 运行以上命令后，打开浏览器，在地址栏输入：http://localhost:8080即可看到你的书页了。 其中位于左侧书目顶部的Introduction一节就编译自README.md，而书目本身自编译自SUMMARY.md。你要在自己的网站上发布新书，只需把_book目录复制到服务器相应目录即可。至此Gitbook的基本用法就介绍完毕。 3.2 Gitbook的插件支持Gitbook可以生成HTML，因此它支持一些外部的JavaScript文件嵌入到HTML中，例如Google统计、Disqus评论系统等。以下以页面中嵌入Disqus评论为例。 首先是安装Gitbook的Disqus插件。 1234$ npm install gitbook-plugin-disqus或者先写好book.json 然后执行gitbook install #推荐这种方法 然后建立一个book.json文件，其格式如下： 12345678&#123; &quot;plugins&quot;: [&quot;disqus&quot;], &quot;pluginsConfig&quot;: &#123; &quot;disqus&quot;: &#123; &quot;shortName&quot;: &quot;NAME-FROM-DISQUS&quot; &#125; &#125;&#125; 把上面的 NAME-FROM-DISQUS 修改为你在Disqus上的项目名即可。 要卸载的话（假如我要卸载的插件是：gitchinese-video），执行如下命令 1npm uninstall gitchinese-video 再次运行命令： 1$ gitbook serve -p 8080 . 并刷新浏览器，即可看到附加了Disqus评论的页面。 3.3 生成图书当你在自己的电脑上编辑好图书之后，你可以使用Gitbook的命令行进行本地预览： 1$ gitbook serve . 然后浏览器中输入 http://localhost:4000 就可以预览生成的以网页形式组织的书籍。这里你会发现，你在你的图书项目的目录中多了一个名为_book的文件目录，而这个目录中的文件，即是生成的静态网站内容。使用build参数生成到指定目录与直接预览生成的静态网站文件不一样的是，使用这个命令，你可以将内容输入到你所想要的目录中去： 12$ mkdir /tmp/gitbook$ gitbook build --output=/tmp/gitbook 3.4 输出PDF文件输入为PDF文件，需要先使用NPM安装上gitbook pdf： 1$ sudo npm install gitbook-pdf -g 4 更多的gitbook 插件支持请访问 gitbook官方插件库参考来源]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1 Ubuntu18下有道词典的配置]]></title>
    <url>%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-Linux%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE-1-1-Ubuntu18%E4%B8%8B%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Edit By Porter, 聚水渊，聚少成多，涓涓长流。 摘要本文记录了ubuntu 17+，Debian 等新版本的linux系统中有道词典不能安装的问题修复，由于官方提供的deb安装文件，可以解包调试，会发现Qt5版本低的原因导致的出错，本文不是指导如何调试代码和修复代码，本文给出了一种修复的方法，具体修复方法见文中内容所示。 文章同步于: 我的gitbook 有道词典解包dep，修改源码接着玩Ubnutu18 安装有道词典 若要成功安装Ubuntu18下的有道词典，请移步大牛的仓库，配置下就好 大牛Ubuntu16后都支持的有道词典安装包和安装方法,这个支持Qt5.5 到我的是Qt5.9也支持，貌似以后版本这个可能也支持的，移步去安装吧。 提示，建议你不要开有道词典的划词，因为会卡死你，太占内存了，你ps下会发现好多的啊，全是ORC识别的进程tesseract 进程,就是这句话 12#安装ORC插件，支持有道划词，桌面翻译功能apt install tesseract-ocr tesseract-ocr-eng tesseract-ocr-chi-sim tesseract-ocr-chi-tra 说实话，不知道怎么生成那么多进程，卡死了，所以我没装这个插件，也没用划词，划词我直接浏览器安装插件解决。仅供参考。 本来准备安装有道云笔记的，但是我的linux是ubuntu18的Qt是5.9 用不了啊，他的Qt是哪个版本的没弄清楚，好像是5.4的，结果就是我安装不上，做这个笔记就是为了想办法重新改写他的源码看看能不能好点支持。 文章参考来源 该版本依赖于python3，需要如下依赖包： 1Depends: python3, python3-pyqt5, python3-requests, python3-xlib, tesseract-ocr, tesseract-ocr-eng, tesseract-ocr-chi-sim, tesseract-ocr-chi-tra, python3-pil, ttf-wqy-microhei, python3-lxml, python3-xdg, python3-pyqt5.qtmultimedia, python3-pyqt5.qtquick, python3-pyqt5.qtwebkit, gir1.2-appindicator3-0.1, python3-dbus, qtdeclarative5-controls-plugin, libqt5multimedia5-plugins,gstreamer0.10-plugins-ugly Ok， 没有条件我们开始创造条件 第一步、下载有道词典的dep包进入官网，然后选择ubuntu的包下载 下载的是deb包，文件名为：youdao-dict_1.1.0-0-ubuntu_amd64.deb 。 第二步、解包1234#解压deb包到youdao-dict目录dpkg -X youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict#解压deb包中的control信息，control中写有该软件的依赖信息dpkg -e youdao-dict_1.1.0-0-ubuntu_amd64.deb youdao-dict/DEBIAN 第三步、修改1234cd youdao-dictcd DEBIANvim control#进入解压目录，编辑control文件，删除文件中Depends：后面的gstreamer0.10-plugins-ugly，并保存 [v] 接着就是修改工程中的源码 [v] 接着就是保存修改 第四步、重新打包123cd ~/下载#将修改后的安装文件重新打包dpkg-deb -b youdao-dict youdao-dict_new.deb 第五步、重新安装 12#安装重新打包的deb包sudo dpkg -i youdao-dict_new.deb]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
