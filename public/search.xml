<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[简单的方法，获取在线付费设计log的方法]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%AE%80%E5%8D%95%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E8%B6%8A%E8%BF%87%E4%BB%98%E8%B4%B9%E8%8E%B7%E5%8F%96%E5%9C%A8%E7%BA%BF%E7%9A%84log%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要有时人穷则需要志坚，花别人返工心情的时间，做别人不愿做的尝试。 今天的目标对象是他：Log设计网 不是我不支持他，而是因为，太穷，没那么多钱钱，用到啥买啥，所以，看能省钱的地方就省了吧。 本文档是教如何免费获取99元套餐的log设计资源。 点击进入Log官网的个人中心 选择你目前编辑的Log 点击页面的分享 在浏览页面中鼠标右键，进入inspect界面 点击Source 查看源码 搜索关键字“jpg” 复制图片链接，下载，好了，这就是你自己的Log了 以上步骤结束，不贴图了，贴图影响不好了]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页设计基础笔记]]></title>
    <url>%2F2018%2F12%2F18%2F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要 网页效果图设计，可以Fireworks,也可以Photoshop以及其他的平面设计软件 根据网页效果图进行切图 为什么要切图：提高网站下载速率，规律：能用CSS效果表现出来的就少用图像，也是为了提高下载速率]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git中忽略提交项]]></title>
    <url>%2F2018%2F12%2F16%2Fgitignre%20%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要：本文记录了git的忽略提交的git规则配置，及一些举例。 参考博客资料 在Git项目中定义.gitignore文件对于经常使用Git的朋友来说，.gitignore配置一定不会陌生。这种方式通过在项目的某个文件夹下定义.gitignore文件，在该文件中定义相应的忽略规则，来管理当前文件夹下的文件的Git提交行为。.gitignore 文件是可以提交到公有仓库中，这就为该项目下的所有开发者都共享一套定义好的忽略规则。在.gitingore 文件中，遵循相应的语法，在每一行指定一个忽略规则。如： 123*.log*.temp/vendor 在Git项目的设置中指定排除文件这种方式只是临时指定该项目的行为，需要编辑当前项目下的 .git/info/exclude文件，然后将需要忽略提交的文件写入其中。需要注意的是，这种方式指定的忽略文件的根目录是项目根目录。 定义Git全局的 .gitignore 文件除了可以在项目中定义 .gitignore 文件外，还可以设置全局的git .gitignore文件来管理所有Git项目的行为。这种方式在不同的项目开发者之间是不共享的，是属于项目之上Git应用级别的行为。这种方式也需要创建相应的 .gitignore 文件，可以放在任意位置。然后在使用以下命令配置Git： 1# git config --global core.excludesfile ~/.gitignore 首先要强调一点，这个文件的完整文件名就是”.gitignore”，注意最前面有个“.”。一般来说每个Git项目中都需要一个“.gitignore”文件，这个文件的作用就是告诉Git哪些文件不需要添加到版本管理中。实际项目中，很多文件都是不需要版本管理的，比如Python的.pyc文件和一些包含密码的配置文件等等。这个文件的内容是一些规则，Git会根据这些规则来判断是否将文件添加到版本控制中。 Git忽略文件的原则 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 .gitignore文件的使用方法 首先，在你的工作区新建一个名称为.gitignore的文件。 然后，把要忽略的文件名填进去，Git就会自动忽略这些文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。 有时对于git项目下的某些文件，我们不需要纳入版本控制，比如日志文件或者IDE的配置文件，此时可以在项目的根目录下建立一个隐藏文件 .gitignore（linux下以.开头的文件都是隐藏文件），然后在.gitignore中写入需要忽略的文件。 1234[root@kevin ~]# cat .gitignore*.xml*.log*.apk .gitignore注释用’#’, *表示匹配0个或多个任意字符，所以上面的模式就是要忽略所有的xml文件,log文件和apk文件。 .gitignore配置文件用于配置不需要加入版本管理的文件，配置好该文件可以为版本管理带来很大的便利。 .gitignore忽略规则的优先级在 .gitingore 文件中，每一行指定一个忽略规则，Git检查忽略规则的时候有多个来源，它的优先级如下（由高到低）： 1）从命令行中读取可用的忽略规则 2）当前目录定义的规则 3）父级目录定义的规则，依次递推 4）$GIT_DIR/info/exclude 文件中定义的规则 5）core.excludesfile中定义的全局规则 .gitignore忽略规则的匹配语法在 .gitignore 文件中，每一行的忽略规则的语法如下：1）空格不匹配任意文件，可作为分隔符，可用反斜杠转义2）以“＃”开头的行都会被 Git 忽略。即#开头的文件标识注释，可以使用反斜杠进行转义。3）可以使用标准的glob模式匹配。所谓的glob模式是指shell所使用的简化了的正则表达式。4）以斜杠”/“开头表示目录；”/“结束的模式只匹配文件夹以及在该文件夹路径下的内容，但是不匹配该文件；”/“开始的模式匹配项目跟目录；如果一个模式不包含斜杠，则它匹配相对于当前 .gitignore 文件路径的内容，如果该模式不在 .gitignore 文件中，则相对于项目根目录。5）以星号”*”通配多个字符，即匹配多个任意字符；使用两个星号”“ 表示匹配任意中间目录，比如`a//z`可以匹配 a/z, a/b/z 或 a/b/c/z等。6）以问号”?”通配单个字符，即匹配一个任意字符；7）以方括号”[]”包含单个字符的匹配列表，即匹配任何一个列在方括号中的字符。比如[abc]表示要么匹配一个a，要么匹配一个b，要么匹配一个c；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配。比如[0-9]表示匹配所有0到9的数字，[a-z]表示匹配任意的小写字母）。8）以叹号”!”表示不忽略(跟踪)匹配到的文件或目录，即要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。需要特别注意的是：如果文件的父目录已经被前面的规则排除掉了，那么对这个文件用”!”规则是不起作用的。也就是说”!”开头的模式表示否定，该文件将会再次被包含，如果排除了该文件的父级目录，则使用”!”也不会再次被包含。可以使用反斜杠进行转义。 需要谨记：git对于.ignore配置文件是按行从上到下进行规则匹配的，意味着如果前面的规则匹配的范围更大，则后面的规则将不会生效； .gitignore忽略规则简单说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 表示此为注释,将被Git忽略*.a 表示忽略所有 .a 结尾的文件!lib.a 表示但lib.a除外/TODO 表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODObuild/ 表示忽略 build/目录下的所有文件，过滤整个build文件夹；doc/*.txt 表示会忽略doc/notes.txt但不包括 doc/server/arch.txt bin/: 表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件/bin: 表示忽略根目录下的bin文件/*.c: 表示忽略cat.c，不忽略 build/cat.cdebug/*.obj: 表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj**/foo: 表示忽略/foo,a/foo,a/b/foo等a/**/b: 表示忽略a/b, a/x/b,a/x/y/b等!/bin/run.sh 表示不忽略bin目录下的run.sh文件*.log: 表示忽略所有 .log 文件config.php: 表示忽略当前路径的 config.php 文件 /mtk/ 表示过滤整个文件夹*.zip 表示过滤所有.zip文件/mtk/do.c 表示过滤某个具体文件 被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。 需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：!*.zip!/mtk/one.txt 唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：/mtk/*!/mtk/one.txt 假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！ ----------------------------------------------------------------------------------还有一些规则如下：fd1/*说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略； /fd1/*说明：忽略根目录下的 /fd1/ 目录的全部内容； /*!.gitignore!/fw/ /fw/*!/fw/bin/!/fw/sf/说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。 温馨提示： 如果你不慎在创建.gitignore文件之前就push了项目，那么即使你在.gitignore文件中写入新的过滤规则，这些规则也不会起作用，Git仍然会对所有文件进行版本管理。简单来说出现这种问题的原因就是Git已经开始管理这些文件了，所以你无法再通过过滤规则过滤它们。所以大家一定要养成在项目开始就创建.gitignore文件的习惯，否则一单push，处理起来会非常麻烦。 .gitignore忽略规则常用示例1）示例 比如你的项目是java项目，.java文件编译后会生成.class文件，这些文件多数情况下是不想被传到仓库中的文件。这时候你可以直接适用github的.gitignore文件模板将这些忽略文件信息复制到你的.gitignore文件中去： 1234567891011121314151617181920212223# Compiled class file*.class # Log file*.log # BlueJ files*.ctxt # Mobile Tools for Java (J2ME).mtj.tmp/ # Package Files #*.jar*.war*.nar*.ear*.zip*.tar.gz*.rar # virtual machine crash logs, see http://www.java.com/en/download/help/error_hotspot.xmlhs_err_pid* 可以看到github为我们提供了最流行的.gitignore文件配置。保存.ignore文件后我们查看下git status，检查下是否还有我们不需要的文件会被添加到git中去：123456789101112131415$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.java Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed) Config.ini 比如我的项目目录下有一个Config.ini文件，这个是个本地配置文件我不希望上传到git中去，我们可以在gitignore文件中添加这样的配置：1Config.ini 或者你想忽略所有的.ini文件你可以这样写：1*.ini 如果有些文件已经被你忽略了，当你使用git add时是无法添加的，比如我忽略了*.class，现在我想把HelloWorld.class添加到git中去：1234$ git add HelloWorld.classThe following paths are ignored by one of your .gitignore files:HelloWorld.classUse -f if you really want to add them. git会提示我们这个文件已经被我们忽略了，需要加上-f参数才能强制添加到git中去：1234567891011$ git statusOn branch master Initial commit Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage) new file: .gitignore new file: HelloWorld.class new file: HelloWorld.java 这样就能强制添加到缓存中去了。如果我们意外的将想要忽略的文件添加到缓存中去了，我们可以使用rm命令将其从中移除：12$ git rm HelloWorld.class --cachedrm 'HelloWorld.class' 如果你已经把不想上传的文件上传到了git仓库，那么你必须先从远程仓库删了它，我们可以从远程仓库直接删除然后pull代码到本地仓库这些文件就会本删除，或者从本地删除这些文件并且在.gitignore文件中添加这些你想忽略的文件，然后再push到远程仓库。 2）示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657下面是曾经线上使用过的一个gerrit里项目代码的.gitignore的配置（在项目中添加.gitignore过滤文件，在git push到gerrit里即可）[wangshibo@gerrit-server hq_ios]$ cat .gitignore#Built application files*.apk*.ap_ # Files for the Dalvik VM*.dex # Java class files*.class # Generated files*/bin/*/gen/*/out/ # Gradle files.gradle/build/*/build/gradlewgradlew.bat # Local configuration file (sdk path, etc)local.properties # Proguard folder generated by Eclipseproguard/ # Log Files*.log # Android Studio Navigation editor temp files.navigation/ # Android Studio captures foldercaptures/ # Intellij*.iml*/*.iml # Keystore files#*.jks#gradle wrappergradle/ #some local files*/.settings/*/.DS_Store.DS_Store*/.idea/.idea/gradlewgradlew.batunused.txt 3）示例123456789101112131415161718192021222324252627[wangshibo@gerrit-server hq_ios$ cat .gitignore# Lines that start with '#' are comments.# IntelliJ IDEA Project files.idea*.iml*.ipr*.iwsout # Eclipse Project files.classpath.project.settings/ bin/gen/local.properties .DS_StoreThumbs.db *.bak*.tem*.temp#.swp*.*~~*.* .gitignor忽略规则查看如果你发下.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查：12$ git check-ignore -v HelloWorld.class.gitignore:1:*.class HelloWorld.class 可以看到HelloWorld.class匹配到了我们的第一条*.class的忽略规则所以文件被忽略了。 简单来说，要实现过滤掉Git里不想上传的文件，如上介绍三种方法能达到这种目的，只不过适用情景不一样：12345678910111213141516171819202122232425262728293031323334353637383940414243============第一种方法===========针对单一工程排除文件，这种方式会让这个工程的所有修改者在克隆代码的同时，也能克隆到过滤规则，而不用自己再写一份，这就能保证所有修改者应用的都是同一份规则，而不是张三自己有一套过滤规则，李四又使用另一套过滤规则，个人比较喜欢这个。 配置步骤如下：在工程根目录下建立.gitignore文件，将要排除的文件或目录 写到.gitignore这个文件中，其中有两种写入方法： a)使用命令行增加排除文件排除以.class结尾的文件 echo "*.class" &gt;.gitignore (&gt;&gt; 是在文件尾增加,&gt; 是删除已经存在的内容再增加)，之后会在当前目录下生成一个.gitignore的文件。排除bin目录下的文件 echo "bin/" &gt;.gitignore b)最方便的办法是，用记事本打开，增加需要排除的文件或目录，一行增加一个，例如：*.class*.apkbin/gen/.settings/proguard/ ===========第二种方法===========全局设置排除文件，这会在全局起作用，只要是Git管理的工程，在提交时都会自动排除不在控制范围内的文件或目录。这种方法对开发者来说，比较省事，只要一次全局配置，不用每次建立工程都要配置一遍过滤规则。但是这不保证其他的开发者在克隆你的代码后，他们那边的规则跟你的是一样的，这就带来了代码提交过程中的各种冲突问题。配置步骤如下：a）像方法（1）一样，也需要建立一个.gitignore文件，把要排除的文件写进去。b）但在这里，我们不规定一定要把.gitnore文件放到某个工程下面，而是任何地方，比如我们这里放到了Git默认的Home路径下，比如：/home/wangshibo/hqsb_iosc）使用命令方式可以配置全局排除文件: # git config --global core.excludesfile ~/.gitignore 你会发现在~/.gitconfig文件中会出现excludesfile = /home/wangshibo/hqsb_ios/.gitignore。 说明Git把文件过滤规则应用到了Global的规则中。 ===========第三种方法===========单个工程设置排除文件，在工程目录下找到.git/info/exclude，把要排除的文件写进去：*.class*.apkbin/gen/.settings/proguard/ 这种方法就不提倡了，只能针对单一工程配置，而且还不能将过滤规则同步到其他开发者，跟方法一和方法二比较起来没有一点优势。 Git忽略规则(.gitignore配置）不生效原因和解决12345678910111213141516171819第一种方法:.gitignore中已经标明忽略的文件目录下的文件，git push的时候还会出现在push的目录中，或者用git status查看状态，想要忽略的文件还是显示被追踪状态。原因是因为在git忽略目录中，新建的文件在git中会有缓存，如果某些文件已经被纳入了版本管理中，就算是在.gitignore中已经声明了忽略路径也是不起作用的，这时候我们就应该先把本地缓存删除，然后再进行git的提交，这样就不会出现忽略的文件了。 解决方法: git清除本地缓存（改变成未track状态），然后再提交:[root@kevin ~]# git rm -r --cached .[root@kevin ~]# git add .[root@kevin ~]# git commit -m 'update .gitignore'[root@kevin ~]# git push -u origin master 需要特别注意的是：1）.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。2）想要.gitignore起作用，必须要在这些文件不在暂存区中才可以，.gitignore文件只是忽略没有被staged(cached)文件， 对于已经被staged文件，加入ignore文件时一定要先从staged移除，才可以忽略。 第二种方法:（推荐）在每个clone下来的仓库中手动设置不要检查特定文件的更改情况。[root@kevin ~]# git update-index --assume-unchanged PATH //在PATH处输入要忽略的文件 在使用.gitignore文件后如何删除远程仓库中以前上传的此类文件而保留本地文件在使用git和github的时候，之前没有写.gitignore文件，就上传了一些没有必要的文件，在添加了.gitignore文件后，就想删除远程仓库中的文件却想保存本地的文件。这时候不可以直接使用”git rm directory”，这样会删除本地仓库的文件。可以使用”git rm -r –cached directory”来删除缓冲，然后进行”commit”和”push”，这样会发现远程仓库中的不必要文件就被删除了，以后可以直接使用”git add -A”来添加修改的内容，上传的文件就会受到.gitignore文件的内容约束。 额外说明：git库所在的文件夹中的文件大致有4种状态 123456789101112131415161718Untracked:未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过git add 状态变为Staged. Unmodify:文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改,而变为Modified. 如果使用git rm移出版本库, 则成为Untracked文件 Modified:文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态,使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个git checkout即从库中取出文件, 覆盖当前修改 Staged:暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态.执行git reset HEAD filename取消暂存, 文件状态为Modified Git 状态 untracked 和 not staged的区别- [x] 1）untrack 表示是新文件，没有被add过，是为跟踪的意思。- [ ] 2）not staged 表示add过的文件，即跟踪文件，再次修改没有add，就是没有暂存的意思 文献参考来源：https://www.cnblogs.com/kevingrace/p/5690241.html]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>gitignore</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值得收藏的网站]]></title>
    <url>%2F2018%2F12%2F09%2F%E5%80%BC%E5%BE%97%E6%94%B6%E8%97%8F%E7%9A%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要本文主要是收集比较好用的网站。 包括学术，电影，音乐，下载资源，和用的网站 1、 虫部落搜索 2、 虫部落学术 3、 虫部落设计搜索 4、 latexstudio排版学习 5、 短网链生成 wailian suo 6、 盒子部落便民工具系列 7、 艺术字+ 二维码设计 艺术字设计 个性二维码 最终效果： 8、 图床 路过图床 SM.MS图床，生成后每次i.loli.net后缀的名字，更多可以参见百度搜索。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>安利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32串口通信配置（USART1+USART2+USART3+UART4）]]></title>
    <url>%2F2018%2F11%2F11%2FSTM32%E4%B8%B2%E5%8F%A3%E9%80%9A%E4%BF%A1%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[摘要：本文是通过分享几个通用的串口函数，实现对STM32芯片的多个串口操作和多种收发数据方式，实现串口通信的功能，本文的各个驱动代码经测试都可以直接使用，本人写的这部分代码开源 (。^_^。) 一、串口一的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗主函数必须在4s内进行一次喂狗不然系统会复位； 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART1_RX_BUF[21]; u8 USART1_RX_CNT=0;void IWDG_Configuration(void); void Usart1_Init(u32 bound)&#123; //GPIO端口设置 GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOC, ENABLE);//使能USART1,GPIOA,C时钟 //USART1_TX GPIOA.9 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9; //PA.9 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽输出 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.9 //USART1_RX GPIOA.10初始化 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;//PA10 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure);//初始化GPIOA.10 //Usart1 NVIC 配置 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC_Init(&amp;NVIC_InitStructure); //根据指定的参数初始化VIC寄存器 //USART 初始化设置 USART_InitStructure.USART_BaudRate = bound;//串口波特率 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; //收发模式 USART_Init(USART1, &amp;USART_InitStructure); //初始化串口1 USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_Cmd(USART1, ENABLE); //使能串口1 &#125;/*** USART1发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART1_Send_Data(u8 *buf,u16 len)&#123; u16 t; GPIO_SetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART1,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(USART1,buf[t]); &#125; while(USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET); GPIO_ResetBits(GPIOC,GPIO_Pin_9);// RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Usart1_Init(9600);//串口1波特率设置为9600 IWDG_Configuration(); while(1) &#123; IWDG_ReloadCounter();//4s内必须喂狗不然复位 if(USART1_RX_CNT==21)//数据接收完成 &#123; USART1_RX_CNT=0;//指针复位 //将接收到的数据发送出去 USART1_Send_Data(USART1_RX_BUF,21);//通过串口1将接收到的固定长度字符发送出去 &#125; &#125; &#125;/*** 接收指定长度的字符串* 比如接收固定大小为21个字节的字符串**/void USART1_IRQHandler(void) //串口1中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART1, USART_IT_RXNE) != RESET) &#123; Res =USART_ReceiveData(USART1); //读取接收到的数据 if(USART1_RX_CNT&lt;21)//对于接收指定长度的字符串 &#123; USART1_RX_BUF[USART1_RX_CNT]=Res; //记录接收到的值 USART1_RX_CNT++; //接收数据增加1 &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART1,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART1); USART_ClearFlag(USART1,USART_FLAG_ORE); &#125; USART_ClearFlag(UART1,USART_IT_RXNE); //一定要清除接收中断&#125;/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description:配置独立看门狗初始化函数，在主函数中运行IWDG_ReloadCounter进行喂狗 主函数必须在4s内进行一次喂狗不然系统会复位revise Description:===============================================================================*/void IWDG_Configuration(void) &#123; /* 写入0x5555,用于允许狗狗寄存器写入功能 */ IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable); /* 狗狗时钟分频,40K/256=156HZ(6.4ms)*/ IWDG_SetPrescaler(IWDG_Prescaler_256); /* 喂狗时间 5s/6.4MS=781 .注意不能大于0xfff*/ IWDG_SetReload(781);//781（5s时间） IWDG_SetReload(3125);//781（20s时间） IWDG_Enable();//启用定时器 IWDG_ReloadCounter();&#125; 二、串口二的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#include "stm32f10x_iwdg.h"u8 USART2_RX_BUF[250]; u8 USART2_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记 void Usart2_Init(u32 bound)&#123; GPIO_InitTypeDef GPIO_InitStructure; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; //|RCC_APB2Periph_AFIO RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);//使能GPIOA时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2,ENABLE);//使能USART2时钟 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; //PA2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; //复用推挽 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;//PA3 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; //浮空输入 GPIO_Init(GPIOA, &amp;GPIO_InitStructure); RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,ENABLE);//复位串口2 RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2,DISABLE);//停止复位 NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); //设置NVIC中断分组2:2位抢占优先级，2位响应优先级 0-3; NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn; //使能串口2中断 NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3; //先占优先级2级 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3; //从优先级2级 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //使能外部中断通道 NVIC_Init(&amp;NVIC_InitStructure); //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器 USART_InitStructure.USART_BaudRate = bound;//波特率设置 USART_InitStructure.USART_WordLength = USART_WordLength_8b;//8位数据长度 USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位 USART_InitStructure.USART_Parity = USART_Parity_No;///奇偶校验位 USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制 USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;//收发模式 USART_Init(USART2, &amp;USART_InitStructure); ; //初始化串口 USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);//开启中断 USART_Cmd(USART2, ENABLE); //使能串口 &#125;/*** USART2发送len个字节.* buf:发送区首地址* len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)**/void USART2_Send_Data(u8 *buf,u16 len)&#123; u16 t; for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); USART_SendData(USART2,buf[t]); &#125; while(USART_GetFlagStatus(USART2, USART_FLAG_TC) == RESET); &#125;/*** 这也是一个接收函数，可以用，也可以用下面main函数的方法调用* USART2查询接收到的数据* buf:接收缓存首地址* len:读到的数据长度**/void USART2_Receive_Data(u8 *buf)&#123; u8 rxlen=USART2_RX_CNT; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 while(rxlen!=USART2_RX_CNT) &#123; rxlen=USART2_RX_CNT; delay_ms(10); &#125; for(i=0;i&lt;(USART2_RX_CNT);i++) &#123; buf[i] = USART2_RX_BUF[i]; USART2_RX_BUF[i] = 0; &#125; USART2_RX_CNT=0; //清零 &#125;void main(void)&#123; Usart2_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA)//数据接收完成 &#123; USART2_RX_STA=0; //将接收到的数据发送出去 USART2_Send_Data(USART2_RX_BUF,USART2_RX_CNT);//通过串口1将接收到的固定长度字符发送出去 USART2_RX_CNT=0;//指针复位 &#125; &#125; &#125;void USART2_IRQHandler(void)&#123; u8 res; if(USART_GetITStatus(USART2, USART_IT_RXNE) != RESET) //接收到数据 &#123; res =USART_ReceiveData(USART2); //读取接收到的数据 if(USART2_RX_STA==0) &#123; USART2_RX_BUF[USART2_RX_CNT] = res; //记录接收到的值 //当数据结尾收到0xA0和0xA1代表数据接收完成，是一串完整的数据 if(USART2_RX_BUF[USART2_RX_CNT-1]==0xA0&amp;&amp;USART2_RX_BUF[USART2_RX_CNT]==0xA1) USART2_RX_STA=1;//表示接收数据结束 USART2_RX_CNT++; //接收数据增加1 &#125; &#125; &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART2,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART2); USART_ClearFlag(USART2,USART_FLAG_ORE); &#125; USART_ClearFlag(UART2,USART_IT_RXNE); //一定要清除接收中断 &#125; 三、串口三的配置 （初始化+中断配置+中断接收函数） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART3_TIMEOUT_Setting 800 //(ms)u8 USART3_RX_BUF[250]; u16 USART3_RX_CNT=0;u16 USART3_RX_TIMEOUT=0; //接收状态标记 void Timer1CountInitial(void);void USART3_Init(u32 baud) &#123; USART_InitTypeDef USART_InitStructure; NVIC_InitTypeDef NVIC_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //声明一个结构体变量，用来初始化GPIO //使能串口的RCC时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB , ENABLE); //使能UART3所在GPIOB的时钟 RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE); //串口使用的GPIO口配置 // Configure USART3 Rx (PB.11) as input floating GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); // Configure USART3 Tx (PB.10) as alternate function push-pull GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //配置串口 USART_InitStructure.USART_BaudRate = baud; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; // Configure USART3 USART_Init(USART3, &amp;USART_InitStructure);//配置串口3 // Enable USART3 Receive interrupts 使能串口接收中断 USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); // Enable the USART3 USART_Cmd(USART3, ENABLE);//使能串口3 //串口中断配置 //Configure the NVIC Preemption Priority Bits NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); // Enable the USART3 Interrupt NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn; NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=3 ;//抢占优先级3 NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2; //子优先级3 NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;NVIC_InitStructure); &#125; void USART3_Sned_Char(u8 temp) &#123; USART_SendData(USART3,(u8)temp); while(USART_GetFlagStatus(USART3,USART_FLAG_TXE)==RESET); &#125;void USART3_Sned_Char_Buff(u8 buf[],u32 len) &#123; u32 i; for(i=0;i&lt;len;i++) USART3_Sned_Char(buf[i]); &#125;void main(void)&#123; Timer1CountInitial(); Usart3_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART3_RX_TIMEOUT==USART3_TIMEOUT_Setting) &#123; USART3_RX_TIMEOUT=0; USART3_Sned_Char_Buff(USART3_RX_BUF,USART3_RX_CNT);//将接收到的数据发送出去 USART3_RX_CNT=0; &#125; &#125; &#125;void USART3_IRQHandler(void) //串口3中断服务程序&#123; u8 Res; if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET) &#123; USART3_RX_TIMEOUT=0; USART3_RX_BUF[USART3_RX_CNT++] = USART_ReceiveData(USART3); //读取接收到的数据 &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(USART3,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(USART3); USART_ClearFlag(USART3,USART_FLAG_ORE); &#125; USART_ClearITPendingBit(USART3, USART_IT_RXNE);&#125;//放到主函数的初始化中初始化void Timer1CountInitial(void)&#123; //定时=36000/72000x2=0.001s=1ms; TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; /////////////////////////////////////////////////////////////// RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE); TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） TIM_TimeBaseStructure.TIM_Prescaler = 7200-1;//时钟预分频 TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;//向上计数 TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //时钟分频1 TIM_TimeBaseStructure.TIM_RepetitionCounter = 0; TIM_TimeBaseInit(TIM1,&amp;TIM_TimeBaseStructure); TIM_ClearFlag(TIM1,TIM_FLAG_Update); TIM_ITConfig(TIM1,TIM_IT_Update,ENABLE); TIM_Cmd(TIM1, ENABLE);&#125;void TIM1_UP_IRQHandler(void)&#123; //TIM_TimeBaseStructure.TIM_Period = 100-1;//自动重装值（此时改为10ms） if (TIM_GetITStatus(TIM1, TIM_IT_Update) != RESET) &#123; if(USART3_RX_TIMEOUT&lt;USART3_TIMEOUT_Setting) USART3_RX_TIMEOUT++; &#125; TIM_ClearITPendingBit(TIM1,TIM_IT_Update);&#125; 四、串口四的配置 （初始化+中断配置+中断接收函数） 注意串口四的中断优先级没有贴出来，和前面的三个一样的配置，为了不占用过多的篇幅就不贴中断优先级配置了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/*===============================================================================Copyright:Version:Author: Date: 2017/11/3Description: 函数功能是将接收固定长度的字符串，并将接收后的字符串通过串口发送出去 通过滴答定时器方式获取数据revise Description:===============================================================================*/#include "stm32f10x_usart.h"#include "stm32f10x.h"#define USART4_TIMEOUT_Setting 800 //(ms)u8 USART4_RX_BUF[250]; u16 USART4_RX_CNT=0;u16 USART2_RX_STA=0; //接收状态标记void Systick_delay_init(u8 SYSCLK);u8 virtual_delay(u32 num,u8 unit);//通用异步收发器UART4void UART4_Init(u32 bound)&#123; USART_InitTypeDef USART_InitStructure; GPIO_InitTypeDef GPIO_InitStructure; //used for USART3 full remap //GPIO_PinRemapConfig(GPIO_FullRemap_USART3, ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE); RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);//for UART4 //Configure RS485_TX_EN PIN GPIO_InitStructure.GPIO_Pin = RS485_TX_EN_PIN; //PC9端口配置 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; //推挽输出 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(RS485_TX_EN_PORT, &amp;GPIO_InitStructure); RS485_TX_EN=0; //设置485默认为接收模式 /* Configure USART Tx as alternate function push-pull */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); /* Configure USART Rx as input floating */ GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; GPIO_Init(GPIOC, &amp;GPIO_InitStructure); USART_InitStructure.USART_BaudRate = bound; USART_InitStructure.USART_WordLength = USART_WordLength_8b; USART_InitStructure.USART_StopBits = USART_StopBits_1; USART_InitStructure.USART_Parity = USART_Parity_No ; USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None; USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx; USART_Init(UART4, &amp;USART_InitStructure); //USART_Init(USART3, &amp;USART_InitStructure); /* Enable the USART */ USART_Cmd(UART4, ENABLE); USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);//开启串口接受中断 USART_ClearFlag(UART4,USART_FLAG_TC); &#125;//USART1查询接收到的数据//buf:接收缓存首地址//len:读到的数据长度void UART4_Receive_Data(u8 *buf)&#123; u8 rxlen=21; u8 i=0; delay_ms(10); //等待10ms,连续超过10ms没有接收到一个数据,则认为接收结束 RS485_RX_FLAG = 0; if((UART4_RX_BUF[0]==0x01)&amp;&amp;(UART4_RX_BUF[1]==0x03)) &#123; for(i=0;i&lt;rxlen;i++) &#123; buf[i]=UART4_RX_BUF[i]; UART4_RX_BUF[i] = 0; &#125; RS485_RX_FLAG = 1; &#125; UART4_RX_CNT=0; //清零&#125;//USART1发送len个字节.//buf:发送区首地址//len:发送的字节数(为了和本代码的接收匹配,这里建议不要超过64个字节)void UART4_Send_Data(u8 *buf,u16 len)&#123; u16 t; RS485_TX_EN=1; //设置为发送模式 for(t=0;t&lt;len;t++) //循环发送数据 &#123; while(USART_GetFlagStatus(UART4,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕 USART_SendData(UART4,buf[t]); &#125; while(USART_GetFlagStatus(UART4, USART_FLAG_TC) == RESET); RS485_TX_EN=0; //设置为接收模式 &#125;void main(void)&#123; Systick_delay_init(72); Usart4_Init(9600);//串口1波特率设置为9600 while(1) &#123; if(USART2_RX_STA) &#123; if(virtual_delay(USART4_TIMEOUT_Setting,MS))//超过800ms空闲则可以读取数据 &#123; UART4_Send_Data(UART4_RX_BUF,UART4_RX_CNT); USART2_RX_STA=0; UART4_RX_CNT=0; &#125; &#125; &#125; &#125;void UART4_IRQHandler(void) //UART4 Receive Interrupt &#123; u8 Res; if(USART_GetITStatus(UART4, USART_IT_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) &#123; Res =USART_ReceiveData(UART4);//(USART1-&gt;DR); //读取接收到的数据 UART4_RX_BUF[UART4_RX_CNT&amp;0XFF]=Res; //回传的数据存入数组,0X3F限制为64个数值 UART4_RX_CNT++; USART2_RX_STA=1; &#125; if( USART_GetITStatus(UART4, USART_IT_TC) == SET ) &#123; USART_ClearFlag(UART4, USART_FLAG_TC); &#125; //溢出-如果发生溢出需要先读SR,再读DR寄存器则可清除不断入中断的问题 if(USART_GetFlagStatus(UART4,USART_FLAG_ORE) == SET) &#123; USART_ReceiveData(UART4); USART_ClearFlag(UART4,USART_FLAG_ORE); &#125;// USART_ITConfig(UART4, USART_IT_RXNE, DISABLE);//临时关闭接收中断 USART_ClearFlag(UART4,USART_IT_RXNE); //一定要清除接收中断 &#125; //初始化延迟函数//SYSTICK的时钟固定为HCLK时钟的1/8//SYSCLK:系统时钟void Systick_delay_init(u8 SYSCLK)&#123; SysTick-&gt;CTRL&amp;=0xfffffffb;//bit2清空,选择外部时钟 HCLK/8// SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK_Div8); //选择外部时钟 HCLK/8 fac_us=SYSCLK/8; fac_ms=(u16)fac_us*1000;&#125;/*===============================================================================Author:peter panDate: Description: 查询式分时或叫做轮询式（近似延时）。本函数是用于执行高效率场合的查询延时，但是一个for or while 循环中只能用一次。revise Description: @ num : //分时查询的周期计数值 @ unit : //分时查询的周期单位 @@ParaValue ： MS //周期单位为MS毫秒级 US //周期单位为US微秒级@ virtual_delay_status : //静态变量 @@ParaValue ： SET //SYSTICK正在占用中，请勿用 RESET //SYSTICK空闲，可以使用@ReValue : with zero mean Time non-arrive ,one representative Time arrived ,you can do task;##example if(virtual_delay(1000,MS)) LedFlash(); //1000ms LED闪烁一下===============================================================================*/u8 virtual_delay(u32 num,u8 unit)&#123; u32 temp; if(virtual_delay_status==RESET) // SYSTICK空闲，可以使用 &#123; if(unit==MS) &#123; SysTick-&gt;LOAD=(u32)num*Delay_SYSCLK*125;//时间加载(SysTick-&gt;LOAD为24bit) SysTick-&gt;VAL =0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125;else if(unit==US) &#123; SysTick-&gt;LOAD=num*Delay_SYSCLK/8; //时间加载 SysTick-&gt;VAL=0x00; //清空计数器 SysTick-&gt;CTRL=0x01 ; //开始倒数 &#125; virtual_delay_status=SET; return 0; &#125; else &#123; //virtual_delay_status==SET SYSTICK被占用 temp=SysTick-&gt;CTRL; if(!(temp&amp;0x01&amp;&amp;!(temp&amp;(1&lt;&lt;16))))//等待时间到达 &#123; SysTick-&gt;CTRL=0x00; //关闭计数器 SysTick-&gt;VAL =0X00; //清空计数器 virtual_delay_status=RESET; return 1; &#125;else return 0; &#125;&#125; 附上本人这篇博客地址]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[STM32复位及通过函数判断是何种条件出发的复位]]></title>
    <url>%2F2018%2F11%2F11%2FSTM32%E5%A4%8D%E4%BD%8D%E5%8F%8A%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E5%88%A4%E6%96%AD%E6%98%AF%E4%BD%95%E7%A7%8D%E6%9D%A1%E4%BB%B6%E5%87%BA%E5%8F%91%E7%9A%84%E5%A4%8D%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[摘要STM32F10xxx支持三种复位形式，分别为系统复位、上电复位和备份区域复位。本文将通过实际的代码来解释各种情况下，软、硬件导致芯片复位的判别和怎样采取措施。 一、系统复位系统复位将复位所有寄存器至它们的复位状态。 当发生以下任一事件时，产生一个系统复位： NRST引脚上的低电平(外部复位) 2. 窗口看门狗计数终止(WWDG复位) 独立看门狗计数终止(IWDG复位) 软件复位(SW复位) 低功耗管理复位 可通过查看RCC_CSR控制状态寄存器中的复位状态标志位识别复位事件来源。软件复位通过将Cortex™-M3中断应用和复位控制寄存器中的SYSRESETREQ位置’1’，可实现软件复位。请参考Cortex™-M3技术参考手册获得进一步信息。 1.1 低功耗管理复位在以下两种情况下可产生低功耗管理复位： 在进入待机模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STDBY位置’1’将使能该复位。这时，即使执行了进入待机模式的过程，系统将被复位而不是进入待机模式。 在进入停止模式时产生低功耗管理复位： 通过将用户选择字节中的nRST_STOP位置’1’将使能该复位。这时，即使执行了进入停机模式的过程，系统将被复位而不是进入停机模式。关于用户选择字节的进一步信息，请参考STM32F10xxx闪存编程手册。 电源复位电源复位当以下事件中之一发生时，产生电源复位： 上电/掉电复位(POR/PDR复位) 从待机模式中返回 图4) 电源复位将复位除了备份区域外的所有寄存器。(见图中复位源将最终作用于RESET引脚，并在复位过程中保持低电平。复位入口矢量被固定在地址0x0000_0004。 芯片内部的复位信号会在NRST引脚上输出，脉冲发生器保证每一个(外部或内部)复位源都能有至少20μs的脉冲延时；当NRST引脚被拉低产生外部复位时，它将产生复位脉冲。 三、备份域复位 备份区域拥有两个专门的复位，它们只影响备份区域(见图4)。 当以下事件中之一发生时，产生备份区域复位。 软件复位，备份区域复位可由设置备份域控制寄存器 (RCC_BDCR)(见6.3.9节)中的BDRST位产生。 在VDD和VBAT两者掉电的前提下，VDD或VBAT上电将引发备份区域复位。 四、复位的标志位 五、复位标志位检索/判断什么原因导致的复位标志位判断的代码由官方库中给定代码如下： FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)；//FlagStatus 分为SET和RESET两种； 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * @brief Checks whether the specified RCC flag is set or not. * @param RCC_FLAG: specifies the flag to check. * * For @b STM32_Connectivity_line_devices, this parameter can be one of the * following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_PLL2RDY: PLL2 clock ready * @arg RCC_FLAG_PLL3RDY: PLL3 clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * For @b other_STM32_devices, this parameter can be one of the following values: * @arg RCC_FLAG_HSIRDY: HSI oscillator clock ready * @arg RCC_FLAG_HSERDY: HSE oscillator clock ready * @arg RCC_FLAG_PLLRDY: PLL clock ready * @arg RCC_FLAG_LSERDY: LSE oscillator clock ready * @arg RCC_FLAG_LSIRDY: LSI oscillator clock ready * @arg RCC_FLAG_PINRST: Pin reset * @arg RCC_FLAG_PORRST: POR/PDR reset * @arg RCC_FLAG_SFTRST: Software reset * @arg RCC_FLAG_IWDGRST: Independent Watchdog reset * @arg RCC_FLAG_WWDGRST: Window Watchdog reset * @arg RCC_FLAG_LPWRRST: Low Power reset * * @retval The new state of RCC_FLAG (SET or RESET). */FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)&#123; uint32_t tmp = 0; uint32_t statusreg = 0; FlagStatus bitstatus = RESET; /* Check the parameters */ assert_param(IS_RCC_FLAG(RCC_FLAG)); /* Get the RCC register index */ tmp = RCC_FLAG &gt;&gt; 5; if (tmp == 1) /* The flag to check is in CR register */ &#123; statusreg = RCC-&gt;CR; &#125; else if (tmp == 2) /* The flag to check is in BDCR register */ &#123; statusreg = RCC-&gt;BDCR; &#125; else /* The flag to check is in CSR register */ &#123; statusreg = RCC-&gt;CSR; &#125; /* Get the flag position */ tmp = RCC_FLAG &amp; FLAG_Mask; if ((statusreg &amp; ((uint32_t)1 &lt;&lt; tmp)) != (uint32_t)RESET) &#123; bitstatus = SET; &#125; else &#123; bitstatus = RESET; &#125; /* Return the flag status */ return bitstatus;&#125; 当然判断完后，我们需要将复位类型的标志置位以防后期出现重复多次判断 void RCC_ClearFlag(void)；//清除复位执行函数 代码原型如下: 12345678910111213141516171819202122232425262728293031/** * @brief Clears the RCC reset flags. * @note The reset flags are: RCC_FLAG_PINRST, RCC_FLAG_PORRST, RCC_FLAG_SFTRST, * RCC_FLAG_IWDGRST, RCC_FLAG_WWDGRST, RCC_FLAG_LPWRRST * @param None * @retval None */void RCC_ClearFlag(void)&#123; /* Set RMVF bit to clear the reset flags */ RCC-&gt;CSR |= CSR_RMVF_Set;&#125;``` * 在使用时，只需要执行如下语句即可：```Cif(RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET) &#123; //这是上电复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET) &#123; //这是外部RST管脚复位 &#125; else if (RCC_GetFlagStatus(RCC_FLAG_SFTRST)!= RESET) &#123; //这是外部RST管脚复位 &#125; RCC_ClearFlag();//清除RCC中复位标志 六、STM32软件复位方法在Cortex-M3权威指南中有这么一句话这里有一个要注意的问题：从SYSRESETREQ 被置为有效，到复位发生器执行复位命令，往往会有一个延时。在此延时期间，处理器仍然可以响应中断请求。但我们的本意往往是要让此次执行到此为止，不要再做任何其它事情了。所以，最好在发出复位请求前，先把FAULTMASK 置位。所以最好在将FAULTMASK 置位才万无一失。 12345void mcuRestart(void)&#123; __set_FAULTMASK(1); //关闭所有中断 NVIC_SystemReset(); //复位｝]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C语言</tag>
        <tag>嵌入式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之tkinter入坑Pack]]></title>
    <url>%2F2018%2F11%2F11%2Fpython%E4%B9%8Btkinter%E5%85%A5%E5%9D%91Pack%2F</url>
    <content type="text"><![CDATA[摘要：python 中写GUI界面还是有很多方法的，下面我就说说这个tkinter吧，感觉刚上手不久，感觉不好用的样子，可能是我自己的原因导致的用不顺手。这篇主要写tkinter的pack（）方法。 tkinter 的pack()可以设置的属性 我从官网帮助手册中看到的是这样 pack_configure(self, cnf={}, **kw)Pack a widget in the parent widget. Use as options: 12345678910111213after=widget - pack it after you have packed widgetanchor=NSEW (or subset) - position widget according to given directionbefore=widget - pack it before you will pack widgetexpand=bool - expand widget if parent size growsfill=NONE or X or Y or BOTH - fill widget if widget growsin=master - use master to contain this widgetin_=master - see 'in' option descriptionipadx=amount - add internal padding in x directionipady=amount - add internal padding in y directionpadx=amount - add padding in x directionpady=amount - add padding in y directionside=TOP or BOTTOM or LEFT or RIGHT - where to add this widget. 上面的部分中文意思是说 12anchor=NSEW,表示设置我们要加的当前部件的位置side=TOP or BOTTOM or LEFT or RIGHT 表示在父类容器的什么地方家我们的部件 上面的界面代码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#coding:utf-8import tkinter# 导入TK的符号常亮from tkinter.constants import *def sendStr(): print('Data Send Ok!')# 实例化TK类，主窗口必须为.TK(),而其他子窗口为.Toplevel()top = tkinter.Tk()# 设置窗口的尺寸大小top.wm_geometry('320x480+1000+100')# 不允许 改变 窗口的宽和高top.wm_resizable(False,False)# 设置窗口标题top.title('TCP Server')# 设置label标签L1 = tkinter.Label(top, text='TCP Sever;\n20108/09/15', width=15, justify=LEFT, relief=RIDGE, background='#6699ff', )\ .pack_configure(anchor=S, side=TOP, ipady=2, pady=2, fill=NONE)# 设置容器frame1 = tkinter.Frame(top,height=80,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame1.pack(fill=NONE,ipady=2,expand=False)# 添加接收区文字标签L2 = tkinter.Label(frame1,text='接\n收\n区',width=2, justify=LEFT, font=("宋体", 12, "bold"),)\ .pack(padx=2,pady=40,side=LEFT,anchor=N)# 添加接收区的文本框txt1 = tkinter.Text(frame1,width = 40, height = 10).pack(padx=2,pady=10,side=RIGHT,anchor=N)frame2 = tkinter.Frame(top, relief=RIDGE,bg='#3366ff')frame2.pack(fill=X, padx=2,pady=10,side=TOP)# 加一个复选框，一个按键chk_text = 'Hex Display'int_if_choise = tkinter.IntVar()chk1 = tkinter.Checkbutton(frame2,text=chk_text,font=('黑体',12),variable=int_if_choise,onvalue='OK',offvalue='NO')chk1.pack(fill=NONE,side=LEFT,padx=2,pady=10)print('shuchu:',int_if_choise)# 设置容器frame3 = tkinter.Frame(top,height=120,width=60,relief=RIDGE, bg='#ff3399',bd=5,borderwidth=4)# 设置填充和布局frame3.pack(fill=X,ipady=2,expand=False)# 设置字符串变量ServerReceiveVar = tkinter.StringVar(top,'')L3 = tkinter.Label(frame3, text='Cache&amp;Input:',font=('黑体',12))L3.pack(fill=NONE, expand=NO, side=TOP, anchor=W, padx=2,pady=10)txt2 = tkinter.Text(frame3, height = 2, width = 30).pack(padx=2, pady=2, ipady=4, side=LEFT, anchor=N)button1 = tkinter.Button(frame3,text='Send Str', command=sendStr).pack(side=TOP, anchor=W, padx=2, pady=4)# IP 列表button2 = tkinter.Button(frame3,text="Exit",command=top.destroy).pack(side=TOP, anchor=N, padx=2, pady=10)top.mainloop() 123456789101112from Tkinter import *root = Tk()w = Label(root, text="red", bg="red", fg="white")w.pack(padx=5, pady=10, side=LEFT)w = Label(root, text="green", bg="green", fg="black")w.pack(padx=5, pady=20, side=LEFT)w = Label(root, text="blue", bg="blue", fg="white")w.pack(padx=5, pady=20, side=LEFT)mainloop()]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ MFC 界面实现套接字（socket) 通信]]></title>
    <url>%2F2018%2F11%2F10%2FMFC%20%20Socket%20%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[摘要 Socket 套接字的概念 Socket 函数功能 MFC 介绍 TCP 变成步骤 TCP 上位机实现 Socket 套接字的概念引用百度百科的一句话：网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 一段形象的比喻： 建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 Socket的英文原义是“孔”或“插座”。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 SuperSocke,可扩展的 Socket 服务器框架 socket.io github 网页或者官网 Socket 函数功能具体函数如下： socket()函数 bind()函数 connect()函数 listen()函数 accept()函数 send()和recv()函数 sendto()和recvfrom()函数 close()和shutdown()函数 getpeername()函数 gethostname()函数 socket() 函数1int socket(int domine,int type,int protocol); 参数(int domin)： 函数参数，即协议域，又称为协议族。协议族决定了socket的地址类型，在通信中必须采用对应的地址，如AF_INET(IPV4)、AF_INET6(IPV6)、AF_LOCAL（或称AF_UNIX，Unix域socket）、AF_ROUTE等等。通常情况下我们使用AF_INET。 AF_INET的定义是：#define AF_INET 2，所以这里的参数都是int型的 参数(int type)： :是套接口类型，主要SOCK_STREAM(建立TCP连接)、SOCK_DGRAM（建立UDP）、SOCK_RAW；SOCK_STREAM(建立TCP连接)：提供面向连接的可靠的数据传输服务。数据被看作是字节流，无长度限制。例如FTP协议就采用这种。SOCK_DGRAM（建立UDP）：提供无连接的数据传输服务，不保证可靠性。 SOCK_RAW：该接口允许对较低层次协议，如IP，ICMP直接访问。 参数(int protocole)： 指定协议。常用的协议有，IPPROTO_TCP、IPPTOTO_UDP、IPPROTO_SCTP、IPPROTO_TIPC等，它们分别对应TCP传输协议、UDP传输协议、STCP传输协议、TIPC传输协议。通常情况系设为0。 注意：并不是上面的type和protocol可以随意组合的，如SOCK_STREAM不可以跟IPPROTO_UDP组合。当protocol为0时，会自动选择type类型对应的默认协议。 函数返回值(int): 成功：返回套接字描述符（套接字的索引） 失败：返回-1 bind() 函数一旦你有一个套接字，你可能要将套接字和机器上的一定的端口关联 起来。(如果你想用listen()来侦听一定端口的数据，这是必要一步–MUD 告 诉你说用命令 “telnet x.y.z 6969”。)如果你只想用 connect()，那么这个步 骤没有必要。但是无论如何，请继续读下去。 1int bind(int sockfd, struct sockaddr *my_addr, int addrlen); 参数(int sockfd)： sockfd 是调用 socket 返回的文件描述符。 参数(struct sockaddr *my_addr)： my_addr 是指向数据结构 struct sockaddr 的指针，它保存你的地址(即端口和 IP 地址) 信息。 参数(int addrlen)： addrlen 设置为 sizeof(struct sockaddr)。 connect()函数现在我们假设你是个 telnet 程序。你的用户命令你得到套接字的文件 描述符。你听从命令调用了socket()。下一步，你的用户告诉你通过端口 23(标准 telnet 端口)连接到”132.241.5.10”。你该怎么做呢? 幸运的是，你正在阅读 connect()–如何连接到远程主机这一章。你可 不想让你的用户失望。 1int connect(int sockfd, struct sockaddr *serv_addr, int addrlen); 参数(int sockfd)： sockfd 是系统调用 socket() 返回的套接字文件描述符。 参数(struct sockaddr *serv_addr)： serv_addr 是 保存着目的地端口和 IP 地址的数据结构 struct sockaddr。 参数(int addrlen)： addrlen 设置 为 sizeof(struct sockaddr)。 listen()函数是换换内容得时候了。假如你不希望与远程的一个地址相连，或者说， 仅仅是将它踢开，那你就需要等待接入请求并且用各种方法处理它们。处 理过程分两步：首先，你听–listen()，然后，你接受–accept() (请看下面的 内容)。 1int listen(int sockfd, int backlog); 参数(int sockfd)： sockfd 是调用 socket() 返回的套接字文件描述符。 参数(int backlog)： backlog 是在进入 队列中允许的连接数目。 accept()函数send()和recv()函数sendto()和recvfrom()函数close()和shutdown()函数getpeername()函数gethostname()函数本节参考了博文 MFC 介绍TCP 上位机实现]]></content>
      <categories>
        <category>skill</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Socket</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Chrome67版本以后不能离线安装插件的情况]]></title>
    <url>%2F2018%2F11%2F10%2F%E8%A7%A3%E5%86%B3Chrome67%E7%89%88%E6%9C%AC%E4%BB%A5%E5%90%8E%E4%B8%8D%E8%83%BD%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E6%8F%92%E4%BB%B6%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要通过本文安装方法可以快速，解决Chrome67版本以后不能离线安装插件的情况。 一般情况下，我们如果使用的Chrome版本为67以后的版本，安装离线插件会出现如下图信息 但是这样我们就真的没法安装离线插件了吗？特别是对想安装翻墙的插件 Proxy SwitchyOmega 的同学来说是一件噩梦。这篇文章讲会告诉读者，这个问题是可以解决的 解决方法如下： 首代开终端输入以下代码 /opt/google/chrome/google-chrome –enable-easy-off-store-extension-install 将会打开google Chrome 浏览器，然后进入浏览器的扩展插件工具界面，如下图所示： 此时请再次将离线下载的插件拖进去，看看是不是能够安装了。]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vultr+freenom实现主机域名的绑定]]></title>
    <url>%2F2018%2F11%2F10%2Fvultr%2Bfreenom%E5%AE%9E%E7%8E%B0%E4%B8%BB%E6%9C%BA%E5%9F%9F%E5%90%8D%E7%9A%84%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[vultr+freenom实现主机域名的绑定 摘要本文将通过实例进行演示，给大家介绍如何用免费的域名，绑定我们的云主机，只需要登录Freenom注册个账号就可以免费申请免备案域名了，心动请先不要忙行动，点击阅读更多，先看看本文的免费域名申请绑定主机的方法吧。 1、注册freenom域名 进入 freenom 网站,在界面的菜单中选择“Servers”–&gt;”Register a New Domains”，如下图所示: 可能在此之前需要先注册一个账号，具体网站的账号怎么注册，自己摸索下，并不复杂，这里我们只讲怎么注册域名并解析到你的主机。 接下来在“My Domains”页面上的输入框中输入你想注册的免费域名，并搜索下是否已经被注册了，输入框在如下图中的红框所示，例如我输入：smriti 搜索结果显示，好几个是免费的，我们只需要选择一个就行，如下截图所示： 随便选择一个，“Get it now” 即可比如我选择TK域名，然后进入我的购物车，选择免费12个月，如下图： 接下来在USE DNS处选择自己需要解析到的主机IP地址上，也就是把你的云服务器的主机地址填到下图的红框中，Hostname不要动，保持默认（ 一个是yourdot.tk,另一个是www.yourdot.tk ），如下图： 接下来点击“COntinue”即可。 注意如果你现在没有主机IP，你可以先不填，后期再填写，后期填写只需要进入“My Domains” 选择你注册的域名，点击右边的“Manage Domain”，然后选择第四个菜单，”Manage Freenom DNS”,然后添加域名解析到主机，如下图所示： 接下来就是等待，因为域名解析，不会一下子就解析成功的所以你需要等5-30分钟不等，如果一个小时后还是解析不成功，可能就是你的主机IP填写错误 重要的事情再说一遍，就是以上域名解析填写完成后，还需要进行等待，一般5-30分钟。5分钟内访问该网站可能提示解析错误，所以要等待啊。 有的需要主机上面也要填写DNS绑定域名,比如阿里云主机,但是我这是国外的主机和国外的免费域名，好像不要要云主机上面操作，直接在域名服务商网页上绑定主机IP就成功访问了。 2、主机注册 推荐好用的还便宜的云主机：vultr 、 和 搬瓦工 加入你已经购买了云虚拟主机，点击进入主机管理，如下图所示： 添加主机域名绑定 最后一步，主机中绑定域名，如下图：]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>总结</tag>
        <tag>网站</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F11%2F10%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博文]]></title>
    <url>%2F2018%2F11%2F10%2F%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要欢迎来到我的博文主页，你可以进一步了解我，通过聚水渊主页 Hexo !和我的github 写作目的 为了更好的学习 每天总结 看到自己每天的进步 遇见最优秀的自己，下面是我的其他博客地址 我的博客园 我的CSDN 新浪博客 网易博客 说说我之前的英文名和现在的英文名之前我的firstname 是pertor 现在是porter，不是一个人 ？不，是一个人的，因为pertor是西班牙的名字，porter是英文名字。都是一个人。 我的网易云最后我贴下我的网易笔记]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 每次写好后deploy博客]]></title>
    <url>%2F2018%2F11%2F10%2FHexo%20%E6%AF%8F%E6%AC%A1%E5%86%99%E5%A5%BD%E5%90%8Edeploy%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要：github page 结合Hexo-Yelee或者Next主题,搭建个人博客主页，是很不错的一个选择，个人使用情况，感觉Yelee界面布局啥的还是很不错的。 这篇文章中我将介绍每次我们写好的md博文怎么部署到github page 上去。 本文主要使用的命令行如下： 1、直接部署到网站 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 也可以本地部署，查看浏览效果 2、部署到本地，查看浏览效果 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo s 我们每次写好的博文如何正确推送至github每次我们写好了博文后，需要上传至我们的github空间中,只需要每次将我们写好的博文放到文件路径：1D:\Github\smritipertor.github.io\source\_posts 如果之前没有安装过 hexo-deployer-git 的话，先执行： 1npm install hexo-deployer-git --save 然后执行如下命令操作： 首先在你之前建好的博文路径：比如我的是 12345hexo generatehexo s //(或者:hexo server)hexo deploy //(或者:hexo d) 说明 一般我们在站点根目录中的“_config.yml”中的文件中设定我们hexo d，的部署文件到那个ID和分支中，设置内容如下： 1234deploy: type: git repository: https://github.com/smritipertor/smritipertor.github.io.git branch: master 以上内容表示，不管我们当前工作在那个分区，只要站点根目录中的“_config.yml”中branch 分区设置好，直接 1hexo d 就可以发布了。 如果你执行：1hexo generate -d 常见错误及解决办法第一种，部署出错出现错误提示，如下：1fatal: in unpopulated submodule '.deploy_git' FATAL Something's wrong. Maybe you can find the solution here: http://hexo.io/docs/troubleshooting.html Error: fatal: in unpopulated submodule '.deploy_git' at ChildProcess.&lt;anonymous&gt; (D:\GitWebsite\smritipertor.github.io\node_modules\hexo-util\lib\spawn.js:37:17) at ChildProcess.emit (events.js:182:13) at ChildProcess.cp.emit (D:\GitWebsite\smritipertor.github.io\node_modules\cross-spawn\lib\enoent.js:40:29) at maybeClose (internal/child_process.js:962:16) at Process.ChildProcess._handle.onexit (internal/child_process.js:251:5) 则你可以直接执行以下命令即可： 12rm -rf .deploy_githexo generate -d 即，删除地电脑本地的.deploy_git文件夹（可能是你上个版本是另一台电脑），然后再生成、部署即可。 至此你的网站上就有了网站数据]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu 中安装sublime_text3]]></title>
    <url>%2F2018%2F11%2F10%2Fubuntu%20%E4%B8%AD%E5%AE%89%E8%A3%85sublime_text3%2F</url>
    <content type="text"><![CDATA[摘要Porter PanEnter “Alt+m” will show Markdown Preview 安装 输入注册码 汉化 安装插件 中文输入bug修复 1.1 安装&emsp;&emsp;建议和我一样初学的直接安装，不要直接下载官方的离线包解压了，不然还得自己配置什么dash中显示，什么的环境配置乱七八糟的 123451、 wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -2、 sudo apt-get install apt-transport-https3、 echo &quot;deb https://download.sublimetext.com/ apt/stable/&quot; | sudo tee /etc/apt/sources.list.d/sublime-text.list4、 sudo apt-get update5、 sudo apt-get install sublime-text 1.2 输入注册码&emsp;&emsp;在输入注册码之前先更改hosts，ubuntu中hosts位于： vim /etc/hosts或者gedit /etc/hosts,然后加入如下两行 121、 127.0.0.1 www.sublimetext.com2、 127.0.0.1 license.sublimehq.com &emsp;&emsp;然后保存，此时dash中输入sublime，找到我们安装的软件，打开后在界面菜单中选择help–&gt;enter license，然后输入如下注册码12345678910111213----- BEGIN LICENSE -----sgbteamSingle User LicenseEA7E-11532598891CBB9 F1513E4F 1A3405C1 A865D53F115F202E 7B91AB2D 0D2A40ED 352B269B76E84F0B CD69BFC7 59F2DFEF E267328F215652A3 E88F9D8F 4C38E3BA 5B2DAAE4969624E7 DC9CD4D5 717FB40C 1B9738CF20B3C4F1 E917B5B3 87C38D9C ACCE7DD85F7EF854 86B9743C FADC04AA FB0DA5C0F913BE58 42FEA319 F954EFDD AE881E0B------ END LICENSE ------ 点击确定，然后就可以 enjoy it! 在这还没结束，下面开始汉化 1.3 汉化 &emsp;&emsp;打开软件，直接按下“shift+ctrl+p”在弹出的框内输入ip,然后点击”package control：install pakage”,出来后输入”Chinese​Localizations”来安装Chinese​Localizations插件，然后重启，至此汉化结束。 1.4 安装markdown插件 &emsp;&emsp;在软件界面输入“shift+ctrl+p”,然后输入“ip”，然后选择，packageinstall ，然后输入“Markdown Editing“ + ”MarkdownLivePreview”,分别安装上，然后新建md文件，在编辑界面输入“alt+m”,则进入markdown preview实时显示模式。 1.5 解决Markdown不能输入汉字的问题打开终端： 在终端中输入以下代码12git clone https://github.com/lyfeyaj/sublime-text-imfix.gitcd sublime-text-imfix &amp;&amp; ./sublime-imfix 或者直接进入github的这个仓库：直接下载这个zip包，然后解压，然后在终端中cd到这个解压后的文件夹路径中，最后是在终端中输入1./sublime-imfix 此时重启sublimetext3 然后就可以进行汉字的输入了。 参考：https://blog.csdn.net/qq_41590417/article/details/80461075 https://blog.csdn.net/woaidouya123/article/details/81476551 https://www.cnblogs.com/james-lee/p/6847906.html]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>sublime-text</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 推送新的文章到github其他分支上]]></title>
    <url>%2F2018%2F11%2F10%2Fgit-%E6%8E%A8%E9%80%81%E6%96%B0%E7%9A%84%E6%96%87%E7%AB%A0%E5%88%B0github%E5%85%B6%E4%BB%96%E5%88%86%E6%94%AF%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要每次编辑博文并通过命令部署网站到github page上时，我们想每天都能将改动后的博文备份到github的一个分支上，实现本地数据同步到云仓库中。 实现本地博客云同步到github page其他分支上 实现本地博客部署到github page上的master分支上 网站部署（建议隔段时间再部署到网站上，短时间内直接部署本地，本地浏览下就好部署到网上 直接部署到github page的master上 123451 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git pull origin proworking #从我的工作分支更新最新的博文和站点配置文件3 git checkout master #将我们的本地切换到master分支4 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中5 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 部署到本地 本地部署，本地浏览效果 12341 git clone -b proworking &lt;我的github网站仓库:proworking&gt;2 git checkout master #将我们的本地切换到master分支3 #此处开始加入你的博文.md到站点的：\source\_posts文件夹中4 hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 实现从github上获取我仓库中的Proworking分支数据，病拉取到我的本地 将本地的博文再重新push到我的云仓库（proworking) 123git add .git commit -m "添加了：file1.md\file2.md"git push origin HEAD:proworking #一定要添加HEAD 不然会 其他注意事项 下面贴上我遇到的问题 [1] 若果你直接输入命令：1$ git push proworking 可能会出现如下的不正常信息： 12345678Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push proworkingfatal: 'proworking' does not appear to be a git repositoryfatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 正确的解决办法是，命令中输入如下代码（加HEAD) 12Pertor@Pertor-PC MINGW64 /d/Github/smritipertor.github.io (master)$ git push origin HEAD:proworking 此时会输出正确的提示，具体提示信息如下： 123456789Enumerating objects: 1498, done.Counting objects: 100% (1480/1480), done.Delta compression using up to 4 threadsCompressing objects: 100% (1219/1219), done.Writing objects: 100% (1461/1461), 1.17 MiB | 390.00 KiB/s, done.Total 1461 (delta 187), reused 1300 (delta 139)remote: Resolving deltas: 100% (187/187), completed with 10 local objects.To https://github.com/smritipertor/smritipertor.github.io.git 06b21dd..1ff56b7 HEAD -&gt; proworking]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu18 正确 安装ShadowSocket]]></title>
    <url>%2F2018%2F11%2F10%2Fubuntu18-%E6%AD%A3%E7%A1%AE-%E5%AE%89%E8%A3%85ShadowSocket%2F</url>
    <content type="text"><![CDATA[ubuntu18 正确安装shadowsocket 摘要为达到能够自由访问全球学习资料，我可谓是绞尽脑汁莫寻方法，目前能做到的除了付费包月的vpn代理机构的，就只能是自己动手自己干的了，但是自己搞旺旺会出很多问题，本文结合晴子实践的经验，将所遇到的问题都一一列下并解决。 1、正常的安装步骤（ubuntu16版本）1234* Ctrl+Alt+T打开终端，输入以下命令安装好GUI界面shadowsocks-qt5* sudo add-apt-repository ppa:hzwhuang/ss-qt5* sudo apt-get update* sudo apt-get install shadowsocks-qt5 但是Ubuntu18.04在安装shadowsocks-qt5时就会出现错误 1仓库 “http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu bionic Release” 没有 Release 文件 原因： ppa:hzwhuang/ss-qt5 并没有18.04版本的源 解决方法：第一步、修改sources.list.d下文件名修改/etc/apt/sources.list.d/hzwhuang-ubuntu-ss-qt5-bionic.list文件，将bionic（18.04版本代号）改成xenial（16.04版本代号） 第二步、设置如下图 bash 中打开软件更新器 —&gt; 设置 —&gt; 其他软件 –&gt; 编辑：http://ppa.launchpad.net/hzwhuang/ss-qt5/ubuntu 将发行版改为xenial ,如上图所示。 然后再执行 sudo apt-get update sudo apt-get install shadowsocks-qt5]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Socket5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python Tkinter 界面实现套接字（socket) 通信]]></title>
    <url>%2F2018%2F09%2F10%2FPython%20GUI%20Socket%2F</url>
    <content type="text"><![CDATA[Porter Pan 摘要]]></content>
      <categories>
        <category>summary</category>
      </categories>
      <tags>
        <tag>GUI</tag>
        <tag>日记</tag>
        <tag>总结</tag>
      </tags>
  </entry>
</search>
